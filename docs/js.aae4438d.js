parcelRequire = function (e, r, t, n) { var i, o = "function" == typeof parcelRequire && parcelRequire, u = "function" == typeof require && require; function f(t, n) { if (!r[t]) { if (!e[t]) { var i = "function" == typeof parcelRequire && parcelRequire; if (!n && i) return i(t, !0); if (o) return o(t, !0); if (u && "string" == typeof t) return u(t); var c = new Error("Cannot find module '" + t + "'"); throw c.code = "MODULE_NOT_FOUND", c } p.resolve = function (r) { return e[t][1][r] || r }, p.cache = {}; var l = r[t] = new f.Module(t); e[t][0].call(l.exports, p, l, l.exports, this) } return r[t].exports; function p(e) { return f(p.resolve(e)) } } f.isParcelRequire = !0, f.Module = function (e) { this.id = e, this.bundle = f, this.exports = {} }, f.modules = e, f.cache = r, f.parent = o, f.register = function (r, t) { e[r] = [function (e, r) { r.exports = t }, {}] }; for (var c = 0; c < t.length; c++)try { f(t[c]) } catch (e) { i || (i = e) } if (t.length) { var l = f(t[t.length - 1]); "object" == typeof exports && "undefined" != typeof module ? module.exports = l : "function" == typeof define && define.amd ? define(function () { return l }) : n && (this[n] = l) } if (parcelRequire = f, i) throw i; return f }({
    "tWCa": [function (require, module, exports) {
        var global = arguments[3];
        var e = arguments[3]; function t(e, t) { const o = Object.create(null), r = e.split(","); for (let s = 0; s < r.length; s++)o[r[s]] = !0; return t ? e => !!o[e.toLowerCase()] : e => !!o[e] } Object.defineProperty(exports, "__esModule", { value: !0 }), exports.escapeHtml = A, exports.escapeHtmlComment = E, exports.generateCodeFrame = a, exports.isSSRSafeAttrName = u, exports.looseEqual = R, exports.looseIndexOf = F, exports.makeMap = t, exports.normalizeClass = w, exports.normalizeStyle = x, exports.parseStringStyle = y, exports.stringifyStyle = S, exports.toTypeString = exports.toRawType = exports.toNumber = exports.toHandlerKey = exports.toDisplayString = exports.remove = exports.propsToAttrMap = exports.objectToString = exports.isVoidTag = exports.isSymbol = exports.isString = exports.isSpecialBooleanAttr = exports.isSet = exports.isSVGTag = exports.isReservedProp = exports.isPromise = exports.isPlainObject = exports.isOn = exports.isObject = exports.isNoUnitNumericStyleProp = exports.isModelListener = exports.isMap = exports.isKnownAttr = exports.isIntegerKey = exports.isHTMLTag = exports.isGloballyWhitelisted = exports.isFunction = exports.isDate = exports.isBooleanAttr = exports.isArray = exports.invokeArrayFns = exports.hyphenate = exports.hasOwn = exports.hasChanged = exports.getGlobalThis = exports.extend = exports.def = exports.capitalize = exports.camelize = exports.babelParserDefaultPlugins = exports.PatchFlagNames = exports.NOOP = exports.NO = exports.EMPTY_OBJ = exports.EMPTY_ARR = void 0; const o = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "HYDRATE_EVENTS", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 1024: "DYNAMIC_SLOTS", 512: "NEED_PATCH", [-1]: "HOISTED", [-2]: "BAIL" }; exports.PatchFlagNames = o; const r = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl", s = t(r); exports.isGloballyWhitelisted = s; const n = 2; function a(e, t = 0, o = e.length) { const r = e.split(/\r?\n/); let s = 0; const a = []; for (let i = 0; i < r.length; i++)if ((s += r[i].length + 1) >= t) { for (let e = i - n; e <= i + n || o > s; e++) { if (e < 0 || e >= r.length) continue; const n = e + 1; a.push(`${n}${" ".repeat(Math.max(3 - String(n).length, 0))}|  ${r[e]}`); const p = r[e].length; if (e === i) { const e = t - (s - p) + 1, r = Math.max(1, o > s ? p - e : o - t); a.push("   |  " + " ".repeat(e) + "^".repeat(r)) } else if (e > i) { if (o > s) { const e = Math.max(Math.min(o - s, p), 1); a.push("   |  " + "^".repeat(e)) } s += p + 1 } } break } return a.join("\n") } const i = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", p = t(i); exports.isSpecialBooleanAttr = p; const l = t(i + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"); exports.isBooleanAttr = l; const c = /[>/="'\u0009\u000a\u000c\u0020]/, d = {}; function u(e) { if (d.hasOwnProperty(e)) return d[e]; const t = c.test(e); return t && console.error(`unsafe attribute name: ${e}`), d[e] = !t } const f = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }; exports.propsToAttrMap = f; const g = t("animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width"); exports.isNoUnitNumericStyleProp = g; const m = t("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"); function x(e) { if (J(e)) { const t = {}; for (let o = 0; o < e.length; o++) { const r = e[o], s = x(ee(r) ? y(r) : r); if (s) for (const e in s) t[e] = s[e] } return t } if (oe(e)) return e } exports.isKnownAttr = m; const h = /;(?![^(]*\))/g, b = /:(.+)/; function y(e) { const t = {}; return e.split(h).forEach(e => { if (e) { const o = e.split(b); o.length > 1 && (t[o[0].trim()] = o[1].trim()) } }), t } function S(e) { let t = ""; if (!e) return t; for (const o in e) { const r = e[o], s = o.startsWith("--") ? o : ge(o); (ee(r) || "number" == typeof r && g(s)) && (t += `${s}:${r};`) } return t } function w(e) { let t = ""; if (ee(e)) t = e; else if (J(e)) for (let o = 0; o < e.length; o++)t += w(e[o]) + " "; else if (oe(e)) for (const o in e) e[o] && (t += o + " "); return t.trim() } const O = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", T = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", k = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", M = t(O); exports.isHTMLTag = M; const P = t(T); exports.isSVGTag = P; const v = t(k); exports.isVoidTag = v; const N = /["'&<>]/; function A(e) { const t = "" + e, o = N.exec(t); if (!o) return t; let r, s, n = "", a = 0; for (s = o.index; s < t.length; s++) { switch (t.charCodeAt(s)) { case 34: r = "&quot;"; break; case 38: r = "&amp;"; break; case 39: r = "&#39;"; break; case 60: r = "&lt;"; break; case 62: r = "&gt;"; break; default: continue }a !== s && (n += t.substring(a, s)), a = s + 1, n += r } return a !== s ? n + t.substring(a, s) : n } const j = /^-?>|<!--|-->|--!>|<!-$/g; function E(e) { return e.replace(j, "") } function C(e, t) { if (e.length !== t.length) return !1; let o = !0; for (let r = 0; o && r < e.length; r++)o = R(e[r], t[r]); return o } function R(e, t) { if (e === t) return !0; let o = Z(e), r = Z(t); if (o || r) return !(!o || !r) && e.getTime() === t.getTime(); if (o = J(e), r = J(t), o || r) return !(!o || !r) && C(e, t); if (o = oe(e), r = oe(t), o || r) { if (!o || !r) return !1; if (Object.keys(e).length !== Object.keys(t).length) return !1; for (const o in e) { const r = e.hasOwnProperty(o), s = t.hasOwnProperty(o); if (r && !s || !r && s || !R(e[o], t[o])) return !1 } } return String(e) === String(t) } function F(e, t) { return e.findIndex(e => R(e, t)) } const D = e => null == e ? "" : oe(e) ? JSON.stringify(e, L, 2) : String(e); exports.toDisplayString = D; const L = (e, t) => W(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((e, [t, o]) => (e[`${t} =>`] = o, e), {}) } : X(t) ? { [`Set(${t.size})`]: [...t.values()] } : !oe(t) || J(t) || ie(t) ? t : String(t), I = ["bigInt", "optionalChaining", "nullishCoalescingOperator"]; exports.babelParserDefaultPlugins = I; const z = {}; exports.EMPTY_OBJ = z; const B = []; exports.EMPTY_ARR = B; const U = () => { }; exports.NOOP = U; const G = () => !1; exports.NO = G; const _ = /^on[^a-z]/, $ = e => _.test(e); exports.isOn = $; const V = e => e.startsWith("onUpdate:"); exports.isModelListener = V; const q = Object.assign; exports.extend = q; const H = (e, t) => { const o = e.indexOf(t); o > -1 && e.splice(o, 1) }; exports.remove = H; const Y = Object.prototype.hasOwnProperty, K = (e, t) => Y.call(e, t); exports.hasOwn = K; const J = Array.isArray; exports.isArray = J; const W = e => "[object Map]" === ne(e); exports.isMap = W; const X = e => "[object Set]" === ne(e); exports.isSet = X; const Z = e => e instanceof Date; exports.isDate = Z; const Q = e => "function" == typeof e; exports.isFunction = Q; const ee = e => "string" == typeof e; exports.isString = ee; const te = e => "symbol" == typeof e; exports.isSymbol = te; const oe = e => null !== e && "object" == typeof e; exports.isObject = oe; const re = e => oe(e) && Q(e.then) && Q(e.catch); exports.isPromise = re; const se = Object.prototype.toString; exports.objectToString = se; const ne = e => se.call(e); exports.toTypeString = ne; const ae = e => ne(e).slice(8, -1); exports.toRawType = ae; const ie = e => "[object Object]" === ne(e); exports.isPlainObject = ie; const pe = e => ee(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e; exports.isIntegerKey = pe; const le = t(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"); exports.isReservedProp = le; const ce = e => { const t = Object.create(null); return o => { return t[o] || (t[o] = e(o)) } }, de = /-(\w)/g, ue = ce(e => e.replace(de, (e, t) => t ? t.toUpperCase() : "")); exports.camelize = ue; const fe = /\B([A-Z])/g, ge = ce(e => e.replace(fe, "-$1").toLowerCase()); exports.hyphenate = ge; const me = ce(e => e.charAt(0).toUpperCase() + e.slice(1)); exports.capitalize = me; const xe = ce(e => e ? `on${me(e)}` : ""); exports.toHandlerKey = xe; const he = (e, t) => e !== t && (e == e || t == t); exports.hasChanged = he; const be = (e, t) => { for (let o = 0; o < e.length; o++)e[o](t) }; exports.invokeArrayFns = be; const ye = (e, t, o) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, value: o }) }; exports.def = ye; const Se = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let we; exports.toNumber = Se; const Oe = () => we || (we = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== e ? e : {}); exports.getGlobalThis = Oe;
    }, {}], "JZte": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.computed = Ie, exports.customRef = Me, exports.effect = a, exports.enableTracking = p, exports.isProxy = ve, exports.isReactive = de, exports.isReadonly = pe, exports.isRef = Re, exports.markRaw = ye, exports.pauseTracking = d, exports.proxyRefs = Ae, exports.reactive = ue, exports.readonly = fe, exports.ref = xe, exports.resetTracking = v, exports.shallowReactive = le, exports.shallowReadonly = he, exports.shallowRef = be, exports.stop = c, exports.toRaw = ge, exports.toRef = ze, exports.toRefs = Pe, exports.track = g, exports.trigger = y, exports.triggerRef = Oe, exports.unref = me, exports.ITERATE_KEY = void 0; var e = require("@vue/shared"); const t = new WeakMap, n = []; let s; const r = Symbol(""); exports.ITERATE_KEY = r; const i = Symbol(""); function o(e) { return e && !0 === e._isEffect } function a(t, n = e.EMPTY_OBJ) { o(t) && (t = t.raw); const s = l(t, n); return n.lazy || s(), s } function c(e) { e.active && (f(e), e.options.onStop && e.options.onStop(), e.active = !1) } let u = 0; function l(e, t) { const r = function () { if (!r.active) return t.scheduler ? void 0 : e(); if (!n.includes(r)) { f(r); try { return p(), n.push(r), s = r, e() } finally { n.pop(), v(), s = n[n.length - 1] } } }; return r.id = u++, r.allowRecurse = !!t.allowRecurse, r._isEffect = !0, r.active = !0, r.raw = e, r.deps = [], r.options = t, r } function f(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } } let h = !0; const _ = []; function d() { _.push(h), h = !1 } function p() { _.push(h), h = !0 } function v() { const e = _.pop(); h = void 0 === e || e } function g(e, n, r) { if (!h || void 0 === s) return; let i = t.get(e); i || t.set(e, i = new Map); let o = i.get(r); o || i.set(r, o = new Set), o.has(s) || (o.add(s), s.deps.push(o)) } function y(n, o, a, c, u, l) { const f = t.get(n); if (!f) return; const h = new Set, _ = e => { e && e.forEach(e => { (e !== s || e.allowRecurse) && h.add(e) }) }; if ("clear" === o) f.forEach(_); else if ("length" === a && (0, e.isArray)(n)) f.forEach((e, t) => { ("length" === t || t >= c) && _(e) }); else switch (void 0 !== a && _(f.get(a)), o) { case "add": (0, e.isArray)(n) ? (0, e.isIntegerKey)(a) && _(f.get("length")) : (_(f.get(r)), (0, e.isMap)(n) && _(f.get(i))); break; case "delete": (0, e.isArray)(n) || (_(f.get(r)), (0, e.isMap)(n) && _(f.get(i))); break; case "set": (0, e.isMap)(n) && _(f.get(r)) }h.forEach(e => { e.options.scheduler ? e.options.scheduler(e) : e() }) } const w = new Set(Object.getOwnPropertyNames(Symbol).map(e => Symbol[e]).filter(e.isSymbol)), R = O(), x = O(!1, !0), b = O(!0), E = O(!0, !0), k = {}; function O(t = !1, n = !1) { return function (s, r, i) { if ("__v_isReactive" === r) return !t; if ("__v_isReadonly" === r) return t; if ("__v_raw" === r && i === (t ? oe : ie).get(s)) return s; const o = (0, e.isArray)(s); if (o && (0, e.hasOwn)(k, r)) return Reflect.get(k, r, i); const a = Reflect.get(s, r, i); if ((0, e.isSymbol)(r) ? w.has(r) : "__proto__" === r || "__v_isRef" === r) return a; if (t || g(s, "get", r), n) return a; if (Re(a)) { return !o || !(0, e.isIntegerKey)(r) ? a.value : a } return (0, e.isObject)(a) ? t ? fe(a) : ue(a) : a } } ["includes", "indexOf", "lastIndexOf"].forEach(e => { const t = Array.prototype[e]; k[e] = function (...e) { const n = ge(this); for (let t = 0, r = this.length; t < r; t++)g(n, "get", t + ""); const s = t.apply(n, e); return -1 === s || !1 === s ? t.apply(n, e.map(ge)) : s } }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => { const t = Array.prototype[e]; k[e] = function (...e) { d(); const n = t.apply(this, e); return v(), n } }); const m = A(), S = A(!0); function A(t = !1) { return function (n, s, r, i) { const o = n[s]; if (!t && (r = ge(r), !(0, e.isArray)(n) && Re(o) && !Re(r))) return o.value = r, !0; const a = (0, e.isArray)(n) && (0, e.isIntegerKey)(s) ? Number(s) < n.length : (0, e.hasOwn)(n, s), c = Reflect.set(n, s, r, i); return n === ge(i) && (a ? (0, e.hasChanged)(r, o) && y(n, "set", s, r, o) : y(n, "add", s, r)), c } } function j(t, n) { const s = (0, e.hasOwn)(t, n), r = t[n], i = Reflect.deleteProperty(t, n); return i && s && y(t, "delete", n, void 0, r), i } function M(t, n) { const s = Reflect.has(t, n); return (0, e.isSymbol)(n) && w.has(n) || g(t, "has", n), s } function P(t) { return g(t, "iterate", (0, e.isArray)(t) ? "length" : r), Reflect.ownKeys(t) } const T = { get: R, set: m, deleteProperty: j, has: M, ownKeys: P }, z = { get: b, set: (e, t) => !0, deleteProperty: (e, t) => !0 }, K = (0, e.extend)({}, T, { get: x, set: S }), I = (0, e.extend)({}, z, { get: E }), W = t => (0, e.isObject)(t) ? ue(t) : t, C = t => (0, e.isObject)(t) ? fe(t) : t, N = e => e, V = e => Reflect.getPrototypeOf(e); function Y(e, t, n = !1, s = !1) { const r = ge(e = e.__v_raw), i = ge(t); t !== i && !n && g(r, "get", t), !n && g(r, "get", i); const { has: o } = V(r), a = n ? C : s ? N : W; return o.call(r, t) ? a(e.get(t)) : o.call(r, i) ? a(e.get(i)) : void 0 } function B(e, t = !1) { const n = this.__v_raw, s = ge(n), r = ge(e); return e !== r && !t && g(s, "has", e), !t && g(s, "has", r), e === r ? n.has(e) : n.has(e) || n.has(r) } function F(e, t = !1) { return e = e.__v_raw, !t && g(ge(e), "iterate", r), Reflect.get(e, "size", e) } function $(e) { e = ge(e); const t = ge(this), n = V(t).has.call(t, e), s = t.add(e); return n || y(t, "add", e, e), s } function q(t, n) { n = ge(n); const s = ge(this), { has: r, get: i } = V(s); let o = r.call(s, t); o || (t = ge(t), o = r.call(s, t)); const a = i.call(s, t), c = s.set(t, n); return o ? (0, e.hasChanged)(n, a) && y(s, "set", t, n, a) : y(s, "add", t, n), c } function J(e) { const t = ge(this), { has: n, get: s } = V(t); let r = n.call(t, e); r || (e = ge(e), r = n.call(t, e)); const i = s ? s.call(t, e) : void 0, o = t.delete(e); return r && y(t, "delete", e, void 0, i), o } function D() { const e = ge(this), t = 0 !== e.size, n = e.clear(); return t && y(e, "clear", void 0, void 0, void 0), n } function G(e, t) { return function (n, s) { const i = this, o = i.__v_raw, a = ge(o), c = e ? C : t ? N : W; return !e && g(a, "iterate", r), o.forEach((e, t) => n.call(s, c(e), c(t), i)) } } function H(t, n, s) { return function (...o) { const a = this.__v_raw, c = ge(a), u = (0, e.isMap)(c), l = "entries" === t || t === Symbol.iterator && u, f = "keys" === t && u, h = a[t](...o), _ = n ? C : s ? N : W; return !n && g(c, "iterate", f ? i : r), { next() { const { value: e, done: t } = h.next(); return t ? { value: e, done: t } : { value: l ? [_(e[0]), _(e[1])] : _(e), done: t } }, [Symbol.iterator]() { return this } } } } function L(e) { return function (...t) { return "delete" !== e && this } } const Q = { get(e) { return Y(this, e) }, get size() { return F(this) }, has: B, add: $, set: q, delete: J, clear: D, forEach: G(!1, !1) }, U = { get(e) { return Y(this, e, !1, !0) }, get size() { return F(this) }, has: B, add: $, set: q, delete: J, clear: D, forEach: G(!1, !0) }, X = { get(e) { return Y(this, e, !0) }, get size() { return F(this, !0) }, has(e) { return B.call(this, e, !0) }, add: L("add"), set: L("set"), delete: L("delete"), clear: L("clear"), forEach: G(!0, !1) }, Z = ["keys", "values", "entries", Symbol.iterator]; function ee(t, n) { const s = n ? U : t ? X : Q; return (n, r, i) => "__v_isReactive" === r ? !t : "__v_isReadonly" === r ? t : "__v_raw" === r ? n : Reflect.get((0, e.hasOwn)(s, r) && r in n ? s : n, r, i) } Z.forEach(e => { Q[e] = H(e, !1, !1), X[e] = H(e, !0, !1), U[e] = H(e, !1, !0) }); const te = { get: ee(!1, !1) }, ne = { get: ee(!1, !0) }, se = { get: ee(!0, !1) }; function re(t, n, s) { const r = ge(s); if (r !== s && n.call(t, r)) { const n = (0, e.toRawType)(t); console.warn(`Reactive ${n} contains both the raw and reactive ` + `versions of the same object${"Map" === n ? " as keys" : ""}, ` + "which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.") } } const ie = new WeakMap, oe = new WeakMap; function ae(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function ce(t) { return t.__v_skip || !Object.isExtensible(t) ? 0 : ae((0, e.toRawType)(t)) } function ue(e) { return e && e.__v_isReadonly ? e : _e(e, !1, T, te) } function le(e) { return _e(e, !1, K, ne) } function fe(e) { return _e(e, !0, z, se) } function he(e) { return _e(e, !0, I, se) } function _e(t, n, s, r) { if (!(0, e.isObject)(t)) return t; if (t.__v_raw && (!n || !t.__v_isReactive)) return t; const i = n ? oe : ie, o = i.get(t); if (o) return o; const a = ce(t); if (0 === a) return t; const c = new Proxy(t, 2 === a ? r : s); return i.set(t, c), c } function de(e) { return pe(e) ? de(e.__v_raw) : !(!e || !e.__v_isReactive) } function pe(e) { return !(!e || !e.__v_isReadonly) } function ve(e) { return de(e) || pe(e) } function ge(e) { return e && ge(e.__v_raw) || e } function ye(t) { return (0, e.def)(t, "__v_skip", !0), t } const we = t => (0, e.isObject)(t) ? ue(t) : t; function Re(e) { return Boolean(e && !0 === e.__v_isRef) } function xe(e) { return ke(e) } function be(e) { return ke(e, !0) } class Ee { constructor(e, t = !1) { this._rawValue = e, this._shallow = t, this.__v_isRef = !0, this._value = t ? e : we(e) } get value() { return g(ge(this), "get", "value"), this._value } set value(t) { (0, e.hasChanged)(ge(t), this._rawValue) && (this._rawValue = t, this._value = this._shallow ? t : we(t), y(ge(this), "set", "value", t)) } } function ke(e, t = !1) { return Re(e) ? e : new Ee(e, t) } function Oe(e) { y(ge(e), "set", "value", void 0) } function me(e) { return Re(e) ? e.value : e } const Se = { get: (e, t, n) => me(Reflect.get(e, t, n)), set: (e, t, n, s) => { const r = e[t]; return Re(r) && !Re(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s) } }; function Ae(e) { return de(e) ? e : new Proxy(e, Se) } class je { constructor(e) { this.__v_isRef = !0; const { get: t, set: n } = e(() => g(this, "get", "value"), () => y(this, "set", "value")); this._get = t, this._set = n } get value() { return this._get() } set value(e) { this._set(e) } } function Me(e) { return new je(e) } function Pe(t) { const n = (0, e.isArray)(t) ? new Array(t.length) : {}; for (const e in t) n[e] = ze(t, e); return n } class Te { constructor(e, t) { this._object = e, this._key = t, this.__v_isRef = !0 } get value() { return this._object[this._key] } set value(e) { this._object[this._key] = e } } function ze(e, t) { return Re(e[t]) ? e[t] : new Te(e, t) } class Ke { constructor(e, t, n) { this._setter = t, this._dirty = !0, this.__v_isRef = !0, this.effect = a(e, { lazy: !0, scheduler: () => { this._dirty || (this._dirty = !0, y(ge(this), "set", "value")) } }), this.__v_isReadonly = n } get value() { return this._dirty && (this._value = this.effect(), this._dirty = !1), g(ge(this), "get", "value"), this._value } set value(e) { this._setter(e) } } function Ie(t) { let n, s; return (0, e.isFunction)(t) ? (n = t, s = e.NOOP) : (n = t.get, s = t.set), new Ke(n, s, (0, e.isFunction)(t) || !t.set) }
    }, { "@vue/shared": "tWCa" }], "gmz5": [function (require, module, exports) {
        var global = arguments[3];
        var e = arguments[3]; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.callWithAsyncErrorHandling = h, exports.callWithErrorHandling = f, exports.cloneVNode = co, exports.computed = sr, exports.createBlock = Xt, exports.createCommentVNode = po, exports.createHydrationRenderer = bt, exports.createRenderer = _t, exports.createSlots = mr, exports.createStaticVNode = uo, exports.createTextVNode = ao, exports.defineAsyncComponent = lr, exports.defineComponent = ir, exports.getTransitionRawChildren = Mn, exports.h = ar, exports.handleError = m, exports.initCustomFormatter = dr, exports.inject = vo, exports.isVNode = Zt, exports.mergeProps = go, exports.nextTick = A, exports.onActivated = In, exports.onDeactivated = Ln, exports.openBlock = Kt, exports.popScopeId = De, exports.provide = yo, exports.pushScopeId = Le, exports.queuePostFlushCb = $, exports.registerRuntimeCompiler = Wo, exports.renderList = fr, exports.renderSlot = $e, exports.resolveComponent = jt, exports.resolveDirective = Nt, exports.resolveDynamicComponent = $t, exports.resolveTransitionHooks = Sn, exports.setBlockTracking = Qt, exports.setDevtoolsHook = Z, exports.setTransitionHooks = Bn, exports.toHandlers = hr, exports.transformVNodeArgs = no, exports.useTransitionState = wn, exports.warn = i, exports.watch = bn, exports.watchEffect = xn, exports.withCtx = Ne, exports.withDirectives = nt, exports.withScopeId = Ye, Object.defineProperty(exports, "customRef", { enumerable: !0, get: function () { return n.customRef } }), Object.defineProperty(exports, "isProxy", { enumerable: !0, get: function () { return n.isProxy } }), Object.defineProperty(exports, "isReactive", { enumerable: !0, get: function () { return n.isReactive } }), Object.defineProperty(exports, "isReadonly", { enumerable: !0, get: function () { return n.isReadonly } }), Object.defineProperty(exports, "isRef", { enumerable: !0, get: function () { return n.isRef } }), Object.defineProperty(exports, "markRaw", { enumerable: !0, get: function () { return n.markRaw } }), Object.defineProperty(exports, "proxyRefs", { enumerable: !0, get: function () { return n.proxyRefs } }), Object.defineProperty(exports, "reactive", { enumerable: !0, get: function () { return n.reactive } }), Object.defineProperty(exports, "readonly", { enumerable: !0, get: function () { return n.readonly } }), Object.defineProperty(exports, "ref", { enumerable: !0, get: function () { return n.ref } }), Object.defineProperty(exports, "shallowReactive", { enumerable: !0, get: function () { return n.shallowReactive } }), Object.defineProperty(exports, "shallowReadonly", { enumerable: !0, get: function () { return n.shallowReadonly } }), Object.defineProperty(exports, "shallowRef", { enumerable: !0, get: function () { return n.shallowRef } }), Object.defineProperty(exports, "toRaw", { enumerable: !0, get: function () { return n.toRaw } }), Object.defineProperty(exports, "toRef", { enumerable: !0, get: function () { return n.toRef } }), Object.defineProperty(exports, "toRefs", { enumerable: !0, get: function () { return n.toRefs } }), Object.defineProperty(exports, "triggerRef", { enumerable: !0, get: function () { return n.triggerRef } }), Object.defineProperty(exports, "unref", { enumerable: !0, get: function () { return n.unref } }), Object.defineProperty(exports, "camelize", { enumerable: !0, get: function () { return t.camelize } }), Object.defineProperty(exports, "capitalize", { enumerable: !0, get: function () { return t.capitalize } }), Object.defineProperty(exports, "toDisplayString", { enumerable: !0, get: function () { return t.toDisplayString } }), Object.defineProperty(exports, "toHandlerKey", { enumerable: !0, get: function () { return t.toHandlerKey } }), exports.version = exports.useSSRContext = exports.ssrUtils = exports.ssrContextKey = exports.onUpdated = exports.onUnmounted = exports.onRenderTriggered = exports.onRenderTracked = exports.onMounted = exports.onErrorCaptured = exports.onBeforeUpdate = exports.onBeforeUnmount = exports.onBeforeMount = exports.getCurrentInstance = exports.devtools = exports.createVNode = exports.Text = exports.Teleport = exports.Suspense = exports.Static = exports.KeepAlive = exports.Fragment = exports.Comment = exports.BaseTransition = void 0; var n = require("@vue/reactivity"), t = require("@vue/shared"); const o = []; function r(e) { o.push(e) } function s() { o.pop() } function i(e, ...t) { (0, n.pauseTracking)(); const r = o.length ? o[o.length - 1].component : null, s = r && r.appContext.config.warnHandler, i = l(); if (s) f(s, r, 11, [e + t.join(""), r && r.proxy, i.map(({ vnode: e }) => `at <${or(r, e.type)}>`).join("\n"), i]); else { const n = [`[Vue warn]: ${e}`, ...t]; i.length && n.push("\n", ...c(i)), console.warn(...n) } (0, n.resetTracking)() } function l() { let e = o[o.length - 1]; if (!e) return []; const n = []; for (; e;) { const t = n[0]; t && t.vnode === e ? t.recurseCount++ : n.push({ vnode: e, recurseCount: 0 }); const o = e.component && e.component.parent; e = o && o.vnode } return n } function c(e) { const n = []; return e.forEach((e, t) => { n.push(...0 === t ? [] : ["\n"], ...a(e)) }), n } function a({ vnode: e, recurseCount: n }) { const t = n > 0 ? `... (${n} recursive calls)` : "", o = !!e.component && null == e.component.parent, r = ` at <${or(e.component, e.type, o)}`, s = ">" + t; return e.props ? [r, ...u(e.props), s] : [r + s] } function u(e) { const n = [], t = Object.keys(e); return t.slice(0, 3).forEach(t => { n.push(...p(t, e[t])) }), t.length > 3 && n.push(" ..."), n } function p(e, o, r) { return (0, t.isString)(o) ? (o = JSON.stringify(o), r ? o : [`${e}=${o}`]) : "number" == typeof o || "boolean" == typeof o || null == o ? r ? o : [`${e}=${o}`] : (0, n.isRef)(o) ? (o = p(e, (0, n.toRaw)(o.value), !0), r ? o : [`${e}=Ref<`, o, ">"]) : (0, t.isFunction)(o) ? [`${e}=fn${o.name ? `<${o.name}>` : ""}`] : (o = (0, n.toRaw)(o), r ? o : [`${e}=`, o]) } const d = { bc: "beforeCreate hook", c: "created hook", bm: "beforeMount hook", m: "mounted hook", bu: "beforeUpdate hook", u: "updated", bum: "beforeUnmount hook", um: "unmounted hook", a: "activated hook", da: "deactivated hook", ec: "errorCaptured hook", rtc: "renderTracked hook", rtg: "renderTriggered hook", 0: "setup function", 1: "render function", 2: "watcher getter", 3: "watcher callback", 4: "watcher cleanup function", 5: "native event handler", 6: "component event handler", 7: "vnode hook", 8: "directive hook", 9: "transition hook", 10: "app errorHandler", 11: "app warnHandler", 12: "ref function", 13: "async component loader", 14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next" }; function f(e, n, t, o) { let r; try { r = o ? e(...o) : e() } catch (s) { m(s, n, t) } return r } function h(e, n, o, r) { if ((0, t.isFunction)(e)) { const s = f(e, n, o, r); return s && (0, t.isPromise)(s) && s.catch(e => { m(e, n, o) }), s } const s = []; for (let t = 0; t < e.length; t++)s.push(h(e[t], n, o, r)); return s } function m(e, n, t, o = !0) { const r = n ? n.vnode : null; if (n) { let o = n.parent; const r = n.proxy, s = t; for (; o;) { const n = o.ec; if (n) for (let t = 0; t < n.length; t++)if (!1 === n[t](e, r, s)) return; o = o.parent } const i = n.appContext.config.errorHandler; if (i) return void f(i, null, 10, [e, r, s]) } g(e, t, r, o) } function g(e, n, t, o = !0) { console.error(e) } let y = !1, v = !1; const x = []; let _ = 0; const b = []; let O = null, C = 0; const P = []; let w = null, F = 0; const T = Promise.resolve(); let k = null, E = null; const S = 100; function A(e) { const n = k || T; return e ? n.then(this ? e.bind(this) : e) : n } function R(e) { x.length && x.includes(e, y && e.allowRecurse ? _ + 1 : _) || e === E || (x.push(e), B()) } function B() { y || v || (v = !0, k = T.then(L)) } function M(e) { const n = x.indexOf(e); n > -1 && (x[n] = null) } function j(e, n, o, r) { (0, t.isArray)(e) ? o.push(...e) : n && n.includes(e, e.allowRecurse ? r + 1 : r) || o.push(e), B() } function V(e) { j(e, O, b, C) } function $(e) { j(e, w, P, F) } function N(e, n = null) { if (b.length) { for (E = n, O = [...new Set(b)], b.length = 0, C = 0; C < O.length; C++)O[C](); O = null, C = 0, E = null, N(e, n) } } function U(e) { if (P.length) { const e = [...new Set(P)]; if (P.length = 0, w) return void w.push(...e); for ((w = e).sort((e, n) => I(e) - I(n)), F = 0; F < w.length; F++)w[F](); w = null, F = 0 } } const I = e => null == e.id ? 1 / 0 : e.id; function L(e) { v = !1, y = !0, N(e), x.sort((e, n) => I(e) - I(n)); try { for (_ = 0; _ < x.length; _++) { const e = x[_]; e && f(e, null, 14) } } finally { _ = 0, x.length = 0, U(e), y = !1, k = null, (x.length || P.length) && L(e) } } function D(e, n) { if (e.has(n)) { const t = e.get(n); if (t > S) throw new Error("Maximum recursive updates exceeded. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function."); e.set(n, t + 1) } else e.set(n, 1) } let Y = !1; const H = new Set; const J = new Map; function z(e) { const n = e.type.__hmrId; let t = J.get(n); t || (q(n), t = J.get(n)), t.add(e) } function K(e) { J.get(e.type.__hmrId).delete(e) } function q(e) { return !J.has(e) && (J.set(e, new Set), !0) } function G(e, n) { const t = J.get(e); t && Array.from(t).forEach(e => { n && (e.render = n), e.renderCache = [], Y = !0, e.update(), Y = !1 }) } function W(e, n) { const o = J.get(e); o && Array.from(o).forEach(e => { const o = e.type; if (!H.has(o)) { n = rr(n) ? n.__vccOpts : n, (0, t.extend)(o, n); for (const e in o) e in n || delete o[e]; H.add(o), $(() => { H.delete(o) }) } e.parent ? R(e.parent.update) : e.appContext.reload ? e.appContext.reload() : "undefined" != typeof window ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.") }) } function Q(e) { return (n, t) => { try { return e(n, t) } catch (o) { console.error(o), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.") } } } let X; function Z(e) { exports.devtools = X = e } function ee(e, n) { X && X.emit("app:init", e, n, { Fragment: Lt, Text: Dt, Comment: Yt, Static: Ht }) } function ne(e) { X && X.emit("app:unmount", e) } exports.devtools = X; const te = se("component:added"), oe = se("component:updated"), re = se("component:removed"); function se(e) { return n => { X && X.emit(e, n.appContext.app, n.uid, n.parent ? n.parent.uid : void 0) } } function ie(e, n, t) { X && X.emit("component:emit", e.appContext.app, e, n, t) } function le(e, n, ...o) { const r = e.vnode.props || t.EMPTY_OBJ; let s = o; const i = n.startsWith("update:"), l = i && n.slice(7); if (l && l in r) { const e = `${"modelValue" === l ? "model" : l}Modifiers`, { number: n, trim: i } = r[e] || t.EMPTY_OBJ; i ? s = o.map(e => e.trim()) : n && (s = o.map(t.toNumber)) } __VUE_PROD_DEVTOOLS__ && ie(e, n, s); let c = (0, t.toHandlerKey)((0, t.camelize)(n)), a = r[c]; !a && i && (a = r[c = (0, t.toHandlerKey)((0, t.hyphenate)(n))]), a && h(a, e, 6, s); const u = r[c + "Once"]; if (u) { if (e.emitted) { if (e.emitted[c]) return } else (e.emitted = {})[c] = !0; h(u, e, 6, s) } } function ce(e, n, o = !1) { if (!n.deopt && void 0 !== e.__emits) return e.__emits; const r = e.emits; let s = {}, i = !1; if (__VUE_OPTIONS_API__ && !(0, t.isFunction)(e)) { const r = e => { i = !0, (0, t.extend)(s, ce(e, n, !0)) }; !o && n.mixins.length && n.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r) } return r || i ? ((0, t.isArray)(r) ? r.forEach(e => s[e] = null) : (0, t.extend)(s, r), e.__emits = s) : e.__emits = null } function ae(e, n) { return !(!e || !(0, t.isOn)(n)) && (n = n.replace(/Once$/, ""), (0, t.hasOwn)(e, n[2].toLowerCase() + n.slice(3)) || (0, t.hasOwn)(e, n.slice(2))) } let ue = null; function pe(e) { ue = e } let de = !1; function fe() { de = !0 } function he(e) { const { type: n, vnode: o, proxy: r, withProxy: s, props: i, propsOptions: [l], slots: c, attrs: a, emit: u, render: p, renderCache: d, data: f, setupState: h, ctx: g } = e; let y; ue = e; try { let x; if (4 & o.shapeFlag) { const e = s || r; y = fo(p.call(e, e, d, i, h, f, g)), x = a } else { const e = n; 0, y = fo(e.length > 1 ? e(i, { attrs: a, slots: c, emit: u }) : e(i, null)), x = n.props ? a : ye(a) } let _ = y; if (!1 !== n.inheritAttrs && x) { const e = Object.keys(x), { shapeFlag: n } = _; e.length && (1 & n || 6 & n) && (l && e.some(t.isModelListener) && (x = ve(x, l)), _ = co(_, x)) } o.dirs && (_.dirs = _.dirs ? _.dirs.concat(o.dirs) : o.dirs), o.transition && (_.transition = o.transition), y = _ } catch (v) { m(v, e, 1), y = io(Yt) } return ue = null, y } const me = e => { if (e.type !== Lt) return [e, void 0]; const n = e.children, t = e.dynamicChildren, o = ge(n); if (!o) return [e, void 0]; const r = n.indexOf(o), s = t ? t.indexOf(o) : -1; return [fo(o), o => { n[r] = o, t && (s > -1 ? t[s] = o : o.patchFlag > 0 && (e.dynamicChildren = [...t, o])) }] }; function ge(e) { const n = e.filter(e => !(Zt(e) && e.type === Yt && "v-if" !== e.children)); return 1 === n.length && Zt(n[0]) ? n[0] : null } const ye = e => { let n; for (const o in e) ("class" === o || "style" === o || (0, t.isOn)(o)) && ((n || (n = {}))[o] = e[o]); return n }, ve = (e, n) => { const o = {}; for (const r in e) (0, t.isModelListener)(r) && r.slice(9) in n || (o[r] = e[r]); return o }, xe = e => 6 & e.shapeFlag || 1 & e.shapeFlag || e.type === Yt; function _e(e, n, t) { const { props: o, children: r, component: s } = e, { props: i, children: l, patchFlag: c } = n, a = s.emitsOptions; if (n.dirs || n.transition) return !0; if (!(t && c > 0)) return !(!r && !l || l && l.$stable) || o !== i && (o ? !i || be(o, i, a) : !!i); if (1024 & c) return !0; if (16 & c) return o ? be(o, i, a) : !!i; if (8 & c) { const e = n.dynamicProps; for (let n = 0; n < e.length; n++) { const t = e[n]; if (i[t] !== o[t] && !ae(a, t)) return !0 } } return !1 } function be(e, n, t) { const o = Object.keys(n); if (o.length !== Object.keys(e).length) return !0; for (let r = 0; r < o.length; r++) { const s = o[r]; if (n[s] !== e[s] && !ae(t, s)) return !0 } return !1 } function Oe({ vnode: e, parent: n }, t) { for (; n && n.subTree === e;)(e = n.vnode).el = t, n = n.parent } const Ce = e => e.__isSuspense, Pe = { __isSuspense: !0, process(e, n, t, o, r, s, i, l, c) { null == e ? Fe(n, t, o, r, s, i, l, c) : Te(e, n, t, o, r, i, c) }, hydrate: Se, create: Ee }, we = Pe; function Fe(e, n, t, o, r, s, i, l) { const { p: c, o: { createElement: a } } = l, u = a("div"), p = e.suspense = Ee(e, r, o, n, u, t, s, i, l); c(null, p.pendingBranch = e.ssContent, u, null, o, p, s), p.deps > 0 ? (c(null, e.ssFallback, n, t, o, null, s), Me(p, e.ssFallback)) : p.resolve() } function Te(e, n, o, r, s, i, { p: l, um: c, o: { createElement: a } }) { const u = n.suspense = e.suspense; u.vnode = n, n.el = e.el; const p = n.ssContent, d = n.ssFallback, { activeBranch: f, pendingBranch: h, isInFallback: m, isHydrating: g } = u; if (h) u.pendingBranch = p, eo(p, h) ? (l(h, p, u.hiddenContainer, null, s, u, i), u.deps <= 0 ? u.resolve() : m && (l(f, d, o, r, s, null, i), Me(u, d))) : (u.pendingId++, g ? (u.isHydrating = !1, u.activeBranch = h) : c(h, s, u), u.deps = 0, u.effects.length = 0, u.hiddenContainer = a("div"), m ? (l(null, p, u.hiddenContainer, null, s, u, i), u.deps <= 0 ? u.resolve() : (l(f, d, o, r, s, null, i), Me(u, d))) : f && eo(p, f) ? (l(f, p, o, r, s, u, i), u.resolve(!0)) : (l(null, p, u.hiddenContainer, null, s, u, i), u.deps <= 0 && u.resolve())); else if (f && eo(p, f)) l(f, p, o, r, s, u, i), Me(u, p); else { const e = n.props && n.props.onPending; if ((0, t.isFunction)(e) && e(), u.pendingBranch = p, u.pendingId++, l(null, p, u.hiddenContainer, null, s, u, i), u.deps <= 0) u.resolve(); else { const { timeout: e, pendingId: n } = u; e > 0 ? setTimeout(() => { u.pendingId === n && u.fallback(d) }, e) : 0 === e && u.fallback(d) } } } exports.Suspense = we; let ke = !1; function Ee(e, n, o, r, s, i, l, c, a, u = !1) { const { p: p, m: d, um: f, n: h, o: { parentNode: g, remove: y } } = a, v = (0, t.toNumber)(e.props && e.props.timeout), x = { vnode: e, parent: n, parentComponent: o, isSVG: l, container: r, hiddenContainer: s, anchor: i, deps: 0, pendingId: 0, timeout: "number" == typeof v ? v : -1, activeBranch: null, pendingBranch: null, isInFallback: !0, isHydrating: u, isUnmounted: !1, effects: [], resolve(e = !1) { const { vnode: n, activeBranch: o, pendingBranch: r, pendingId: s, effects: i, parentComponent: l, container: c } = x; if (x.isHydrating) x.isHydrating = !1; else if (!e) { const e = o && r.transition && "out-in" === r.transition.mode; e && (o.transition.afterLeave = (() => { s === x.pendingId && d(r, c, n, 0) })); let { anchor: n } = x; o && (n = h(o), f(o, l, x, !0)), e || d(r, c, n, 0) } Me(x, r), x.pendingBranch = null, x.isInFallback = !1; let a = x.parent, u = !1; for (; a;) { if (a.pendingBranch) { a.effects.push(...i), u = !0; break } a = a.parent } u || $(i), x.effects = []; const p = n.props && n.props.onResolve; (0, t.isFunction)(p) && p() }, fallback(e) { if (!x.pendingBranch) return; const { vnode: n, activeBranch: o, parentComponent: r, container: s, isSVG: i } = x, l = n.props && n.props.onFallback; (0, t.isFunction)(l) && l(); const c = h(o), a = () => { x.isInFallback && (p(null, e, s, c, r, null, i), Me(x, e)) }, u = e.transition && "out-in" === e.transition.mode; u && (o.transition.afterLeave = a), f(o, r, null, !0), x.isInFallback = !0, u || a() }, move(e, n, t) { x.activeBranch && d(x.activeBranch, e, n, t), x.container = e }, next: () => x.activeBranch && h(x.activeBranch), registerDep(e, n) { if (!x.pendingBranch) return; const t = e.vnode.el; x.deps++, e.asyncDep.catch(n => { m(n, e, 0) }).then(o => { if (e.isUnmounted || x.isUnmounted || x.pendingId !== e.suspenseId) return; x.deps--, e.asyncResolved = !0; const { vnode: r } = e; Go(e, o), t && (r.el = t); const s = !t && e.subTree.el; n(e, r, g(t || e.subTree.el), t ? null : h(e.subTree), x, l, c), s && y(s), Oe(e, r.el), 0 === x.deps && x.resolve() }) }, unmount(e, n) { x.isUnmounted = !0, x.activeBranch && f(x.activeBranch, o, e, n), x.pendingBranch && f(x.pendingBranch, o, e, n) } }; return x } function Se(e, n, t, o, r, s, i, l) { const c = n.suspense = Ee(n, o, t, e.parentNode, document.createElement("div"), null, r, s, i, !0), a = l(e, c.pendingBranch = n.ssContent, t, c, s); return 0 === c.deps && c.resolve(), a } function Ae(e) { const { shapeFlag: n, children: t } = e; let o, r; return 32 & n ? (o = Re(t.default), r = Re(t.fallback)) : (o = Re(t), r = fo(null)), { content: o, fallback: r } } function Re(e) { if ((0, t.isFunction)(e) && (e = e()), (0, t.isArray)(e)) { const n = ge(e); 0, e = n } return fo(e) } function Be(e, n) { n && n.pendingBranch ? (0, t.isArray)(e) ? n.effects.push(...e) : n.effects.push(e) : $(e) } function Me(e, n) { e.activeBranch = n; const { vnode: t, parentComponent: o } = e, r = t.el = n.el; o && o.subTree === t && (o.vnode.el = r, Oe(o, r)) } let je = 0; const Ve = e => je += e; function $e(e, n, t = {}, o) { let r = e[n]; je++; const s = (Kt(), Xt(Lt, { key: t.key }, r ? r(t) : o ? o() : [], 1 === e._ ? 64 : -2)); return je--, s } function Ne(e, n = ue) { if (!n) return e; const t = (...t) => { je || Kt(!0); const o = ue; pe(n); const r = e(...t); return pe(o), je || qt(), r }; return t._c = !0, t } let Ue = null; const Ie = []; function Le(e) { Ie.push(Ue = e) } function De() { Ie.pop(), Ue = Ie[Ie.length - 1] || null } function Ye(e) { return n => Ne(function () { Le(e); const t = n.apply(this, arguments); return De(), t }) } function He(e, o, r, s = !1) { const i = {}, l = {}; (0, t.def)(l, oo, 1), ze(e, o, i, l), r ? e.props = s ? i : (0, n.shallowReactive)(i) : e.type.props ? e.props = i : e.props = l, e.attrs = l } function Je(e, o, r, s) { const { props: i, attrs: l, vnode: { patchFlag: c } } = e, a = (0, n.toRaw)(i), [u] = e.propsOptions; if (!(s || c > 0) || 16 & c) { let n; ze(e, o, i, l); for (const s in a) o && ((0, t.hasOwn)(o, s) || (n = (0, t.hyphenate)(s)) !== s && (0, t.hasOwn)(o, n)) || (u ? !r || void 0 === r[s] && void 0 === r[n] || (i[s] = Ke(u, o || t.EMPTY_OBJ, s, void 0, e)) : delete i[s]); if (l !== a) for (const e in l) o && (0, t.hasOwn)(o, e) || delete l[e] } else if (8 & c) { const n = e.vnode.dynamicProps; for (let r = 0; r < n.length; r++) { const s = n[r], c = o[s]; if (u) if ((0, t.hasOwn)(l, s)) l[s] = c; else { const n = (0, t.camelize)(s); i[n] = Ke(u, a, n, c, e) } else l[s] = c } } (0, n.trigger)(e, "set", "$attrs") } function ze(e, o, r, s) { const [i, l] = e.propsOptions; if (o) for (const n in o) { const l = o[n]; if ((0, t.isReservedProp)(n)) continue; let c; i && (0, t.hasOwn)(i, c = (0, t.camelize)(n)) ? r[c] = l : ae(e.emitsOptions, n) || (s[n] = l) } if (l) { const t = (0, n.toRaw)(r); for (let n = 0; n < l.length; n++) { const o = l[n]; r[o] = Ke(i, t, o, t[o], e) } } } function Ke(e, n, o, r, s) { const i = e[o]; if (null != i) { const e = (0, t.hasOwn)(i, "default"); if (e && void 0 === r) { const e = i.default; i.type !== Function && (0, t.isFunction)(e) ? (Do(s), r = e(n), Do(null)) : r = e } i[0] && ((0, t.hasOwn)(n, o) || e ? !i[1] || "" !== r && r !== (0, t.hyphenate)(o) || (r = !0) : r = !1) } return r } function qe(e, n, o = !1) { if (!n.deopt && e.__props) return e.__props; const r = e.props, s = {}, i = []; let l = !1; if (__VUE_OPTIONS_API__ && !(0, t.isFunction)(e)) { const r = e => { l = !0; const [o, r] = qe(e, n, !0); (0, t.extend)(s, o), r && i.push(...r) }; !o && n.mixins.length && n.mixins.forEach(r), e.extends && r(e.extends), e.mixins && e.mixins.forEach(r) } if (!r && !l) return e.__props = t.EMPTY_ARR; if ((0, t.isArray)(r)) for (let c = 0; c < r.length; c++) { 0; const e = (0, t.camelize)(r[c]); Ge(e) && (s[e] = t.EMPTY_OBJ) } else if (r) { 0; for (const e in r) { const n = (0, t.camelize)(e); if (Ge(n)) { const o = r[e], l = s[n] = (0, t.isArray)(o) || (0, t.isFunction)(o) ? { type: o } : o; if (l) { const e = Xe(Boolean, l.type), o = Xe(String, l.type); l[0] = e > -1, l[1] = o < 0 || e < o, (e > -1 || (0, t.hasOwn)(l, "default")) && i.push(n) } } } } return e.__props = [s, i] } function Ge(e) { return "$" !== e[0] } function We(e) { const n = e && e.toString().match(/^\s*function (\w+)/); return n ? n[1] : "" } function Qe(e, n) { return We(e) === We(n) } function Xe(e, n) { if ((0, t.isArray)(n)) { for (let t = 0, o = n.length; t < o; t++)if (Qe(n[t], e)) return t } else if ((0, t.isFunction)(n)) return Qe(n, e) ? 0 : -1; return -1 } function Ze(e, o) { const r = (0, n.toRaw)(e), s = o.propsOptions[0]; for (const n in s) { let e = s[n]; null != e && en(n, r[n], e, !(0, t.hasOwn)(r, n)) } } function en(e, n, o, r) { const { type: s, required: l, validator: c } = o; if (l && r) i('Missing required prop: "' + e + '"'); else if (null != n || o.required) { if (null != s && !0 !== s) { let o = !1; const r = (0, t.isArray)(s) ? s : [s], l = []; for (let e = 0; e < r.length && !o; e++) { const { valid: t, expectedType: s } = tn(n, r[e]); l.push(s || ""), o = t } if (!o) return void i(on(e, n, l)) } c && !c(n) && i('Invalid prop: custom validator check failed for prop "' + e + '".') } } const nn = (0, t.makeMap)("String,Number,Boolean,Function,Symbol"); function tn(e, n) { let o; const r = We(n); if (nn(r)) { const t = typeof e; (o = t === r.toLowerCase()) || "object" !== t || (o = e instanceof n) } else o = "Object" === r ? (0, t.isObject)(e) : "Array" === r ? (0, t.isArray)(e) : e instanceof n; return { valid: o, expectedType: r } } function on(e, n, o) { let r = `Invalid prop: type check failed for prop "${e}".` + ` Expected ${o.map(t.capitalize).join(", ")}`; const s = o[0], i = (0, t.toRawType)(n), l = rn(n, s), c = rn(n, i); return 1 === o.length && sn(s) && !ln(s, i) && (r += ` with value ${l}`), r += `, got ${i} `, sn(i) && (r += `with value ${c}.`), r } function rn(e, n) { return "String" === n ? `"${e}"` : "Number" === n ? `${Number(e)}` : `${e}` } function sn(e) { return ["string", "number", "boolean"].some(n => e.toLowerCase() === n) } function ln(...e) { return e.some(e => "boolean" === e.toLowerCase()) } function cn(e, t, o = Io, r = !1) { if (o) { const s = o[e] || (o[e] = []), i = t.__weh || (t.__weh = ((...r) => { if (o.isUnmounted) return; (0, n.pauseTracking)(), Do(o); const s = h(t, o, e, r); return Do(null), (0, n.resetTracking)(), s })); return r ? s.unshift(i) : s.push(i), i } } const an = e => (n, t = Io) => !zo && cn(e, n, t), un = an("bm"); exports.onBeforeMount = un; const pn = an("m"); exports.onMounted = pn; const dn = an("bu"); exports.onBeforeUpdate = dn; const fn = an("u"); exports.onUpdated = fn; const hn = an("bum"); exports.onBeforeUnmount = hn; const mn = an("um"); exports.onUnmounted = mn; const gn = an("rtg"); exports.onRenderTriggered = gn; const yn = an("rtc"); exports.onRenderTracked = yn; const vn = (e, n = Io) => { cn("ec", e, n) }; function xn(e, n) { return On(e, null, n) } exports.onErrorCaptured = vn; const _n = {}; function bn(e, n, t) { return On(e, n, t) } function On(e, o, { immediate: r, deep: s, flush: i, onTrack: l, onTrigger: c } = t.EMPTY_OBJ, a = Io) { let u, p, d = !1; if ((0, n.isRef)(e) ? (u = (() => e.value), d = !!e._shallow) : (0, n.isReactive)(e) ? (u = (() => e), s = !0) : u = (0, t.isArray)(e) ? () => e.map(e => (0, n.isRef)(e) ? e.value : (0, n.isReactive)(e) ? Pn(e) : (0, t.isFunction)(e) ? f(e, a, 2) : void 0) : (0, t.isFunction)(e) ? o ? () => f(e, a, 2) : () => { if (!a || !a.isUnmounted) return p && p(), f(e, a, 3, [m]) } : t.NOOP, o && s) { const e = u; u = (() => Pn(e())) } const m = e => { p = x.options.onStop = (() => { f(e, a, 4) }) }; let g = (0, t.isArray)(e) ? [] : _n; const y = () => { if (x.active) if (o) { const e = x(); (s || d || (0, t.hasChanged)(e, g)) && (p && p(), h(o, a, 3, [e, g === _n ? void 0 : g, m]), g = e) } else x() }; let v; y.allowRecurse = !!o, v = "sync" === i ? y : "post" === i ? () => vt(y, a && a.suspense) : () => { !a || a.isMounted ? V(y) : y() }; const x = (0, n.effect)(u, { lazy: !0, onTrack: l, onTrigger: c, scheduler: v }); return er(x), o ? r ? y() : g = x() : "post" === i ? vt(x, a && a.suspense) : x(), () => { (0, n.stop)(x), a && (0, t.remove)(a.effects, x) } } function Cn(e, n, o) { const r = this.proxy; return On((0, t.isString)(e) ? () => r[e] : e.bind(r), n.bind(r), o, this) } function Pn(e, o = new Set) { if (!(0, t.isObject)(e) || o.has(e)) return e; if (o.add(e), (0, n.isRef)(e)) Pn(e.value, o); else if ((0, t.isArray)(e)) for (let n = 0; n < e.length; n++)Pn(e[n], o); else if ((0, t.isSet)(e) || (0, t.isMap)(e)) e.forEach(e => { Pn(e, o) }); else for (const n in e) Pn(e[n], o); return e } function wn() { const e = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return pn(() => { e.isMounted = !0 }), hn(() => { e.isUnmounting = !0 }), e } const Fn = [Function, Array], Tn = { name: "BaseTransition", props: { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: Fn, onEnter: Fn, onAfterEnter: Fn, onEnterCancelled: Fn, onBeforeLeave: Fn, onLeave: Fn, onAfterLeave: Fn, onLeaveCancelled: Fn, onBeforeAppear: Fn, onAppear: Fn, onAfterAppear: Fn, onAppearCancelled: Fn }, setup(e, { slots: t }) { const o = Lo(), r = wn(); let s; return () => { const i = t.default && Mn(t.default(), !0); if (!i || !i.length) return; const l = (0, n.toRaw)(e), { mode: c } = l; const a = i[0]; if (r.isLeaving) return An(a); const u = Rn(a); if (!u) return An(a); const p = Sn(u, l, r, o); Bn(u, p); const d = o.subTree, f = d && Rn(d); let h = !1; const { getTransitionKey: m } = u.type; if (m) { const e = m(); void 0 === s ? s = e : e !== s && (s = e, h = !0) } if (f && f.type !== Yt && (!eo(u, f) || h)) { const e = Sn(f, l, r, o); if (Bn(f, e), "out-in" === c) return r.isLeaving = !0, e.afterLeave = (() => { r.isLeaving = !1, o.update() }), An(a); "in-out" === c && (e.delayLeave = ((e, n, t) => { En(r, f)[String(f.key)] = f, e._leaveCb = (() => { n(), e._leaveCb = void 0, delete p.delayedLeave }), p.delayedLeave = t })) } return a } } }, kn = Tn; function En(e, n) { const { leavingVNodes: t } = e; let o = t.get(n.type); return o || (o = Object.create(null), t.set(n.type, o)), o } function Sn(e, n, t, o) { const { appear: r, mode: s, persisted: i = !1, onBeforeEnter: l, onEnter: c, onAfterEnter: a, onEnterCancelled: u, onBeforeLeave: p, onLeave: d, onAfterLeave: f, onLeaveCancelled: m, onBeforeAppear: g, onAppear: y, onAfterAppear: v, onAppearCancelled: x } = n, _ = String(e.key), b = En(t, e), O = (e, n) => { e && h(e, o, 9, n) }, C = { mode: s, persisted: i, beforeEnter(n) { let o = l; if (!t.isMounted) { if (!r) return; o = g || l } n._leaveCb && n._leaveCb(!0); const s = b[_]; s && eo(e, s) && s.el._leaveCb && s.el._leaveCb(), O(o, [n]) }, enter(e) { let n = c, o = a, s = u; if (!t.isMounted) { if (!r) return; n = y || c, o = v || a, s = x || u } let i = !1; const l = e._enterCb = (n => { i || (i = !0, O(n ? s : o, [e]), C.delayedLeave && C.delayedLeave(), e._enterCb = void 0) }); n ? (n(e, l), n.length <= 1 && l()) : l() }, leave(n, o) { const r = String(e.key); if (n._enterCb && n._enterCb(!0), t.isUnmounting) return o(); O(p, [n]); let s = !1; const i = n._leaveCb = (t => { s || (s = !0, o(), O(t ? m : f, [n]), n._leaveCb = void 0, b[r] === e && delete b[r]) }); b[r] = e, d ? (d(n, i), d.length <= 1 && i()) : i() }, clone: e => Sn(e, n, t, o) }; return C } function An(e) { if (jn(e)) return (e = co(e)).children = null, e } function Rn(e) { return jn(e) ? e.children ? e.children[0] : void 0 : e } function Bn(e, n) { 6 & e.shapeFlag && e.component ? Bn(e.component.subTree, n) : 128 & e.shapeFlag ? (e.ssContent.transition = n.clone(e.ssContent), e.ssFallback.transition = n.clone(e.ssFallback)) : e.transition = n } function Mn(e, n = !1) { let t = [], o = 0; for (let r = 0; r < e.length; r++) { const s = e[r]; s.type === Lt ? (128 & s.patchFlag && o++, t = t.concat(Mn(s.children, n))) : (n || s.type !== Yt) && t.push(s) } if (o > 1) for (let r = 0; r < t.length; r++)t[r].patchFlag = -2; return t } exports.BaseTransition = kn; const jn = e => e.type.__isKeepAlive, Vn = { name: "KeepAlive", __isKeepAlive: !0, inheritRef: !0, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(e, { slots: n }) { const o = new Map, r = new Set; let s = null; const i = Lo(), l = i.suspense, c = i.ctx, { renderer: { p: a, m: u, um: p, o: { createElement: d } } } = c, f = d("div"); function h(e) { Hn(e), p(e, i, l) } function m(e) { o.forEach((n, t) => { const o = Nn(n.type); !o || e && e(o) || g(t) }) } function g(e) { const n = o.get(e); s && n.type === s.type ? s && Hn(s) : h(n), o.delete(e), r.delete(e) } c.activate = ((e, n, o, r, s) => { const i = e.component; u(e, n, o, 0, l), a(i.vnode, e, n, o, i, l, r, s), vt(() => { i.isDeactivated = !1, i.a && (0, t.invokeArrayFns)(i.a); const n = e.props && e.props.onVnodeMounted; n && Ct(n, i.parent, e) }, l) }), c.deactivate = (e => { const n = e.component; u(e, f, null, 1, l), vt(() => { n.da && (0, t.invokeArrayFns)(n.da); const o = e.props && e.props.onVnodeUnmounted; o && Ct(o, n.parent, e), n.isDeactivated = !0 }, l) }), bn(() => [e.include, e.exclude], ([e, n]) => { e && m(n => Un(e, n)), n && m(e => !Un(n, e)) }, { flush: "post" }); let y = null; const v = () => { null != y && o.set(y, Jn(i.subTree)) }; return pn(v), fn(v), hn(() => { o.forEach(e => { const { subTree: n, suspense: t } = i, o = Jn(n); if (e.type !== o.type) h(e); else { Hn(o); const e = o.component.da; e && vt(e, t) } }) }), () => { if (y = null, !n.default) return null; const t = n.default(), i = t[0]; if (t.length > 1) return s = null, t; if (!(Zt(i) && (4 & i.shapeFlag || 128 & i.shapeFlag))) return s = null, i; let l = Jn(i); const c = l.type, a = Nn(c), { include: u, exclude: p, max: d } = e; if (u && (!a || !Un(u, a)) || p && a && Un(p, a)) return s = l, i; const f = null == l.key ? c : l.key, h = o.get(f); return l.el && (l = co(l), 128 & i.shapeFlag && (i.ssContent = l)), y = f, h ? (l.el = h.el, l.component = h.component, l.transition && Bn(l, l.transition), l.shapeFlag |= 512, r.delete(f), r.add(f)) : (r.add(f), d && r.size > parseInt(d, 10) && g(r.values().next().value)), l.shapeFlag |= 256, s = l, i } } }, $n = Vn; function Nn(e) { return e.displayName || e.name } function Un(e, n) { return (0, t.isArray)(e) ? e.some(e => Un(e, n)) : (0, t.isString)(e) ? e.split(",").indexOf(n) > -1 : !!e.test && e.test(n) } function In(e, n) { Dn(e, "a", n) } function Ln(e, n) { Dn(e, "da", n) } function Dn(e, n, t = Io) { const o = e.__wdc || (e.__wdc = (() => { let n = t; for (; n;) { if (n.isDeactivated) return; n = n.parent } e() })); if (cn(n, o, t), t) { let e = t.parent; for (; e && e.parent;)jn(e.parent.vnode) && Yn(o, n, t, e), e = e.parent } } function Yn(e, n, o, r) { const s = cn(n, e, r, !0); mn(() => { (0, t.remove)(r[n], s) }, o) } function Hn(e) { let n = e.shapeFlag; 256 & n && (n -= 256), 512 & n && (n -= 512), e.shapeFlag = n } function Jn(e) { return 128 & e.shapeFlag ? e.ssContent : e } exports.KeepAlive = $n; const zn = e => "_" === e[0] || "$stable" === e, Kn = e => (0, t.isArray)(e) ? e.map(fo) : [fo(e)], qn = (e, n, t) => Ne(e => Kn(n(e)), t), Gn = (e, n) => { const o = e._ctx; for (const r in e) { if (zn(r)) continue; const s = e[r]; if ((0, t.isFunction)(s)) n[r] = qn(0, s, o); else if (null != s) { 0; const e = Kn(s); n[r] = (() => e) } } }, Wn = (e, n) => { const t = Kn(n); e.slots.default = (() => t) }, Qn = (e, n) => { if (32 & e.vnode.shapeFlag) { const o = n._; o ? (e.slots = n, (0, t.def)(n, "_", o)) : Gn(n, e.slots = {}) } else e.slots = {}, n && Wn(e, n); (0, t.def)(e.slots, oo, 1) }, Xn = (e, n) => { const { vnode: o, slots: r } = e; let s = !0, i = t.EMPTY_OBJ; if (32 & o.shapeFlag) { const e = n._; e ? 1 === e ? s = !1 : (0, t.extend)(r, n) : (s = !n.$stable, Gn(n, r)), i = n } else n && (Wn(e, n), i = { default: 1 }); if (s) for (const t in r) zn(t) || t in i || delete r[t] }, Zn = (0, t.makeMap)("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text"); function et(e) { Zn(e) && i("Do not use built-in directive ids as custom directive id: " + e) } function nt(e, n) { if (null === ue) return e; const o = ue.proxy, r = e.dirs || (e.dirs = []); for (let s = 0; s < n.length; s++) { let [e, i, l, c = t.EMPTY_OBJ] = n[s]; (0, t.isFunction)(e) && (e = { mounted: e, updated: e }), r.push({ dir: e, instance: o, value: i, oldValue: void 0, arg: l, modifiers: c }) } return e } function tt(e, n, t, o) { const r = e.dirs, s = n && n.dirs; for (let i = 0; i < r.length; i++) { const l = r[i]; s && (l.oldValue = s[i].value); const c = l.dir[o]; c && h(c, t, 8, [e.el, l, e, n]) } } function ot() { return { app: null, config: { isNativeTag: t.NO, performance: !1, globalProperties: {}, optionMergeStrategies: {}, isCustomElement: t.NO, errorHandler: void 0, warnHandler: void 0 }, mixins: [], components: {}, directives: {}, provides: Object.create(null) } } let rt = 0; function st(e, n) { return function (o, r = null) { null == r || (0, t.isObject)(r) || (r = null); const s = ot(), i = new Set; let l = !1; const c = s.app = { _uid: rt++, _component: o, _props: r, _container: null, _context: s, version: gr, get config() { return s.config }, set config(e) { 0 }, use: (e, ...n) => (i.has(e) || (e && (0, t.isFunction)(e.install) ? (i.add(e), e.install(c, ...n)) : (0, t.isFunction)(e) && (i.add(e), e(c, ...n))), c), mixin: e => (__VUE_OPTIONS_API__ && (s.mixins.includes(e) || (s.mixins.push(e), (e.props || e.emits) && (s.deopt = !0))), c), component: (e, n) => n ? (s.components[e] = n, c) : s.components[e], directive: (e, n) => n ? (s.directives[e] = n, c) : s.directives[e], mount(t, i) { if (!l) { const a = io(o, r); return a.appContext = s, i && n ? n(a, t) : e(a, t), l = !0, c._container = t, t.__vue_app__ = c, __VUE_PROD_DEVTOOLS__ && ee(c, gr), a.component.proxy } }, unmount() { l && (e(null, c._container), __VUE_PROD_DEVTOOLS__ && ne(c)) }, provide: (e, n) => (s.provides[e] = n, c) }; return c } } let it = !1; const lt = e => /svg/.test(e.namespaceURI) && "foreignObject" !== e.tagName, ct = e => 8 === e.nodeType; function at(e) { const { mt: n, p: o, o: { patchProp: r, nextSibling: s, parentNode: i, remove: l, insert: c, createComment: a } } = e, u = (t, o, r, l, c = !1) => { const a = ct(t) && "[" === t.data, g = () => h(t, o, r, l, a), { type: y, ref: v, shapeFlag: x } = o, _ = t.nodeType; o.el = t; let b = null; switch (y) { case Dt: 3 !== _ ? b = g() : (t.data !== o.children && (it = !0, t.data = o.children), b = s(t)); break; case Yt: b = 8 !== _ || a ? g() : s(t); break; case Ht: if (1 === _) { b = t; const e = !o.children.length; for (let n = 0; n < o.staticCount; n++)e && (o.children += b.outerHTML), n === o.staticCount - 1 && (o.anchor = b), b = s(b); return b } b = g(); break; case Lt: b = a ? f(t, o, r, l, c) : g(); break; default: if (1 & x) b = 1 !== _ || o.type !== t.tagName.toLowerCase() ? g() : p(t, o, r, l, c); else if (6 & x) { const e = i(t), u = () => { n(o, e, null, r, l, lt(e), c) }, p = o.type.__asyncLoader; p ? p().then(u) : u(), b = a ? m(t) : s(t) } else 64 & x ? b = 8 !== _ ? g() : o.type.hydrate(t, o, r, l, c, e, d) : 128 & x && (b = o.type.hydrate(t, o, r, l, lt(i(t)), c, e, u)) }return null != v && r && xt(v, null, r, l, o), b }, p = (e, n, o, s, i) => { i = i || !!n.dynamicChildren; const { props: c, patchFlag: a, shapeFlag: u, dirs: p } = n; if (-1 !== a) { if (p && tt(n, null, o, "created"), c) if (!i || 16 & a || 32 & a) for (const n in c) !(0, t.isReservedProp)(n) && (0, t.isOn)(n) && r(e, n, null, c[n]); else c.onClick && r(e, "onClick", null, c.onClick); let f; if ((f = c && c.onVnodeBeforeMount) && Ct(f, o, n), p && tt(n, null, o, "beforeMount"), ((f = c && c.onVnodeMounted) || p) && Be(() => { f && Ct(f, o, n), p && tt(n, null, o, "mounted") }, s), 16 & u && (!c || !c.innerHTML && !c.textContent)) { let t = d(e.firstChild, n, e, o, s, i); for (; t;) { it = !0; const e = t; t = t.nextSibling, l(e) } } else 8 & u && e.textContent !== n.children && (it = !0, e.textContent = n.children) } return e.nextSibling }, d = (e, n, t, r, s, i) => { i = i || !!n.dynamicChildren; const l = n.children, c = l.length; for (let a = 0; a < c; a++) { const n = i ? l[a] : l[a] = fo(l[a]); e ? e = u(e, n, r, s, i) : (it = !0, o(null, n, t, null, r, s, lt(t))) } return e }, f = (e, n, t, o, r) => { const l = i(e), u = d(s(e), n, l, t, o, r); return u && ct(u) && "]" === u.data ? s(n.anchor = u) : (it = !0, c(n.anchor = a("]"), l, u), u) }, h = (e, n, t, r, c) => { if (it = !0, n.el = null, c) { const n = m(e); for (; ;) { const t = s(e); if (!t || t === n) break; l(t) } } const a = s(e), u = i(e); return l(e), o(null, n, u, a, t, r, lt(u)), a }, m = e => { let n = 0; for (; e;)if ((e = s(e)) && ct(e) && ("[" === e.data && n++, "]" === e.data)) { if (0 === n) return s(e); n-- } return e }; return [(e, n) => { it = !1, u(n.firstChild, e, null, null), U(), it && console.error("Hydration completed but contains mismatches.") }, u] } let ut, pt; function dt(e, n) { e.appContext.config.performance && ht() && pt.mark(`vue-${n}-${e.uid}`) } function ft(e, n) { if (e.appContext.config.performance && ht()) { const t = `vue-${n}-${e.uid}`, o = t + ":end"; pt.mark(o), pt.measure(`<${or(e, e.type)}> ${n}`, t, o), pt.clearMarks(t), pt.clearMarks(o) } } function ht() { return void 0 !== ut ? ut : ("undefined" != typeof window && window.performance ? (ut = !0, pt = window.performance) : ut = !1, ut) } function mt() { let e = !1; "boolean" != typeof __VUE_OPTIONS_API__ && (e = !0, (0, t.getGlobalThis)().__VUE_OPTIONS_API__ = !0), "boolean" != typeof __VUE_PROD_DEVTOOLS__ && (e = !0, (0, t.getGlobalThis)().__VUE_PROD_DEVTOOLS__ = !1) } const gt = { scheduler: R, allowRecurse: !0 }; function yt(e) { return { scheduler: R, allowRecurse: !0, onTrack: e.rtc ? n => (0, t.invokeArrayFns)(e.rtc, n) : void 0, onTrigger: e.rtg ? n => (0, t.invokeArrayFns)(e.rtg, n) : void 0 } } const vt = Be, xt = (e, o, r, s, i) => { if ((0, t.isArray)(e)) return void e.forEach((e, n) => xt(e, o && ((0, t.isArray)(o) ? o[n] : o), r, s, i)); let l; l = i ? 4 & i.shapeFlag ? i.component.proxy : i.el : null; const { i: c, r: a } = e; const u = o && o.r, p = c.refs === t.EMPTY_OBJ ? c.refs = {} : c.refs, d = c.setupState; if (null != u && u !== a && ((0, t.isString)(u) ? (p[u] = null, (0, t.hasOwn)(d, u) && (d[u] = null)) : (0, n.isRef)(u) && (u.value = null)), (0, t.isString)(a)) { const e = () => { p[a] = l, (0, t.hasOwn)(d, a) && (d[a] = l) }; l ? (e.id = -1, vt(e, s)) : e() } else if ((0, n.isRef)(a)) { const e = () => { a.value = l }; l ? (e.id = -1, vt(e, s)) : e() } else (0, t.isFunction)(a) && f(a, r, 12, [l, p]) }; function _t(e) { return Ot(e) } function bt(e) { return Ot(e, at) } function Ot(e, o) { mt(); const { insert: r, remove: s, patchProp: i, forcePatchProp: l, createElement: c, createText: a, createComment: u, setText: p, setElementText: d, parentNode: f, nextSibling: h, setScopeId: m = t.NOOP, cloneNode: g, insertStaticContent: y } = e, v = (e, n, t, o = null, r = null, s = null, i = !1, l = !1) => { e && !eo(e, n) && (o = K(e), D(e, r, s, !0), e = null), -2 === n.patchFlag && (l = !1, n.dynamicChildren = null); const { type: c, ref: a, shapeFlag: u } = n; switch (c) { case Dt: x(e, n, t, o); break; case Yt: _(e, n, t, o); break; case Ht: null == e && b(n, t, o, i); break; case Lt: E(e, n, t, o, r, s, i, l); break; default: 1 & u ? O(e, n, t, o, r, s, i, l) : 6 & u ? S(e, n, t, o, r, s, i, l) : 64 & u ? c.process(e, n, t, o, r, s, i, l, G) : 128 & u && c.process(e, n, t, o, r, s, i, l, G) }null != a && r && xt(a, e && e.ref, r, s, n) }, x = (e, n, t, o) => { if (null == e) r(n.el = a(n.children), t, o); else { const t = n.el = e.el; n.children !== e.children && p(t, n.children) } }, _ = (e, n, t, o) => { null == e ? r(n.el = u(n.children || ""), t, o) : n.el = e.el }, b = (e, n, t, o) => { [e.el, e.anchor] = y(e.children, n, t, o) }, O = (e, n, t, o, r, s, i, l) => { i = i || "svg" === n.type, null == e ? C(n, t, o, r, s, i, l) : F(e, n, r, s, i, l) }, C = (e, n, o, s, l, a, u) => { let p, f; const { type: h, props: m, shapeFlag: y, transition: v, scopeId: x, patchFlag: _, dirs: b } = e; if (e.el && void 0 !== g && -1 === _) p = e.el = g(e.el); else { if (p = e.el = c(e.type, a, m && m.is), 8 & y ? d(p, e.children) : 16 & y && w(e.children, p, null, s, l, a && "foreignObject" !== h, u || !!e.dynamicChildren), b && tt(e, null, s, "created"), m) { for (const n in m) (0, t.isReservedProp)(n) || i(p, n, null, m[n], a, e.children, s, l, z); (f = m.onVnodeBeforeMount) && Ct(f, s, e) } P(p, x, e, s) } __VUE_PROD_DEVTOOLS__ && (Object.defineProperty(p, "__vnode", { value: e, enumerable: !1 }), Object.defineProperty(p, "__vueParentComponent", { value: s, enumerable: !1 })), b && tt(e, null, s, "beforeMount"); const O = (!l || l && !l.pendingBranch) && v && !v.persisted; O && v.beforeEnter(p), r(p, n, o), ((f = m && m.onVnodeMounted) || O || b) && vt(() => { f && Ct(f, s, e), O && v.enter(p), b && tt(e, null, s, "mounted") }, l) }, P = (e, n, t, o) => { if (n && m(e, n), o) { const r = o.type.__scopeId; r && r !== n && m(e, r + "-s"); let s = o.subTree; 0, t === s && P(e, o.vnode.scopeId, o.vnode, o.parent) } }, w = (e, n, t, o, r, s, i, l = 0) => { for (let c = l; c < e.length; c++) { const l = e[c] = i ? ho(e[c]) : fo(e[c]); v(null, l, n, t, o, r, s, i) } }, F = (e, n, o, r, s, c) => { const a = n.el = e.el; let { patchFlag: u, dynamicChildren: p, dirs: f } = n; u |= 16 & e.patchFlag; const h = e.props || t.EMPTY_OBJ, m = n.props || t.EMPTY_OBJ; let g; if ((g = m.onVnodeBeforeUpdate) && Ct(g, o, n, e), f && tt(n, e, o, "beforeUpdate"), u > 0) { if (16 & u) k(a, n, h, m, o, r, s); else if (2 & u && h.class !== m.class && i(a, "class", null, m.class, s), 4 & u && i(a, "style", h.style, m.style, s), 8 & u) { const t = n.dynamicProps; for (let n = 0; n < t.length; n++) { const c = t[n], u = h[c], p = m[c]; (p !== u || l && l(a, c)) && i(a, c, u, p, s, e.children, o, r, z) } } 1 & u && e.children !== n.children && d(a, n.children) } else c || null != p || k(a, n, h, m, o, r, s); const y = s && "foreignObject" !== n.type; p ? T(e.dynamicChildren, p, a, o, r, y) : c || V(e, n, a, null, o, r, y), ((g = m.onVnodeUpdated) || f) && vt(() => { g && Ct(g, o, n, e), f && tt(n, e, o, "updated") }, r) }, T = (e, n, t, o, r, s) => { for (let i = 0; i < n.length; i++) { const l = e[i], c = n[i], a = l.type === Lt || !eo(l, c) || 6 & l.shapeFlag || 64 & l.shapeFlag ? f(l.el) : t; v(l, c, a, null, o, r, s, !0) } }, k = (e, n, o, r, s, c, a) => { if (o !== r) { for (const u in r) { if ((0, t.isReservedProp)(u)) continue; const p = r[u], d = o[u]; (p !== d || l && l(e, u)) && i(e, u, d, p, a, n.children, s, c, z) } if (o !== t.EMPTY_OBJ) for (const l in o) (0, t.isReservedProp)(l) || l in r || i(e, l, o[l], null, a, n.children, s, c, z) } }, E = (e, n, t, o, s, i, l, c) => { const u = n.el = e ? e.el : a(""), p = n.anchor = e ? e.anchor : a(""); let { patchFlag: d, dynamicChildren: f } = n; d > 0 && (c = !0), null == e ? (r(u, t, o), r(p, t, o), w(n.children, t, p, s, i, l, c)) : d > 0 && 64 & d && f ? (T(e.dynamicChildren, f, t, s, i, l), (null != n.key || s && n === s.subTree) && Pt(e, n, !0)) : V(e, n, t, p, s, i, l, c) }, S = (e, n, t, o, r, s, i, l) => { null == e ? 512 & n.shapeFlag ? r.ctx.activate(n, t, o, i, l) : A(n, t, o, r, s, i, l) : R(e, n, l) }, A = (e, n, t, o, r, s, i) => { const l = e.component = Uo(e, o, r); if (jn(e) && (l.ctx.renderer = G), Ko(l), l.asyncDep) { if (r && r.registerDep(l, B), !e.el) { const e = l.subTree = io(Yt); _(null, e, n, t) } } else B(l, e, n, t, r, s, i) }, R = (e, n, t) => { const o = n.component = e.component; if (_e(e, n, t)) { if (o.asyncDep && !o.asyncResolved) return void j(o, n, t); o.next = n, M(o.update), o.update() } else n.component = e.component, n.el = e.el, o.vnode = n }, B = (e, o, r, s, i, l, c) => { e.update = (0, n.effect)(function () { if (e.isMounted) { let n, { next: o, bu: r, u: s, parent: a, vnode: u } = e, p = o; 0, o ? (o.el = u.el, j(e, o, c)) : o = u, r && (0, t.invokeArrayFns)(r), (n = o.props && o.props.onVnodeBeforeUpdate) && Ct(n, a, o, u); const d = he(e); 0; const h = e.subTree; e.subTree = d, v(h, d, f(h.el), K(h), e, i, l), o.el = d.el, null === p && Oe(e, d.el), s && vt(s, i), (n = o.props && o.props.onVnodeUpdated) && vt(() => { Ct(n, a, o, u) }, i), __VUE_PROD_DEVTOOLS__ && oe(e) } else { let n; const { el: c, props: a } = o, { bm: u, m: p, parent: d } = e; u && (0, t.invokeArrayFns)(u), (n = a && a.onVnodeBeforeMount) && Ct(n, d, o); const f = e.subTree = he(e); 0, c && Q ? Q(o.el, f, e, i) : (v(null, f, r, s, e, i, l), o.el = f.el), p && vt(p, i), (n = a && a.onVnodeMounted) && vt(() => { Ct(n, d, o) }, i); const { a: h } = e; h && 256 & o.shapeFlag && vt(h, i), e.isMounted = !0 } }, gt) }, j = (e, n, t) => { n.component = e; const o = e.vnode.props; e.vnode = n, e.next = null, Je(e, n.props, o, t), Xn(e, n.children), N(void 0, e.update) }, V = (e, n, t, o, r, s, i, l = !1) => { const c = e && e.children, a = e ? e.shapeFlag : 0, u = n.children, { patchFlag: p, shapeFlag: f } = n; if (p > 0) { if (128 & p) return void I(c, u, t, o, r, s, i, l); if (256 & p) return void $(c, u, t, o, r, s, i, l) } 8 & f ? (16 & a && z(c, r, s), u !== c && d(t, u)) : 16 & a ? 16 & f ? I(c, u, t, o, r, s, i, l) : z(c, r, s, !0) : (8 & a && d(t, ""), 16 & f && w(u, t, o, r, s, i, l)) }, $ = (e, n, o, r, s, i, l, c) => { e = e || t.EMPTY_ARR, n = n || t.EMPTY_ARR; const a = e.length, u = n.length, p = Math.min(a, u); let d; for (d = 0; d < p; d++) { const t = n[d] = c ? ho(n[d]) : fo(n[d]); v(e[d], t, o, null, s, i, l, c) } a > u ? z(e, s, i, !0, !1, p) : w(n, o, r, s, i, l, c, p) }, I = (e, n, o, r, s, i, l, c) => { let a = 0; const u = n.length; let p = e.length - 1, d = u - 1; for (; a <= p && a <= d;) { const t = e[a], r = n[a] = c ? ho(n[a]) : fo(n[a]); if (!eo(t, r)) break; v(t, r, o, null, s, i, l, c), a++ } for (; a <= p && a <= d;) { const t = e[p], r = n[d] = c ? ho(n[d]) : fo(n[d]); if (!eo(t, r)) break; v(t, r, o, null, s, i, l, c), p--, d-- } if (a > p) { if (a <= d) { const e = d + 1, t = e < u ? n[e].el : r; for (; a <= d;)v(null, n[a] = c ? ho(n[a]) : fo(n[a]), o, t, s, i, l), a++ } } else if (a > d) for (; a <= p;)D(e[a], s, i, !0), a++; else { const f = a, h = a, m = new Map; for (a = h; a <= d; a++) { const e = n[a] = c ? ho(n[a]) : fo(n[a]); null != e.key && m.set(e.key, a) } let g, y = 0; const x = d - h + 1; let _ = !1, b = 0; const O = new Array(x); for (a = 0; a < x; a++)O[a] = 0; for (a = f; a <= p; a++) { const t = e[a]; if (y >= x) { D(t, s, i, !0); continue } let r; if (null != t.key) r = m.get(t.key); else for (g = h; g <= d; g++)if (0 === O[g - h] && eo(t, n[g])) { r = g; break } void 0 === r ? D(t, s, i, !0) : (O[r - h] = a + 1, r >= b ? b = r : _ = !0, v(t, n[r], o, null, s, i, l, c), y++) } const C = _ ? wt(O) : t.EMPTY_ARR; for (g = C.length - 1, a = x - 1; a >= 0; a--) { const e = h + a, t = n[e], c = e + 1 < u ? n[e + 1].el : r; 0 === O[a] ? v(null, t, o, c, s, i, l) : _ && (g < 0 || a !== C[g] ? L(t, o, c, 2) : g--) } } }, L = (e, n, t, o, s = null) => { const { el: i, type: l, transition: c, children: a, shapeFlag: u } = e; if (6 & u) L(e.component.subTree, n, t, o); else if (128 & u) e.suspense.move(n, t, o); else if (64 & u) l.move(e, n, t, G); else if (l !== Lt) if (2 !== o && 1 & u && c) if (0 === o) c.beforeEnter(i), r(i, n, t), vt(() => c.enter(i), s); else { const { leave: e, delayLeave: o, afterLeave: s } = c, l = () => r(i, n, t), a = () => { e(i, () => { l(), s && s() }) }; o ? o(i, l, a) : a() } else r(i, n, t); else { r(i, n, t); for (let e = 0; e < a.length; e++)L(a[e], n, t, o); r(e.anchor, n, t) } }, D = (e, n, t, o = !1, r = !1) => { const { type: s, props: i, ref: l, children: c, dynamicChildren: a, shapeFlag: u, patchFlag: p, dirs: d } = e; if (null != l && n && xt(l, null, n, t, null), 256 & u) return void n.ctx.deactivate(e); const f = 1 & u && d; let h; if ((h = i && i.onVnodeBeforeUnmount) && Ct(h, n, e), 6 & u) J(e.component, t, o); else { if (128 & u) return void e.suspense.unmount(t, o); f && tt(e, null, n, "beforeUnmount"), a && (s !== Lt || p > 0 && 64 & p) ? z(a, n, t, !1, !0) : (s === Lt && (128 & p || 256 & p) || !r && 16 & u) && z(c, n, t), 64 & u && (o || !Tt(e.props)) && e.type.remove(e, G), o && Y(e) } ((h = i && i.onVnodeUnmounted) || f) && vt(() => { h && Ct(h, n, e), f && tt(e, null, n, "unmounted") }, t) }, Y = e => { const { type: n, el: t, anchor: o, transition: r } = e; if (n === Lt) return void H(t, o); const i = () => { s(t), r && !r.persisted && r.afterLeave && r.afterLeave() }; if (1 & e.shapeFlag && r && !r.persisted) { const { leave: n, delayLeave: o } = r, s = () => n(t, i); o ? o(e.el, i, s) : s() } else i() }, H = (e, n) => { let t; for (; e !== n;)t = h(e), s(e), e = t; s(n) }, J = (e, o, r) => { const { bum: s, effects: i, update: l, subTree: c, um: a } = e; if (s && (0, t.invokeArrayFns)(s), i) for (let t = 0; t < i.length; t++)(0, n.stop)(i[t]); l && ((0, n.stop)(l), D(c, e, o, r)), a && vt(a, o), vt(() => { e.isUnmounted = !0 }, o), o && o.pendingBranch && !o.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === o.pendingId && (o.deps--, 0 === o.deps && o.resolve()), __VUE_PROD_DEVTOOLS__ && re(e) }, z = (e, n, t, o = !1, r = !1, s = 0) => { for (let i = s; i < e.length; i++)D(e[i], n, t, o, r) }, K = e => 6 & e.shapeFlag ? K(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : h(e.anchor || e.el), q = (e, n) => { null == e ? n._vnode && D(n._vnode, null, null, !0) : v(n._vnode || null, e, n), U(), n._vnode = e }, G = { p: v, um: D, m: L, r: Y, mt: A, mc: w, pc: V, pbc: T, n: K, o: e }; let W, Q; return o && ([W, Q] = o(G)), { render: q, hydrate: W, createApp: st(q, W) } } function Ct(e, n, t, o = null) { h(e, n, 7, [t, o]) } function Pt(e, n, o = !1) { const r = e.children, s = n.children; if ((0, t.isArray)(r) && (0, t.isArray)(s)) for (let t = 0; t < r.length; t++) { const e = r[t]; let n = s[t]; 1 & n.shapeFlag && !n.dynamicChildren && ((n.patchFlag <= 0 || 32 === n.patchFlag) && ((n = s[t] = ho(s[t])).el = e.el), o || Pt(e, n)) } } function wt(e) { const n = e.slice(), t = [0]; let o, r, s, i, l; const c = e.length; for (o = 0; o < c; o++) { const c = e[o]; if (0 !== c) { if (e[r = t[t.length - 1]] < c) { n[o] = r, t.push(o); continue } for (s = 0, i = t.length - 1; s < i;)e[t[l = (s + i) / 2 | 0]] < c ? s = l + 1 : i = l; c < e[t[s]] && (s > 0 && (n[o] = t[s - 1]), t[s] = o) } } for (i = t[(s = t.length) - 1]; s-- > 0;)t[s] = i, i = n[i]; return t } const Ft = e => e.__isTeleport, Tt = e => e && (e.disabled || "" === e.disabled), kt = (e, n) => { const o = e && e.to; if ((0, t.isString)(o)) { if (n) { const e = n(o); return e } return null } return o }, Et = { __isTeleport: !0, process(e, n, t, o, r, s, i, l, c) { const { mc: a, pc: u, pbc: p, o: { insert: d, querySelector: f, createText: h, createComment: m } } = c, g = Tt(n.props), { shapeFlag: y, children: v } = n; if (null == e) { const e = n.el = h(""), c = n.anchor = h(""); d(e, t, o), d(c, t, o); const u = n.target = kt(n.props, f), p = n.targetAnchor = h(""); u && d(p, u); const m = (e, n) => { 16 & y && a(v, e, n, r, s, i, l) }; g ? m(t, c) : u && m(u, p) } else { n.el = e.el; const o = n.anchor = e.anchor, a = n.target = e.target, d = n.targetAnchor = e.targetAnchor, h = Tt(e.props), m = h ? t : a, y = h ? o : d; if (n.dynamicChildren ? (p(e.dynamicChildren, n.dynamicChildren, m, r, s, i), Pt(e, n, !0)) : l || u(e, n, m, y, r, s, i), g) h || St(n, t, o, c, 1); else if ((n.props && n.props.to) !== (e.props && e.props.to)) { const e = n.target = kt(n.props, f); e && St(n, e, null, c, 0) } else h && St(n, a, d, c, 1) } }, remove(e, { r: n, o: { remove: t } }) { const { shapeFlag: o, children: r, anchor: s } = e; if (t(s), 16 & o) for (let i = 0; i < r.length; i++)n(r[i]) }, move: St, hydrate: At }; function St(e, n, t, { o: { insert: o }, m: r }, s = 2) { 0 === s && o(e.targetAnchor, n, t); const { el: i, anchor: l, shapeFlag: c, children: a, props: u } = e, p = 2 === s; if (p && o(i, n, t), (!p || Tt(u)) && 16 & c) for (let d = 0; d < a.length; d++)r(a[d], n, t, 2); p && o(l, n, t) } function At(e, n, t, o, r, { o: { nextSibling: s, parentNode: i, querySelector: l } }, c) { const a = n.target = kt(n.props, l); if (a) { const l = a._lpa || a.firstChild; 16 & n.shapeFlag && (Tt(n.props) ? (n.anchor = c(s(e), n, i(e), t, o, r), n.targetAnchor = l) : (n.anchor = s(e), n.targetAnchor = c(l, n, a, t, o, r)), a._lpa = n.targetAnchor && s(n.targetAnchor)) } return n.anchor && s(n.anchor) } const Rt = Et; exports.Teleport = Rt; const Bt = "components", Mt = "directives"; function jt(e) { return Ut(Bt, e) || e } const Vt = Symbol(); function $t(e) { return (0, t.isString)(e) ? Ut(Bt, e, !1) || e : e || Vt } function Nt(e) { return Ut(Mt, e) } function Ut(e, n, o = !0) { const r = ue || Io; if (r) { const o = r.type; if (e === Bt) { const e = o.displayName || o.name; if (e && (e === n || e === (0, t.camelize)(n) || e === (0, t.capitalize)((0, t.camelize)(n)))) return o } const s = It(r[e] || o[e], n) || It(r.appContext[e], n); return s } } function It(e, n) { return e && (e[n] || e[(0, t.camelize)(n)] || e[(0, t.capitalize)((0, t.camelize)(n))]) } const Lt = Symbol(void 0); exports.Fragment = Lt; const Dt = Symbol(void 0); exports.Text = Dt; const Yt = Symbol(void 0); exports.Comment = Yt; const Ht = Symbol(void 0); exports.Static = Ht; const Jt = []; let zt = null; function Kt(e = !1) { Jt.push(zt = e ? null : []) } function qt() { Jt.pop(), zt = Jt[Jt.length - 1] || null } let Gt, Wt = 1; function Qt(e) { Wt += e } function Xt(e, n, o, r, s) { const i = io(e, n, o, r, s, !0); return i.dynamicChildren = zt || t.EMPTY_ARR, qt(), Wt > 0 && zt && zt.push(i), i } function Zt(e) { return !!e && !0 === e.__v_isVNode } function eo(e, n) { return e.type === n.type && e.key === n.key } function no(e) { Gt = e } const to = (...e) => lo(...Gt ? Gt(e, ue) : e), oo = "__vInternal", ro = ({ key: e }) => null != e ? e : null, so = ({ ref: e }) => null != e ? (0, t.isArray)(e) ? e : { i: ue, r: e } : null, io = lo; function lo(e, o = null, r = null, s = 0, i = null, l = !1) { if (e && e !== Vt || (e = Yt), Zt(e)) { const n = co(e, o, !0); return r && mo(n, r), n } if (rr(e) && (e = e.__vccOpts), o) { ((0, n.isProxy)(o) || oo in o) && (o = (0, t.extend)({}, o)); let { class: e, style: r } = o; e && !(0, t.isString)(e) && (o.class = (0, t.normalizeClass)(e)), (0, t.isObject)(r) && ((0, n.isProxy)(r) && !(0, t.isArray)(r) && (r = (0, t.extend)({}, r)), o.style = (0, t.normalizeStyle)(r)) } const c = (0, t.isString)(e) ? 1 : Ce(e) ? 128 : Ft(e) ? 64 : (0, t.isObject)(e) ? 4 : (0, t.isFunction)(e) ? 2 : 0; const a = { __v_isVNode: !0, __v_skip: !0, type: e, props: o, key: o && ro(o), ref: o && so(o), scopeId: Ue, children: null, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: c, patchFlag: s, dynamicProps: i, dynamicChildren: null, appContext: null }; if (mo(a, r), 128 & c) { const { content: e, fallback: n } = Ae(a); a.ssContent = e, a.ssFallback = n } return Wt > 0 && !l && zt && (s > 0 || 6 & c) && 32 !== s && zt.push(a), a } function co(e, n, o = !1) { const { props: r, ref: s, patchFlag: i } = e, l = n ? go(r || {}, n) : r; return { __v_isVNode: !0, __v_skip: !0, type: e.type, props: l, key: l && ro(l), ref: n && n.ref ? o && s ? (0, t.isArray)(s) ? s.concat(so(n)) : [s, so(n)] : so(n) : s, scopeId: e.scopeId, children: e.children, target: e.target, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: n && e.type !== Lt ? -1 === i ? 16 : 16 | i : i, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: e.transition, component: e.component, suspense: e.suspense, ssContent: e.ssContent && co(e.ssContent), ssFallback: e.ssFallback && co(e.ssFallback), el: e.el, anchor: e.anchor } } function ao(e = " ", n = 0) { return io(Dt, null, e, n) } function uo(e, n) { const t = io(Ht, null, e); return t.staticCount = n, t } function po(e = "", n = !1) { return n ? (Kt(), Xt(Yt, null, e)) : io(Yt, null, e) } function fo(e) { return null == e || "boolean" == typeof e ? io(Yt) : (0, t.isArray)(e) ? io(Lt, null, e) : "object" == typeof e ? null === e.el ? e : co(e) : io(Dt, null, String(e)) } function ho(e) { return null === e.el ? e : co(e) } function mo(e, n) { let o = 0; const { shapeFlag: r } = e; if (null == n) n = null; else if ((0, t.isArray)(n)) o = 16; else if ("object" == typeof n) { if (1 & r || 64 & r) { const t = n.default; return void (t && (t._c && Ve(1), mo(e, t()), t._c && Ve(-1))) } { o = 32; const t = n._; t || oo in n ? 3 === t && ue && (1024 & ue.vnode.patchFlag ? (n._ = 2, e.patchFlag |= 1024) : n._ = 1) : n._ctx = ue } } else (0, t.isFunction)(n) ? (n = { default: n, _ctx: ue }, o = 32) : (n = String(n), 64 & r ? (o = 16, n = [ao(n)]) : o = 8); e.children = n, e.shapeFlag |= o } function go(...e) { const n = (0, t.extend)({}, e[0]); for (let o = 1; o < e.length; o++) { const r = e[o]; for (const e in r) if ("class" === e) n.class !== r.class && (n.class = (0, t.normalizeClass)([n.class, r.class])); else if ("style" === e) n.style = (0, t.normalizeStyle)([n.style, r.style]); else if ((0, t.isOn)(e)) { const t = n[e], o = r[e]; t !== o && (n[e] = t ? [].concat(t, r[e]) : o) } else "" !== e && (n[e] = r[e]) } return n } function yo(e, n) { if (Io) { let t = Io.provides; const o = Io.parent && Io.parent.provides; o === t && (t = Io.provides = Object.create(o)), t[e] = n } else 0 } function vo(e, n, o = !1) { const r = Io || ue; if (r) { const s = null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides; if (s && e in s) return s[e]; if (arguments.length > 1) return o && (0, t.isFunction)(n) ? n() : n } else 0 } function xo() { const e = Object.create(null); return (n, t) => { e[t] ? i(`${n} property "${t}" is already defined in ${e[t]}.`) : e[t] = n } } exports.createVNode = io; let _o = !1; function bo(e, n, o = [], r = [], s = [], i = !1) { const { mixins: l, extends: c, data: a, computed: u, methods: p, watch: d, provide: f, inject: h, components: m, directives: g, beforeMount: y, mounted: v, beforeUpdate: x, updated: _, activated: b, deactivated: O, beforeDestroy: C, beforeUnmount: P, destroyed: w, unmounted: F, render: T, renderTracked: k, renderTriggered: E, errorCaptured: S } = n, A = e.proxy, R = e.ctx, B = e.appContext.mixins; i && T && e.render === t.NOOP && (e.render = T), i || (_o = !0, Oo("beforeCreate", "bc", n, e, B), _o = !1, wo(e, B, o, r, s)), c && bo(e, c, o, r, s, !0), l && wo(e, l, o, r, s); if (h) if ((0, t.isArray)(h)) for (let t = 0; t < h.length; t++) { const e = h[t]; R[e] = vo(e) } else for (const M in h) { const e = h[M]; (0, t.isObject)(e) ? R[M] = vo(e.from || M, e.default, !0) : R[M] = vo(e) } if (p) for (const M in p) { const e = p[M]; (0, t.isFunction)(e) && (R[M] = e.bind(A)) } if (i ? a && o.push(a) : (o.length && o.forEach(n => Fo(e, n, A)), a && Fo(e, a, A)), u) for (const M in u) { const e = u[M], n = (0, t.isFunction)(e) ? e.bind(A, A) : (0, t.isFunction)(e.get) ? e.get.bind(A, A) : t.NOOP; 0; const o = sr({ get: n, set: !(0, t.isFunction)(e) && (0, t.isFunction)(e.set) ? e.set.bind(A) : t.NOOP }); Object.defineProperty(R, M, { enumerable: !0, configurable: !0, get: () => o.value, set: e => o.value = e }) } d && r.push(d), !i && r.length && r.forEach(e => { for (const n in e) To(e[n], R, A, n) }), f && s.push(f), !i && s.length && s.forEach(e => { const n = (0, t.isFunction)(e) ? e.call(A) : e; for (const t in n) yo(t, n[t]) }), i && (m && (0, t.extend)(e.components || (e.components = (0, t.extend)({}, e.type.components)), m), g && (0, t.extend)(e.directives || (e.directives = (0, t.extend)({}, e.type.directives)), g)), i || Oo("created", "c", n, e, B), y && un(y.bind(A)), v && pn(v.bind(A)), x && dn(x.bind(A)), _ && fn(_.bind(A)), b && In(b.bind(A)), O && Ln(O.bind(A)), S && vn(S.bind(A)), k && yn(k.bind(A)), E && gn(E.bind(A)), P && hn(P.bind(A)), F && mn(F.bind(A)) } function Oo(e, n, t, o, r) { Po(e, n, r, o); const { extends: s, mixins: i } = t; s && Co(e, n, s, o), i && Po(e, n, i, o); const l = t[e]; l && h(l.bind(o.proxy), o, n) } function Co(e, n, t, o) { t.extends && Co(e, n, t.extends, o); const r = t[e]; r && h(r.bind(o.proxy), o, n) } function Po(e, n, t, o) { for (let r = 0; r < t.length; r++) { const s = t[r].mixins; s && Po(e, n, s, o); const i = t[r][e]; i && h(i.bind(o.proxy), o, n) } } function wo(e, n, t, o, r) { for (let s = 0; s < n.length; s++)bo(e, n[s], t, o, r, !0) } function Fo(e, o, r) { const s = o.call(r, r); (0, t.isObject)(s) && (e.data === t.EMPTY_OBJ ? e.data = (0, n.reactive)(s) : (0, t.extend)(e.data, s)) } function To(e, n, o, r) { const s = r.includes(".") ? ko(o, r) : () => o[r]; if ((0, t.isString)(e)) { const o = n[e]; (0, t.isFunction)(o) && bn(s, o) } else if ((0, t.isFunction)(e)) bn(s, e.bind(o)); else if ((0, t.isObject)(e)) if ((0, t.isArray)(e)) e.forEach(e => To(e, n, o, r)); else { const r = (0, t.isFunction)(e.handler) ? e.handler.bind(o) : n[e.handler]; (0, t.isFunction)(r) && bn(s, r, e) } else 0 } function ko(e, n) { const t = n.split("."); return () => { let n = e; for (let e = 0; e < t.length && n; e++)n = n[t[e]]; return n } } function Eo(e) { const n = e.type, { __merged: t, mixins: o, extends: r } = n; if (t) return t; const s = e.appContext.mixins; if (!s.length && !o && !r) return n; const i = {}; return s.forEach(n => So(i, n, e)), So(i, n, e), n.__merged = i } function So(e, n, o) { const r = o.appContext.config.optionMergeStrategies, { mixins: s, extends: i } = n; i && So(e, i, o), s && s.forEach(n => So(e, n, o)); for (const l in n) r && (0, t.hasOwn)(r, l) ? e[l] = r[l](e[l], n[l], o.proxy, l) : e[l] = n[l] } const Ao = (0, t.extend)(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => e.parent && e.parent.proxy, $root: e => e.root && e.root.proxy, $emit: e => e.emit, $options: e => __VUE_OPTIONS_API__ ? Eo(e) : e.type, $forceUpdate: e => () => R(e.update), $nextTick: e => A.bind(e.proxy), $watch: e => __VUE_OPTIONS_API__ ? Cn.bind(e) : t.NOOP }), Ro = { get({ _: e }, o) { const { ctx: r, setupState: s, data: i, props: l, accessCache: c, type: a, appContext: u } = e; if ("__v_skip" === o) return !0; let p; if ("$" !== o[0]) { const n = c[o]; if (void 0 !== n) switch (n) { case 0: return s[o]; case 1: return i[o]; case 3: return r[o]; case 2: return l[o] } else { if (s !== t.EMPTY_OBJ && (0, t.hasOwn)(s, o)) return c[o] = 0, s[o]; if (i !== t.EMPTY_OBJ && (0, t.hasOwn)(i, o)) return c[o] = 1, i[o]; if ((p = e.propsOptions[0]) && (0, t.hasOwn)(p, o)) return c[o] = 2, l[o]; if (r !== t.EMPTY_OBJ && (0, t.hasOwn)(r, o)) return c[o] = 3, r[o]; __VUE_OPTIONS_API__ && _o || (c[o] = 4) } } const d = Ao[o]; let f, h; return d ? ("$attrs" === o && (0, n.track)(e, "get", o), d(e)) : (f = a.__cssModules) && (f = f[o]) ? f : r !== t.EMPTY_OBJ && (0, t.hasOwn)(r, o) ? (c[o] = 3, r[o]) : (h = u.config.globalProperties, (0, t.hasOwn)(h, o) ? h[o] : void 0) }, set({ _: e }, n, o) { const { data: r, setupState: s, ctx: i } = e; if (s !== t.EMPTY_OBJ && (0, t.hasOwn)(s, n)) s[n] = o; else if (r !== t.EMPTY_OBJ && (0, t.hasOwn)(r, n)) r[n] = o; else if (n in e.props) return !1; return !("$" === n[0] && n.slice(1) in e) && (i[n] = o, !0) }, has({ _: { data: e, setupState: n, accessCache: o, ctx: r, appContext: s, propsOptions: i } }, l) { let c; return void 0 !== o[l] || e !== t.EMPTY_OBJ && (0, t.hasOwn)(e, l) || n !== t.EMPTY_OBJ && (0, t.hasOwn)(n, l) || (c = i[0]) && (0, t.hasOwn)(c, l) || (0, t.hasOwn)(r, l) || (0, t.hasOwn)(Ao, l) || (0, t.hasOwn)(s.config.globalProperties, l) } }; const Bo = (0, t.extend)({}, Ro, { get(e, n) { if (n !== Symbol.unscopables) return Ro.get(e, n, e) }, has(e, n) { const o = "_" !== n[0] && !(0, t.isGloballyWhitelisted)(n); return o } }); function Mo(e) { const n = {}; Object.defineProperty(n, "_", { configurable: !0, enumerable: !1, get: () => e }), Object.keys(Ao).forEach(o => { Object.defineProperty(n, o, { configurable: !0, enumerable: !1, get: () => Ao[o](e), set: t.NOOP }) }); const { globalProperties: o } = e.appContext.config; return Object.keys(o).forEach(e => { Object.defineProperty(n, e, { configurable: !0, enumerable: !1, get: () => o[e], set: t.NOOP }) }), n } function jo(e) { const { ctx: n, propsOptions: [o] } = e; o && Object.keys(o).forEach(o => { Object.defineProperty(n, o, { enumerable: !0, configurable: !0, get: () => e.props[o], set: t.NOOP }) }) } function Vo(e) { const { ctx: o, setupState: r } = e; Object.keys((0, n.toRaw)(r)).forEach(e => { "$" !== e[0] && "_" !== e[0] ? Object.defineProperty(o, e, { enumerable: !0, configurable: !0, get: () => r[e], set: t.NOOP }) : i(`setup() return property ${JSON.stringify(e)} should not start with "$" or "_" ` + "which are reserved prefixes for Vue internals.") }) } const $o = ot(); let No = 0; function Uo(e, n, o) { const r = e.type, s = (n ? n.appContext : e.appContext) || $o, i = { uid: No++, vnode: e, type: r, parent: n, appContext: s, root: null, next: null, subTree: null, update: null, render: null, proxy: null, withProxy: null, effects: null, provides: n ? n.provides : Object.create(s.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: qe(r, s), emitsOptions: ce(r, s), emit: null, emitted: null, ctx: t.EMPTY_OBJ, data: t.EMPTY_OBJ, props: t.EMPTY_OBJ, attrs: t.EMPTY_OBJ, slots: t.EMPTY_OBJ, refs: t.EMPTY_OBJ, setupState: t.EMPTY_OBJ, setupContext: null, suspense: o, suspenseId: o ? o.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null }; return i.ctx = { _: i }, i.root = n ? n.root : i, i.emit = le.bind(null, i), __VUE_PROD_DEVTOOLS__ && te(i), i } let Io = null; const Lo = () => Io || ue; exports.getCurrentInstance = Lo; const Do = e => { Io = e }, Yo = (0, t.makeMap)("slot,component"); function Ho(e, n) { const o = n.isNativeTag || t.NO; (Yo(e) || o(e)) && i("Do not use built-in or reserved HTML elements as component id: " + e) } let Jo, zo = !1; function Ko(e, n = !1) { zo = n; const { props: t, children: o, shapeFlag: r } = e.vnode, s = 4 & r; He(e, t, s, n), Qn(e, o); const i = s ? qo(e, n) : void 0; return zo = !1, i } function qo(e, o) { const r = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Ro); const { setup: s } = r; if (s) { const r = e.setupContext = s.length > 1 ? Zo(e) : null; Io = e, (0, n.pauseTracking)(); const i = f(s, e, 0, [e.props, r]); if ((0, n.resetTracking)(), Io = null, (0, t.isPromise)(i)) { if (o) return i.then(n => { Go(e, n) }); e.asyncDep = i } else Go(e, i) } else Qo(e) } function Go(e, o, r) { (0, t.isFunction)(o) ? e.render = o : (0, t.isObject)(o) && (__VUE_PROD_DEVTOOLS__ && (e.devtoolsRawSetupState = o), e.setupState = (0, n.proxyRefs)(o)), Qo(e) } function Wo(e) { Jo = e } function Qo(e, n) { const o = e.type; e.render || (Jo && o.template && !o.render && (o.render = Jo(o.template, { isCustomElement: e.appContext.config.isCustomElement, delimiters: o.delimiters })), e.render = o.render || t.NOOP, e.render._rc && (e.withProxy = new Proxy(e.ctx, Bo))), __VUE_OPTIONS_API__ && (Io = e, bo(e, o), Io = null) } const Xo = { get: (e, n) => e[n], set: () => (i("setupContext.attrs is readonly."), !1), deleteProperty: () => (i("setupContext.attrs is readonly."), !1) }; function Zo(e) { return { attrs: e.attrs, slots: e.slots, emit: e.emit } } function er(e) { Io && (Io.effects || (Io.effects = [])).push(e) } const nr = /(?:^|[-_])(\w)/g, tr = e => e.replace(nr, e => e.toUpperCase()).replace(/[-_]/g, ""); function or(e, n, o = !1) { let r = (0, t.isFunction)(n) && n.displayName || n.name; if (!r && n.__file) { const e = n.__file.match(/([^/\\]+)\.vue$/); e && (r = e[1]) } if (!r && e && e.parent) { const t = e => { for (const t in e) if (e[t] === n) return t }; r = t(e.components || e.parent.type.components) || t(e.appContext.components) } return r ? tr(r) : o ? "App" : "Anonymous" } function rr(e) { return (0, t.isFunction)(e) && "__vccOpts" in e } function sr(e) { const t = (0, n.computed)(e); return er(t.effect), t } function ir(e) { return (0, t.isFunction)(e) ? { setup: e, name: e.name } : e } function lr(e) { (0, t.isFunction)(e) && (e = { loader: e }); const { loader: o, loadingComponent: r, errorComponent: s, delay: i = 200, timeout: l, suspensible: c = !0, onError: a } = e; let u, p = null, d = 0; const f = () => { let e; return p || (e = p = o().catch(e => { if (e = e instanceof Error ? e : new Error(String(e)), a) return new Promise((n, t) => { a(e, () => n((() => (d++, p = null, f()))()), () => t(e), d + 1) }); throw e }).then(n => e !== p && p ? p : (n && (n.__esModule || "Module" === n[Symbol.toStringTag]) && (n = n.default), u = n, n))) }; return ir({ __asyncLoader: f, name: "AsyncComponentWrapper", setup() { const e = Io; if (u) return () => cr(u, e); const t = n => { p = null, m(n, e, 13, !s) }; if (c && e.suspense) return f().then(n => () => cr(n, e)).catch(e => (t(e), () => s ? io(s, { error: e }) : null)); const o = (0, n.ref)(!1), a = (0, n.ref)(), d = (0, n.ref)(!!i); return i && setTimeout(() => { d.value = !1 }, i), null != l && setTimeout(() => { if (!o.value && !a.value) { const e = new Error(`Async component timed out after ${l}ms.`); t(e), a.value = e } }, l), f().then(() => { o.value = !0 }).catch(e => { t(e), a.value = e }), () => o.value && u ? cr(u, e) : a.value && s ? io(s, { error: a.value }) : r && !d.value ? io(r) : void 0 } }) } function cr(e, { vnode: { props: n, children: t } }) { return io(e, n, t) } function ar(e, n, o) { const r = arguments.length; return 2 === r ? (0, t.isObject)(n) && !(0, t.isArray)(n) ? Zt(n) ? io(e, null, [n]) : io(e, n) : io(e, null, n) : (r > 3 ? o = Array.prototype.slice.call(arguments, 2) : 3 === r && Zt(o) && (o = [o]), io(e, n, o)) } const ur = Symbol(""); exports.ssrContextKey = ur; const pr = () => { { const e = vo(ur); return e || i("Server rendering context not provided. Make sure to only call useSsrContext() conditionally in the server build."), e } }; function dr() { return void 0 } function fr(e, n) { let o; if ((0, t.isArray)(e) || (0, t.isString)(e)) { o = new Array(e.length); for (let t = 0, r = e.length; t < r; t++)o[t] = n(e[t], t) } else if ("number" == typeof e) { 0, o = new Array(e); for (let t = 0; t < e; t++)o[t] = n(t + 1, t) } else if ((0, t.isObject)(e)) if (e[Symbol.iterator]) o = Array.from(e, n); else { const t = Object.keys(e); o = new Array(t.length); for (let r = 0, s = t.length; r < s; r++) { const s = t[r]; o[r] = n(e[s], s, r) } } else o = []; return o } function hr(e) { const n = {}; for (const o in e) n[(0, t.toHandlerKey)(o)] = e[o]; return n } function mr(e, n) { for (let o = 0; o < n.length; o++) { const r = n[o]; if ((0, t.isArray)(r)) for (let n = 0; n < r.length; n++)e[r[n].name] = r[n].fn; else r && (e[r.name] = r.fn) } return e } exports.useSSRContext = pr; const gr = "3.0.2"; exports.version = gr; const yr = null; exports.ssrUtils = null;
    }, { "@vue/reactivity": "JZte", "@vue/shared": "tWCa" }], "KZzx": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); var e = { Transition: !0, TransitionGroup: !0, createApp: !0, createSSRApp: !0, hydrate: !0, render: !0, useCssModule: !0, useCssVars: !0, vModelCheckbox: !0, vModelDynamic: !0, vModelRadio: !0, vModelSelect: !0, vModelText: !0, vShow: !0, withKeys: !0, withModifiers: !0 }; exports.useCssModule = O, exports.useCssVars = B, exports.withModifiers = exports.withKeys = exports.vShow = exports.vModelText = exports.vModelSelect = exports.vModelRadio = exports.vModelDynamic = exports.vModelCheckbox = exports.render = exports.hydrate = exports.createSSRApp = exports.createApp = exports.TransitionGroup = exports.Transition = void 0; var t = require("@vue/runtime-core"); Object.keys(t).forEach(function (n) { "default" !== n && "__esModule" !== n && (Object.prototype.hasOwnProperty.call(e, n) || n in exports && exports[n] === t[n] || Object.defineProperty(exports, n, { enumerable: !0, get: function () { return t[n] } })) }); var n = require("@vue/shared"); const o = "http://www.w3.org/2000/svg", r = "undefined" != typeof document ? document : null; let s, a; const i = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n) => t ? r.createElementNS(o, e) : r.createElement(e, n ? { is: n } : void 0), createText: e => r.createTextNode(e), createComment: e => r.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => r.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, cloneNode: e => e.cloneNode(!0), insertStaticContent(e, t, n, l) { const c = l ? a || (a = r.createElementNS(o, "svg")) : s || (s = r.createElement("div")); c.innerHTML = e; const u = c.firstChild; let p = u, d = p; for (; p;)d = p, i.insert(p, t, n), p = c.firstChild; return [u, d] } }; function l(e, t, n) { if (null == t && (t = ""), n) e.setAttribute("class", t); else { const n = e._vtc; n && (t = (t ? [t, ...n] : [...n]).join(" ")), e.className = t } } function c(e, t, o) { const r = e.style; if (o) if ((0, n.isString)(o)) t !== o && (r.cssText = o); else { for (const e in o) p(r, e, o[e]); if (t && !(0, n.isString)(t)) for (const e in t) null == o[e] && p(r, e, "") } else e.removeAttribute("style") } const u = /\s*!important$/; function p(e, t, o) { if ((0, n.isArray)(o)) o.forEach(n => p(e, t, n)); else if (t.startsWith("--")) e.setProperty(t, o); else { const r = m(e, t); u.test(o) ? e.setProperty((0, n.hyphenate)(r), o.replace(u, ""), "important") : e[r] = o } } const d = ["Webkit", "Moz", "ms"], f = {}; function m(e, o) { const r = f[o]; if (r) return r; let s = (0, t.camelize)(o); if ("filter" !== s && s in e) return f[o] = s; s = (0, n.capitalize)(s); for (let t = 0; t < d.length; t++) { const n = d[t] + s; if (n in e) return f[o] = n } return o } const v = "http://www.w3.org/1999/xlink"; function g(e, t, o, r) { if (r && t.startsWith("xlink:")) null == o ? e.removeAttributeNS(v, t.slice(6, t.length)) : e.setAttributeNS(v, t, o); else { const r = (0, n.isSpecialBooleanAttr)(t); null == o || r && !1 === o ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : o) } } function h(e, t, n, o, r, s, a) { if ("innerHTML" === t || "textContent" === t) return o && a(o, r, s), void (e[t] = null == n ? "" : n); if ("value" !== t || "PROGRESS" === e.tagName) if ("" === n && "boolean" == typeof e[t]) e[t] = !0; else if (null == n && "string" == typeof e[t]) e[t] = "", e.removeAttribute(t); else try { e[t] = n } catch (i) { 0 } else { e._value = n; const t = null == n ? "" : n; e.value !== t && (e.value = t) } } let y = Date.now; "undefined" != typeof document && y() > document.createEvent("Event").timeStamp && (y = (() => performance.now())); let b = 0; const x = Promise.resolve(), C = () => { b = 0 }, T = () => b || (x.then(C), b = y()); function _(e, t, n, o) { e.addEventListener(t, n, o) } function S(e, t, n, o) { e.removeEventListener(t, n, o) } function E(e, t, n, o, r = null) { const s = e._vei || (e._vei = {}), a = s[t]; if (o && a) a.value = o; else { const [n, i] = w(t); if (o) { _(e, n, s[t] = M(o, r), i) } else a && (S(e, n, a, i), s[t] = void 0) } } const A = /(?:Once|Passive|Capture)$/; function w(e) { let t; if (A.test(e)) { let n; for (t = {}; n = e.match(A);)e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0 } return [e.slice(2).toLowerCase(), t] } function M(e, n) { const o = e => { (e.timeStamp || y()) >= o.attached - 1 && (0, t.callWithAsyncErrorHandling)(k(e, o.value), n, 5, [e]) }; return o.value = e, o.attached = T(), o } function k(e, t) { if ((0, n.isArray)(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = (() => { n.call(e), e._stopped = !0 }), t.map(e => t => !t._stopped && e(t)) } return t } const N = /^on[a-z]/, L = (e, t) => "value" === t, P = (e, t, o, r, s = !1, a, i, u, p) => { switch (t) { case "class": l(e, r, s); break; case "style": c(e, o, r); break; default: (0, n.isOn)(t) ? (0, n.isModelListener)(t) || E(e, t, o, r, i) : $(e, t, r, s) ? h(e, t, r, a, i, u, p) : ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r), g(e, t, r, s)) } }; function $(e, t, o, r) { return r ? "innerHTML" === t || !!(t in e && N.test(t) && (0, n.isFunction)(o)) : "spellcheck" !== t && "draggable" !== t && (("form" !== t || "string" != typeof o) && (("list" !== t || "INPUT" !== e.tagName) && ((!N.test(t) || !(0, n.isString)(o)) && t in e))) } function O(e = "$style") { { const o = (0, t.getCurrentInstance)(); if (!o) return n.EMPTY_OBJ; const r = o.type.__cssModules; if (!r) return n.EMPTY_OBJ; const s = r[e]; return s || n.EMPTY_OBJ } } function B(e, n = !1) { const o = (0, t.getCurrentInstance)(); if (!o) return; const r = n && o.type.__scopeId ? `${o.type.__scopeId.replace(/^data-v-/, "")}-` : "", s = () => F(o.subTree, e(o.proxy), r); (0, t.onMounted)(() => (0, t.watchEffect)(s)), (0, t.onUpdated)(s) } function F(e, n, o) { if (128 & e.shapeFlag) { const t = e.suspense; e = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => { F(t.activeBranch, n, o) }) } for (; e.component;)e = e.component.subTree; if (1 & e.shapeFlag && e.el) { const r = e.el.style; for (const e in n) r.setProperty(`--${o}${e}`, (0, t.unref)(n[e])) } else e.type === t.Fragment && e.children.forEach(e => F(e, n, o)) } const H = "transition", V = "animation", I = (e, { slots: n }) => (0, t.h)(t.BaseTransition, D(e), n); exports.Transition = I, I.displayName = "Transition"; const R = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, q = I.props = (0, n.extend)({}, t.BaseTransition.props, R); function D(e) { let { name: t = "v", type: o, css: r = !0, duration: s, enterFromClass: a = `${t}-enter-from`, enterActiveClass: i = `${t}-enter-active`, enterToClass: l = `${t}-enter-to`, appearFromClass: c = a, appearActiveClass: u = i, appearToClass: p = l, leaveFromClass: d = `${t}-leave-from`, leaveActiveClass: f = `${t}-leave-active`, leaveToClass: m = `${t}-leave-to` } = e; const v = {}; for (const n in e) n in R || (v[n] = e[n]); if (!r) return v; const g = U(s), h = g && g[0], y = g && g[1], { onBeforeEnter: b, onEnter: x, onEnterCancelled: C, onLeave: T, onLeaveCancelled: _, onBeforeAppear: S = b, onAppear: E = x, onAppearCancelled: A = C } = v, w = (e, t, n) => { G(e, t ? p : l), G(e, t ? u : i), n && n() }, M = (e, t) => { G(e, m), G(e, f), t && t() }, k = e => (t, n) => { const r = e ? E : x, s = () => w(t, e, n); r && r(t, s), W(() => { G(t, e ? c : a), z(t, e ? p : l), r && r.length > 1 || (h ? setTimeout(s, h) : J(t, o, s)) }) }; return (0, n.extend)(v, { onBeforeEnter(e) { b && b(e), z(e, i), z(e, a) }, onBeforeAppear(e) { S && S(e), z(e, u), z(e, c) }, onEnter: k(!1), onAppear: k(!0), onLeave(e, t) { const n = () => M(e, t); z(e, f), z(e, d), W(() => { G(e, d), z(e, m), T && T.length > 1 || (y ? setTimeout(n, y) : J(e, o, n)) }), T && T(e, n) }, onEnterCancelled(e) { w(e, !1), C && C(e) }, onAppearCancelled(e) { w(e, !0), A && A(e) }, onLeaveCancelled(e) { M(e), _ && _(e) } }) } function U(e) { if (null == e) return null; if ((0, n.isObject)(e)) return [j(e.enter), j(e.leave)]; { const t = j(e); return [t, t] } } function j(e) { const t = (0, n.toNumber)(e); return t } function K(e) { "number" != typeof e ? (0, t.warn)("<transition> explicit duration is not a valid number - " + `got ${JSON.stringify(e)}.`) : isNaN(e) && (0, t.warn)("<transition> explicit duration is NaN - the duration expression might be incorrect.") } function z(e, t) { t.split(/\s+/).forEach(t => t && e.classList.add(t)), (e._vtc || (e._vtc = new Set)).add(t) } function G(e, t) { t.split(/\s+/).forEach(t => t && e.classList.remove(t)); const { _vtc: n } = e; n && (n.delete(t), n.size || (e._vtc = void 0)) } function W(e) { requestAnimationFrame(() => { requestAnimationFrame(e) }) } function J(e, t, n) { const { type: o, timeout: r, propCount: s } = Y(e, t); if (!o) return n(); const a = o + "end"; let i = 0; const l = () => { e.removeEventListener(a, c), n() }, c = t => { t.target === e && ++i >= s && l() }; setTimeout(() => { i < s && l() }, r + 1), e.addEventListener(a, c) } function Y(e, t) { const n = window.getComputedStyle(e), o = e => (n[e] || "").split(", "), r = o(H + "Delay"), s = o(H + "Duration"), a = X(r, s), i = o(V + "Delay"), l = o(V + "Duration"), c = X(i, l); let u = null, p = 0, d = 0; return t === H ? a > 0 && (u = H, p = a, d = s.length) : t === V ? c > 0 && (u = V, p = c, d = l.length) : d = (u = (p = Math.max(a, c)) > 0 ? a > c ? H : V : null) ? u === H ? s.length : l.length : 0, { type: u, timeout: p, propCount: d, hasTransform: u === H && /\b(transform|all)(,|$)/.test(n[H + "Property"]) } } function X(e, t) { for (; e.length < t.length;)e = e.concat(e); return Math.max(...t.map((t, n) => Q(t) + Q(e[n]))) } function Q(e) { return 1e3 * Number(e.slice(0, -1).replace(",", ".")) } function Z(e) { return e && Z(e.__v_raw) || e } const ee = new WeakMap, te = new WeakMap, ne = { name: "TransitionGroup", props: (0, n.extend)({}, q, { tag: String, moveClass: String }), setup(e, { slots: n }) { const o = (0, t.getCurrentInstance)(), r = (0, t.useTransitionState)(); let s, a; return (0, t.onUpdated)(() => { if (!s.length) return; const t = e.moveClass || `${e.name || "v"}-move`; if (!le(s[0].el, o.vnode.el, t)) return; s.forEach(re), s.forEach(se); const n = s.filter(ae); ie(), n.forEach(e => { const n = e.el, o = n.style; z(n, t), o.transform = o.webkitTransform = o.transitionDuration = ""; const r = n._moveCb = (e => { e && e.target !== n || e && !/transform$/.test(e.propertyName) || (n.removeEventListener("transitionend", r), n._moveCb = null, G(n, t)) }); n.addEventListener("transitionend", r) }) }), () => { const i = Z(e), l = D(i), c = i.tag || t.Fragment; s = a, a = n.default ? (0, t.getTransitionRawChildren)(n.default()) : []; for (let e = 0; e < a.length; e++) { const n = a[e]; null != n.key && (0, t.setTransitionHooks)(n, (0, t.resolveTransitionHooks)(n, l, r, o)) } if (s) for (let e = 0; e < s.length; e++) { const n = s[e]; (0, t.setTransitionHooks)(n, (0, t.resolveTransitionHooks)(n, l, r, o)), ee.set(n, n.el.getBoundingClientRect()) } return (0, t.createVNode)(c, null, a) } } }, oe = ne; function re(e) { const t = e.el; t._moveCb && t._moveCb(), t._enterCb && t._enterCb() } function se(e) { te.set(e, e.el.getBoundingClientRect()) } function ae(e) { const t = ee.get(e), n = te.get(e), o = t.left - n.left, r = t.top - n.top; if (o || r) { const t = e.el.style; return t.transform = t.webkitTransform = `translate(${o}px,${r}px)`, t.transitionDuration = "0s", e } } function ie() { return document.body.offsetHeight } function le(e, t, n) { const o = e.cloneNode(); e._vtc && e._vtc.forEach(e => { e.split(/\s+/).forEach(e => e && o.classList.remove(e)) }), n.split(/\s+/).forEach(e => e && o.classList.add(e)), o.style.display = "none"; const r = 1 === t.nodeType ? t : t.parentNode; r.appendChild(o); const { hasTransform: s } = Y(o); return r.removeChild(o), s } exports.TransitionGroup = oe; const ce = e => { const t = e.props["onUpdate:modelValue"]; return (0, n.isArray)(t) ? e => (0, n.invokeArrayFns)(t, e) : t }; function ue(e) { e.target.composing = !0 } function pe(e) { const t = e.target; t.composing && (t.composing = !1, de(t, "input")) } function de(e, t) { const n = document.createEvent("HTMLEvents"); n.initEvent(t, !0, !0), e.dispatchEvent(n) } const fe = { created(e, { modifiers: { lazy: t, trim: o, number: r } }, s) { e._assign = ce(s); const a = r || "number" === e.type; _(e, t ? "change" : "input", t => { if (t.target.composing) return; let r = e.value; o ? r = r.trim() : a && (r = (0, n.toNumber)(r)), e._assign(r) }), o && _(e, "change", () => { e.value = e.value.trim() }), t || (_(e, "compositionstart", ue), _(e, "compositionend", pe), _(e, "change", pe)) }, mounted(e, { value: t }) { e.value = null == t ? "" : t }, beforeUpdate(e, { value: t, modifiers: { trim: o, number: r } }, s) { if (e._assign = ce(s), e.composing) return; if (document.activeElement === e) { if (o && e.value.trim() === t) return; if ((r || "number" === e.type) && (0, n.toNumber)(e.value) === t) return } const a = null == t ? "" : t; e.value !== a && (e.value = a) } }; exports.vModelText = fe; const me = { created(e, t, o) { ve(e, t, o), e._assign = ce(o), _(e, "change", () => { const t = e._modelValue, o = be(e), r = e.checked, s = e._assign; if ((0, n.isArray)(t)) { const e = (0, n.looseIndexOf)(t, o), a = -1 !== e; if (r && !a) s(t.concat(o)); else if (!r && a) { const n = [...t]; n.splice(e, 1), s(n) } } else (0, n.isSet)(t) ? r ? t.add(o) : t.delete(o) : s(xe(e, r)) }) }, beforeUpdate(e, t, n) { e._assign = ce(n), ve(e, t, n) } }; function ve(e, { value: t, oldValue: o }, r) { e._modelValue = t, (0, n.isArray)(t) ? e.checked = (0, n.looseIndexOf)(t, r.props.value) > -1 : (0, n.isSet)(t) ? e.checked = t.has(r.props.value) : t !== o && (e.checked = (0, n.looseEqual)(t, xe(e, !0))) } exports.vModelCheckbox = me; const ge = { created(e, { value: t }, o) { e.checked = (0, n.looseEqual)(t, o.props.value), e._assign = ce(o), _(e, "change", () => { e._assign(be(e)) }) }, beforeUpdate(e, { value: t, oldValue: o }, r) { e._assign = ce(r), t !== o && (e.checked = (0, n.looseEqual)(t, r.props.value)) } }; exports.vModelRadio = ge; const he = { created(e, { modifiers: { number: t } }, o) { _(e, "change", () => { const o = Array.prototype.filter.call(e.options, e => e.selected).map(e => t ? (0, n.toNumber)(be(e)) : be(e)); e._assign(e.multiple ? o : o[0]) }), e._assign = ce(o) }, mounted(e, { value: t }) { ye(e, t) }, beforeUpdate(e, t, n) { e._assign = ce(n) }, updated(e, { value: t }) { ye(e, t) } }; function ye(e, t) { const o = e.multiple; if (!o || (0, n.isArray)(t) || (0, n.isSet)(t)) { for (let r = 0, s = e.options.length; r < s; r++) { const s = e.options[r], a = be(s); if (o) (0, n.isArray)(t) ? s.selected = (0, n.looseIndexOf)(t, a) > -1 : s.selected = t.has(a); else if ((0, n.looseEqual)(be(s), t)) return void (e.selectedIndex = r) } o || (e.selectedIndex = -1) } } function be(e) { return "_value" in e ? e._value : e.value } function xe(e, t) { const n = t ? "_trueValue" : "_falseValue"; return n in e ? e[n] : t } exports.vModelSelect = he; const Ce = { created(e, t, n) { Te(e, t, n, null, "created") }, mounted(e, t, n) { Te(e, t, n, null, "mounted") }, beforeUpdate(e, t, n, o) { Te(e, t, n, o, "beforeUpdate") }, updated(e, t, n, o) { Te(e, t, n, o, "updated") } }; function Te(e, t, n, o, r) { let s; switch (e.tagName) { case "SELECT": s = he; break; case "TEXTAREA": s = fe; break; default: switch (n.props && n.props.type) { case "checkbox": s = me; break; case "radio": s = ge; break; default: s = fe } }const a = s[r]; a && a(e, t, n, o) } exports.vModelDynamic = Ce; const _e = ["ctrl", "shift", "alt", "meta"], Se = { stop: e => e.stopPropagation(), prevent: e => e.preventDefault(), self: e => e.target !== e.currentTarget, ctrl: e => !e.ctrlKey, shift: e => !e.shiftKey, alt: e => !e.altKey, meta: e => !e.metaKey, left: e => "button" in e && 0 !== e.button, middle: e => "button" in e && 1 !== e.button, right: e => "button" in e && 2 !== e.button, exact: (e, t) => _e.some(n => e[`${n}Key`] && !t.includes(n)) }, Ee = (e, t) => (n, ...o) => { for (let e = 0; e < t.length; e++) { const o = Se[t[e]]; if (o && o(n, t)) return } return e(n, ...o) }; exports.withModifiers = Ee; const Ae = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, we = (e, t) => o => { if (!("key" in o)) return; const r = (0, n.hyphenate)(o.key); return t.some(e => e === r || Ae[e] === r) ? e(o) : void 0 }; exports.withKeys = we; const Me = { beforeMount(e, { value: t }, { transition: n }) { e._vod = "none" === e.style.display ? "" : e.style.display, n && t ? n.beforeEnter(e) : ke(e, t) }, mounted(e, { value: t }, { transition: n }) { n && t && n.enter(e) }, updated(e, { value: t, oldValue: n }, { transition: o }) { !t != !n && (o ? t ? (o.beforeEnter(e), ke(e, !0), o.enter(e)) : o.leave(e, () => { ke(e, !1) }) : ke(e, t)) }, beforeUnmount(e, { value: t }) { ke(e, t) } }; function ke(e, t) { e.style.display = t ? e._vod : "none" } exports.vShow = Me; const Ne = (0, n.extend)({ patchProp: P, forcePatchProp: L }, i); let Le, Pe = !1; function $e() { return Le || (Le = (0, t.createRenderer)(Ne)) } function Oe() { return Le = Pe ? Le : (0, t.createHydrationRenderer)(Ne), Pe = !0, Le } const Be = (...e) => { $e().render(...e) }; exports.render = Be; const Fe = (...e) => { Oe().hydrate(...e) }; exports.hydrate = Fe; const He = (...e) => { const t = $e().createApp(...e); const { mount: o } = t; return t.mount = (e => { const r = Re(e); if (!r) return; const s = t._component; (0, n.isFunction)(s) || s.render || s.template || (s.template = r.innerHTML), r.innerHTML = ""; const a = o(r); return r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", ""), a }), t }; exports.createApp = He; const Ve = (...e) => { const t = Oe().createApp(...e); const { mount: n } = t; return t.mount = (e => { const t = Re(e); if (t) return n(t, !0) }), t }; function Ie(e) { Object.defineProperty(e.config, "isNativeTag", { value: e => (0, n.isHTMLTag)(e) || (0, n.isSVGTag)(e), writable: !1 }) } function Re(e) { if ((0, n.isString)(e)) { const t = document.querySelector(e); return t } return e } exports.createSSRApp = Ve;
    }, { "@vue/runtime-core": "gmz5", "@vue/shared": "tWCa" }], "J4YF": [function (require, module, exports) {
        "use strict"; function t(t) { return a(t) || i(t) || s(t) || e() } function e() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function s(t, e) { if (t) { if ("string" == typeof t) return r(t, e); var s = Object.prototype.toString.call(t).slice(8, -1); return "Object" === s && t.constructor && (s = t.constructor.name), "Map" === s || "Set" === s ? Array.from(t) : "Arguments" === s || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s) ? r(t, e) : void 0 } } function i(t) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t) } function a(t) { if (Array.isArray(t)) return r(t) } function r(t, e) { (null == e || e > t.length) && (e = t.length); for (var s = 0, i = new Array(e); s < e; s++)i[s] = t[s]; return i } function n(t, e, s) { return (n = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, s) { var i = o(t, e); if (i) { var a = Object.getOwnPropertyDescriptor(i, e); return a.get ? a.get.call(s) : a.value } })(t, e, s || t) } function o(t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = f(t));); return t } function h(t) { return (h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) } function l(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && p(t, e) } function p(t, e) { return (p = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t })(t, e) } function c(t) { var e = m(); return function () { var s, i = f(t); if (e) { var a = f(this).constructor; s = Reflect.construct(i, arguments, a) } else s = i.apply(this, arguments); return u(this, s) } } function u(t, e) { return !e || "object" !== h(e) && "function" != typeof e ? d(t) : e } function d(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t } function m() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function () { })), !0 } catch (t) { return !1 } } function f(t) { return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) } function y(t, e) { for (var s = 0; s < e.length; s++) { var i = e[s]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function v(t, e, s) { return e && y(t.prototype, e), s && y(t, s), t } function x(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(exports, "__esModule", { value: !0 }); var P = !0, k = !0, g = !0, b = !0, T = !0, w = !0, A = function t(e) { var s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; x(this, t), this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e, this.keyword = s.keyword, this.beforeExpr = !!s.beforeExpr, this.startsExpr = !!s.startsExpr, this.rightAssociative = !!s.rightAssociative, this.isLoop = !!s.isLoop, this.isAssign = !!s.isAssign, this.prefix = !!s.prefix, this.postfix = !!s.postfix, this.binop = null != s.binop ? s.binop : null, this.updateContext = null }, E = new Map; function S(t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; e.keyword = t; var s = new A(t, e); return E.set(t, s), s } function C(t, e) { return new A(t, { beforeExpr: P, binop: e }) } var N = { num: new A("num", { startsExpr: k }), bigint: new A("bigint", { startsExpr: k }), decimal: new A("decimal", { startsExpr: k }), regexp: new A("regexp", { startsExpr: k }), string: new A("string", { startsExpr: k }), name: new A("name", { startsExpr: k }), eof: new A("eof"), bracketL: new A("[", { beforeExpr: P, startsExpr: k }), bracketHashL: new A("#[", { beforeExpr: P, startsExpr: k }), bracketBarL: new A("[|", { beforeExpr: P, startsExpr: k }), bracketR: new A("]"), bracketBarR: new A("|]"), braceL: new A("{", { beforeExpr: P, startsExpr: k }), braceBarL: new A("{|", { beforeExpr: P, startsExpr: k }), braceHashL: new A("#{", { beforeExpr: P, startsExpr: k }), braceR: new A("}"), braceBarR: new A("|}"), parenL: new A("(", { beforeExpr: P, startsExpr: k }), parenR: new A(")"), comma: new A(",", { beforeExpr: P }), semi: new A(";", { beforeExpr: P }), colon: new A(":", { beforeExpr: P }), doubleColon: new A("::", { beforeExpr: P }), dot: new A("."), question: new A("?", { beforeExpr: P }), questionDot: new A("?."), arrow: new A("=>", { beforeExpr: P }), template: new A("template"), ellipsis: new A("...", { beforeExpr: P }), backQuote: new A("`", { startsExpr: k }), dollarBraceL: new A("${", { beforeExpr: P, startsExpr: k }), at: new A("@"), hash: new A("#", { startsExpr: k }), interpreterDirective: new A("#!..."), eq: new A("=", { beforeExpr: P, isAssign: b }), assign: new A("_=", { beforeExpr: P, isAssign: b }), incDec: new A("++/--", { prefix: T, postfix: w, startsExpr: k }), bang: new A("!", { beforeExpr: P, prefix: T, startsExpr: k }), tilde: new A("~", { beforeExpr: P, prefix: T, startsExpr: k }), pipeline: C("|>", 0), nullishCoalescing: C("??", 1), logicalOR: C("||", 1), logicalAND: C("&&", 2), bitwiseOR: C("|", 3), bitwiseXOR: C("^", 4), bitwiseAND: C("&", 5), equality: C("==/!=/===/!==", 6), relational: C("</>/<=/>=", 7), bitShift: C("<</>>/>>>", 8), plusMin: new A("+/-", { beforeExpr: P, binop: 9, prefix: T, startsExpr: k }), modulo: new A("%", { beforeExpr: P, binop: 10, startsExpr: k }), star: new A("*", { binop: 10 }), slash: C("/", 10), exponent: new A("**", { beforeExpr: P, binop: 11, rightAssociative: !0 }), _break: S("break"), _case: S("case", { beforeExpr: P }), _catch: S("catch"), _continue: S("continue"), _debugger: S("debugger"), _default: S("default", { beforeExpr: P }), _do: S("do", { isLoop: g, beforeExpr: P }), _else: S("else", { beforeExpr: P }), _finally: S("finally"), _for: S("for", { isLoop: g }), _function: S("function", { startsExpr: k }), _if: S("if"), _return: S("return", { beforeExpr: P }), _switch: S("switch"), _throw: S("throw", { beforeExpr: P, prefix: T, startsExpr: k }), _try: S("try"), _var: S("var"), _const: S("const"), _while: S("while", { isLoop: g }), _with: S("with"), _new: S("new", { beforeExpr: P, startsExpr: k }), _this: S("this", { startsExpr: k }), _super: S("super", { startsExpr: k }), _class: S("class", { startsExpr: k }), _extends: S("extends", { beforeExpr: P }), _export: S("export"), _import: S("import", { startsExpr: k }), _null: S("null", { startsExpr: k }), _true: S("true", { startsExpr: k }), _false: S("false", { startsExpr: k }), _in: S("in", { beforeExpr: P, binop: 7 }), _instanceof: S("instanceof", { beforeExpr: P, binop: 7 }), _typeof: S("typeof", { beforeExpr: P, prefix: T, startsExpr: k }), _void: S("void", { beforeExpr: P, prefix: T, startsExpr: k }), _delete: S("delete", { beforeExpr: P, prefix: T, startsExpr: k }) }, I = 0, L = 1, D = 2, M = 4, R = 8, O = 16, F = 32, B = 64, _ = 128, j = L | D | _, U = 1, q = 2, V = 4, z = 8, H = 16, K = 64, W = 128, J = 256, X = 512, G = 1024, Q = U | q | z | W, Y = 0 | U | z | 0, $ = 0 | U | V | 0, Z = 0 | U | H | 0, tt = 0 | q | W, et = 0 | q, st = U | q | z | J, it = 0 | G, at = 0 | K, rt = 0 | U | K, nt = st | X, ot = 0 | G, ht = 4, lt = 2, pt = 1, ct = lt | pt, ut = lt | ht, dt = pt | ht, mt = lt, ft = pt, yt = 0, vt = /\r\n?|[\n\u2028\u2029]/, xt = new RegExp(vt.source, "g"); function Pt(t) { switch (t) { case 10: case 13: case 8232: case 8233: return !0; default: return !1 } } var kt = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g; function gt(t) { switch (t) { case 9: case 11: case 12: case 32: case 160: case 5760: case 8192: case 8193: case 8194: case 8195: case 8196: case 8197: case 8198: case 8199: case 8200: case 8201: case 8202: case 8239: case 8287: case 12288: case 65279: return !0; default: return !1 } } var bt = function t(e, s) { x(this, t), this.line = void 0, this.column = void 0, this.line = e, this.column = s }, Tt = function t(e, s) { x(this, t), this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e, this.end = s }; function wt(t, e) { var s, i = 1, a = 0; for (xt.lastIndex = 0; (s = xt.exec(t)) && s.index < e;)i++, a = xt.lastIndex; return new bt(i, e - a) } var At = function () { function t() { x(this, t), this.options = void 0, this.inModule = void 0, this.scope = void 0, this.classScope = void 0, this.prodParam = void 0, this.plugins = void 0, this.filename = void 0, this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1, this.state = void 0, this.input = void 0, this.length = void 0 } return v(t, [{ key: "hasPlugin", value: function (t) { return this.plugins.has(t) } }, { key: "getPluginOption", value: function (t, e) { if (this.hasPlugin(t)) return this.plugins.get(t)[e] } }]), t }(); function Et(t) { return t[t.length - 1] } var St = function (t) { l(s, At); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "addComment", value: function (t) { this.filename && (t.loc.filename = this.filename), this.state.trailingComments.push(t), this.state.leadingComments.push(t) } }, { key: "adjustCommentsAfterTrailingComma", value: function (t, e, s) { if (0 !== this.state.leadingComments.length) { for (var i = null, a = e.length; null === i && a > 0;)i = e[--a]; if (null !== i) { for (var r = 0; r < this.state.leadingComments.length; r++)this.state.leadingComments[r].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(r, 1), r--); for (var n = [], o = 0; o < this.state.leadingComments.length; o++) { var h = this.state.leadingComments[o]; h.end < t.end ? (n.push(h), s || (this.state.leadingComments.splice(o, 1), o--)) : (void 0 === t.trailingComments && (t.trailingComments = []), t.trailingComments.push(h)) } s && (this.state.leadingComments = []), n.length > 0 ? i.trailingComments = n : void 0 !== i.trailingComments && (i.trailingComments = []) } } } }, { key: "processComment", value: function (t) { if (!("Program" === t.type && t.body.length > 0)) { var e, s, i, a, r, n = this.state.commentStack; if (this.state.trailingComments.length > 0) this.state.trailingComments[0].start >= t.end ? (i = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0; else if (n.length > 0) { var o = Et(n); o.trailingComments && o.trailingComments[0].start >= t.end && (i = o.trailingComments, delete o.trailingComments) } for (n.length > 0 && Et(n).start >= t.start && (e = n.pop()); n.length > 0 && Et(n).start >= t.start;)s = n.pop(); if (!s && e && (s = e), e) switch (t.type) { case "ObjectExpression": this.adjustCommentsAfterTrailingComma(t, t.properties); break; case "ObjectPattern": this.adjustCommentsAfterTrailingComma(t, t.properties, !0); break; case "CallExpression": this.adjustCommentsAfterTrailingComma(t, t.arguments); break; case "ArrayExpression": this.adjustCommentsAfterTrailingComma(t, t.elements); break; case "ArrayPattern": this.adjustCommentsAfterTrailingComma(t, t.elements, !0) } else this.state.commentPreviousNode && ("ImportSpecifier" === this.state.commentPreviousNode.type && "ImportSpecifier" !== t.type || "ExportSpecifier" === this.state.commentPreviousNode.type && "ExportSpecifier" !== t.type) && this.adjustCommentsAfterTrailingComma(t, [this.state.commentPreviousNode]); if (s) { if (s.leadingComments) if (s !== t && s.leadingComments.length > 0 && Et(s.leadingComments).end <= t.start) t.leadingComments = s.leadingComments, delete s.leadingComments; else for (a = s.leadingComments.length - 2; a >= 0; --a)if (s.leadingComments[a].end <= t.start) { t.leadingComments = s.leadingComments.splice(0, a + 1); break } } else if (this.state.leadingComments.length > 0) if (Et(this.state.leadingComments).end <= t.start) { if (this.state.commentPreviousNode) for (r = 0; r < this.state.leadingComments.length; r++)this.state.leadingComments[r].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(r, 1), r--); this.state.leadingComments.length > 0 && (t.leadingComments = this.state.leadingComments, this.state.leadingComments = []) } else { for (a = 0; a < this.state.leadingComments.length && !(this.state.leadingComments[a].end > t.start); a++); var h = this.state.leadingComments.slice(0, a); h.length && (t.leadingComments = h), 0 === (i = this.state.leadingComments.slice(a)).length && (i = null) } if (this.state.commentPreviousNode = t, i) if (i.length && i[0].start >= t.start && Et(i).end <= t.end) t.innerComments = i; else { var l = i.findIndex(function (e) { return e.end >= t.end }); l > 0 ? (t.innerComments = i.slice(0, l), t.trailingComments = i.slice(l)) : t.trailingComments = i } n.push(t) } } }]), s }(), Ct = Object.freeze({ AccessorIsGenerator: "A %0ter cannot be a generator", ArgumentsInClass: "'arguments' is only allowed in functions and class methods", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function", AwaitExpressionFormalParameter: "await is not allowed in async function parameters", AwaitNotInAsyncFunction: "Can not use keyword 'await' outside an async function", BadGetterArity: "getter must not have any formal parameters", BadSetterArity: "setter must have exactly one formal parameter", BadSetterRestParameter: "setter function argument must not be a rest parameter", ConstructorClassField: "Classes may not have a field named 'constructor'", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'", ConstructorIsAccessor: "Class constructor may not be an accessor", ConstructorIsAsync: "Constructor can't be an async function", ConstructorIsGenerator: "Constructor can't be a generator", DeclarationMissingInitializer: "%0 require an initialization value", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon", DecoratorStaticBlock: "Decorators can't be used with a static block", DeletePrivateField: "Deleting a private field is not allowed", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property", DuplicateRegExpFlags: "Duplicate regular expression flag", DuplicateStaticBlock: "Duplicate static block in the same class", ElementAfterRest: "Rest element must be last element", EscapedCharNotAnIdentifier: "Invalid Unicode escape", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { %0 as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'", ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block", IllegalBreakContinue: "Unsyntactic %0", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list", IllegalReturn: "'return' outside of function", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments", ImportCallArity: "import() requires exactly %0", ImportCallNotNewExpression: "Cannot use new with import(...)", ImportCallSpreadArgument: "... is not allowed in import()", ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'", ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'", InvalidBigIntLiteral: "Invalid BigIntLiteral", InvalidCodePoint: "Code point out of bounds", InvalidDecimal: "Invalid decimal", InvalidDigit: "Expected number in radix %0", InvalidEscapeSequence: "Bad character escape sequence", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template", InvalidEscapedReservedWord: "Escape sequence in keyword %0", InvalidIdentifier: "Invalid identifier %0", InvalidLhs: "Invalid left-hand side in %0", InvalidLhsBinding: "Binding invalid left-hand side in %0", InvalidNumber: "Invalid number", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'", InvalidOrUnexpectedToken: "Unexpected character '%0'", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern", InvalidPrivateFieldResolution: "Private name #%0 is not defined", InvalidPropertyBindingPattern: "Binding member expression", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions", InvalidRestAssignmentPattern: "Invalid rest operator's argument", LabelRedeclaration: "Label '%0' is already declared", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'", MalformedRegExpFlags: "Invalid regular expression flag", MissingClassName: "A class name is required", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'", ModuleExportUndefined: "Export '%0' is not defined", MultipleDefaultsInSwitch: "Multiple default clauses", NewlineAfterThrow: "Illegal newline after throw", NoCatchOrFinally: "Missing catch or finally clause", NumberIdentifier: "Identifier directly after number", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences", ObsoleteAwaitStar: "await* has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "constructors in/after an Optional Chain are not allowed", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain", ParamDupe: "Argument name clash", PatternHasAccessor: "Object pattern can't contain getter or setter", PatternHasMethod: "Object pattern can't contain methods", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding", PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.", PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`)", PrivateNameRedeclaration: "Duplicate private name #%0", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'", RecordNoProto: "'__proto__' is not allowed in Record expressions", RestTrailingComma: "Unexpected trailing comma after rest element", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement", StaticPrototype: "Classes may not have static property named prototype", StrictDelete: "Deleting local variable in strict mode", StrictEvalArguments: "Assigning to '%0' in strict mode", StrictEvalArgumentsBinding: "Binding '%0' in strict mode", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode", StrictWith: "'with' in strict mode", SuperNotAllowed: "super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super", TrailingDecorator: "Decorators must be attached to a class element", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal', UnexpectedDigitAfterHash: "Unexpected digit after hash token", UnexpectedImportExport: "'import' and 'export' may only appear at the top level", UnexpectedKeyword: "Unexpected keyword '%0'", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context", UnexpectedNewTarget: "new.target can only be used in functions", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'", UnexpectedSuper: "super is only allowed in object methods and classes", UnexpectedToken: "Unexpected token '%0'", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "import can only be used in import() or import.meta", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties", UnsupportedSuper: "super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])", UnterminatedComment: "Unterminated comment", UnterminatedRegExp: "Unterminated regular expression", UnterminatedString: "Unterminated string constant", UnterminatedTemplate: "Unterminated template", VarRedeclaration: "Identifier '%0' has already been declared", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator", YieldInParameter: "yield is not allowed in generator parameters", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0" }), Nt = function (t) { l(s, St); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "getLocationForPosition", value: function (t) { return t === this.state.start ? this.state.startLoc : t === this.state.lastTokStart ? this.state.lastTokStartLoc : t === this.state.end ? this.state.endLoc : t === this.state.lastTokEnd ? this.state.lastTokEndLoc : wt(this.input, t) } }, { key: "raise", value: function (t, e) { for (var s = arguments.length, i = new Array(s > 2 ? s - 2 : 0), a = 2; a < s; a++)i[a - 2] = arguments[a]; return this.raiseWithData.apply(this, [t, void 0, e].concat(i)) } }, { key: "raiseWithData", value: function (t, e, s) { for (var i = arguments.length, a = new Array(i > 3 ? i - 3 : 0), r = 3; r < i; r++)a[r - 3] = arguments[r]; var n = this.getLocationForPosition(t), o = s.replace(/%(\d+)/g, function (t, e) { return a[e] }) + " (".concat(n.line, ":").concat(n.column, ")"); return this._raise(Object.assign({ loc: n, pos: t }, e), o) } }, { key: "_raise", value: function (t, e) { var s = new SyntaxError(e); if (Object.assign(s, t), this.options.errorRecovery) return this.isLookahead || this.state.errors.push(s), s; throw s } }]), s }(); function It(t) { return null != t && "Property" === t.type && "init" === t.kind && !1 === t.method } var Lt = function (t) { return function (e) { l(i, t); var s = c(i); function i() { return x(this, i), s.apply(this, arguments) } return v(i, [{ key: "estreeParseRegExpLiteral", value: function (t) { var { pattern: e, flags: s } = t, i = null; try { i = new RegExp(e, s) } catch (r) { } var a = this.estreeParseLiteral(i); return a.regex = { pattern: e, flags: s }, a } }, { key: "estreeParseBigIntLiteral", value: function (t) { var e = "undefined" != typeof BigInt ? BigInt(t) : null, s = this.estreeParseLiteral(e); return s.bigint = String(s.value || t), s } }, { key: "estreeParseDecimalLiteral", value: function (t) { var e = this.estreeParseLiteral(null); return e.decimal = String(e.value || t), e } }, { key: "estreeParseLiteral", value: function (t) { return this.parseLiteral(t, "Literal") } }, { key: "directiveToStmt", value: function (t) { var e = t.value, s = this.startNodeAt(t.start, t.loc.start), i = this.startNodeAt(e.start, e.loc.start); return i.value = e.value, i.raw = e.extra.raw, s.expression = this.finishNodeAt(i, "Literal", e.end, e.loc.end), s.directive = e.extra.raw.slice(1, -1), this.finishNodeAt(s, "ExpressionStatement", t.end, t.loc.end) } }, { key: "initFunction", value: function (t, e) { n(f(i.prototype), "initFunction", this).call(this, t, e), t.expression = !1 } }, { key: "checkDeclaration", value: function (t) { It(t) ? this.checkDeclaration(t.value) : n(f(i.prototype), "checkDeclaration", this).call(this, t) } }, { key: "getObjectOrClassMethodParams", value: function (t) { return t.value.params } }, { key: "checkLVal", value: function (t) { var e = this, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : at, a = arguments.length > 2 ? arguments[2] : void 0, r = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 ? arguments[4] : void 0; switch (t.type) { case "ObjectPattern": t.properties.forEach(function (t) { e.checkLVal("Property" === t.type ? t.value : t, s, a, "object destructuring pattern", o) }); break; default: n(f(i.prototype), "checkLVal", this).call(this, t, s, a, r, o) } } }, { key: "checkProto", value: function (t, e, s, a) { t.method || n(f(i.prototype), "checkProto", this).call(this, t, e, s, a) } }, { key: "isValidDirective", value: function (t) { var e; return "ExpressionStatement" === t.type && "Literal" === t.expression.type && "string" == typeof t.expression.value && !(null == (e = t.expression.extra) ? void 0 : e.parenthesized) } }, { key: "stmtToDirective", value: function (t) { var e = n(f(i.prototype), "stmtToDirective", this).call(this, t), s = t.expression.value; return e.value.value = s, e } }, { key: "parseBlockBody", value: function (t, e, s, a) { var r = this; n(f(i.prototype), "parseBlockBody", this).call(this, t, e, s, a); var o = t.directives.map(function (t) { return r.directiveToStmt(t) }); t.body = o.concat(t.body), delete t.directives } }, { key: "pushClassMethod", value: function (t, e, s, i, a, r) { this.parseMethod(e, s, i, a, r, "ClassMethod", !0), e.typeParameters && (e.value.typeParameters = e.typeParameters, delete e.typeParameters), t.body.push(e) } }, { key: "parseExprAtom", value: function (t) { switch (this.state.type) { case N.num: case N.string: return this.estreeParseLiteral(this.state.value); case N.regexp: return this.estreeParseRegExpLiteral(this.state.value); case N.bigint: return this.estreeParseBigIntLiteral(this.state.value); case N.decimal: return this.estreeParseDecimalLiteral(this.state.value); case N._null: return this.estreeParseLiteral(null); case N._true: return this.estreeParseLiteral(!0); case N._false: return this.estreeParseLiteral(!1); default: return n(f(i.prototype), "parseExprAtom", this).call(this, t) } } }, { key: "parseLiteral", value: function (t, e, s, a) { var r = n(f(i.prototype), "parseLiteral", this).call(this, t, e, s, a); return r.raw = r.extra.raw, delete r.extra, r } }, { key: "parseFunctionBody", value: function (t, e) { var s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; n(f(i.prototype), "parseFunctionBody", this).call(this, t, e, s), t.expression = "BlockStatement" !== t.body.type } }, { key: "parseMethod", value: function (t, e, s, a, r, o) { var h = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], l = this.startNode(); return l.kind = t.kind, (l = n(f(i.prototype), "parseMethod", this).call(this, l, e, s, a, r, o, h)).type = "FunctionExpression", delete l.kind, t.value = l, o = "ClassMethod" === o ? "MethodDefinition" : o, this.finishNode(t, o) } }, { key: "parseObjectMethod", value: function (t, e, s, a, r) { var o = n(f(i.prototype), "parseObjectMethod", this).call(this, t, e, s, a, r); return o && (o.type = "Property", "method" === o.kind && (o.kind = "init"), o.shorthand = !1), o } }, { key: "parseObjectProperty", value: function (t, e, s, a, r) { var o = n(f(i.prototype), "parseObjectProperty", this).call(this, t, e, s, a, r); return o && (o.kind = "init", o.type = "Property"), o } }, { key: "toAssignable", value: function (t) { return It(t) ? (this.toAssignable(t.value), t) : n(f(i.prototype), "toAssignable", this).call(this, t) } }, { key: "toAssignableObjectExpressionProp", value: function (t, e) { if ("get" === t.kind || "set" === t.kind) throw this.raise(t.key.start, Ct.PatternHasAccessor); if (t.method) throw this.raise(t.key.start, Ct.PatternHasMethod); n(f(i.prototype), "toAssignableObjectExpressionProp", this).call(this, t, e) } }, { key: "finishCallExpression", value: function (t, e) { return n(f(i.prototype), "finishCallExpression", this).call(this, t, e), "Import" === t.callee.type && (t.type = "ImportExpression", t.source = t.arguments[0], delete t.arguments, delete t.callee), t } }, { key: "toReferencedListDeep", value: function (t, e) { t && n(f(i.prototype), "toReferencedListDeep", this).call(this, t, e) } }, { key: "parseExport", value: function (t) { switch (n(f(i.prototype), "parseExport", this).call(this, t), t.type) { case "ExportAllDeclaration": t.exported = null; break; case "ExportNamedDeclaration": 1 === t.specifiers.length && "ExportNamespaceSpecifier" === t.specifiers[0].type && (t.type = "ExportAllDeclaration", t.exported = t.specifiers[0].exported, delete t.specifiers) }return t } }, { key: "parseSubscript", value: function (t, e, s, a, r) { var o = n(f(i.prototype), "parseSubscript", this).call(this, t, e, s, a, r); if (r.optionalChainMember) { if ("OptionalMemberExpression" !== o.type && "OptionalCallExpression" !== o.type || (o.type = o.type.substring(8)), r.stop) { var h = this.startNodeAtNode(o); return h.expression = o, this.finishNode(h, "ChainExpression") } } else "MemberExpression" !== o.type && "CallExpression" !== o.type || (o.optional = !1); return o } }]), i }() }, Dt = function t(e, s, i, a) { x(this, t), this.token = void 0, this.isExpr = void 0, this.preserveSpace = void 0, this.override = void 0, this.token = e, this.isExpr = !!s, this.preserveSpace = !!i, this.override = a }, Mt = { braceStatement: new Dt("{", !1), braceExpression: new Dt("{", !0), recordExpression: new Dt("#{", !0), templateQuasi: new Dt("${", !1), parenStatement: new Dt("(", !1), parenExpression: new Dt("(", !0), template: new Dt("`", !0, !0, function (t) { return t.readTmplToken() }), functionExpression: new Dt("function", !0), functionStatement: new Dt("function", !1) }; N.parenR.updateContext = N.braceR.updateContext = function () { if (1 !== this.state.context.length) { var t = this.state.context.pop(); t === Mt.braceStatement && "function" === this.curContext().token && (t = this.state.context.pop()), this.state.exprAllowed = !t.isExpr } else this.state.exprAllowed = !0 }, N.name.updateContext = function (t) { var e = !1; t !== N.dot && ("of" === this.state.value && !this.state.exprAllowed && t !== N._function && t !== N._class || "yield" === this.state.value && this.prodParam.hasYield) && (e = !0), this.state.exprAllowed = e, this.state.isIterator && (this.state.isIterator = !1) }, N.braceL.updateContext = function (t) { this.state.context.push(this.braceIsBlock(t) ? Mt.braceStatement : Mt.braceExpression), this.state.exprAllowed = !0 }, N.dollarBraceL.updateContext = function () { this.state.context.push(Mt.templateQuasi), this.state.exprAllowed = !0 }, N.parenL.updateContext = function (t) { var e = t === N._if || t === N._for || t === N._with || t === N._while; this.state.context.push(e ? Mt.parenStatement : Mt.parenExpression), this.state.exprAllowed = !0 }, N.incDec.updateContext = function () { }, N._function.updateContext = N._class.updateContext = function (t) { !t.beforeExpr || t === N.semi || t === N._else || t === N._return && this.hasPrecedingLineBreak() || (t === N.colon || t === N.braceL) && this.curContext() === Mt.b_stat ? this.state.context.push(Mt.functionStatement) : this.state.context.push(Mt.functionExpression), this.state.exprAllowed = !1 }, N.backQuote.updateContext = function () { this.curContext() === Mt.template ? this.state.context.pop() : this.state.context.push(Mt.template), this.state.exprAllowed = !1 }, N.braceHashL.updateContext = function () { this.state.context.push(Mt.recordExpression), this.state.exprAllowed = !0 }; var Rt = "---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------", Ot = "----------------------------------------------------------------------------------------------------------------------------------------------------", Ft = new RegExp("[" + Rt + "]"), Bt = new RegExp("[" + Rt + Ot + "]"); Rt = Ot = null; var _t = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], jt = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239]; function Ut(t, e) { for (var s = 65536, i = 0, a = e.length; i < a; i += 2) { if ((s += e[i]) > t) return !1; if ((s += e[i + 1]) >= t) return !0 } return !1 } function qt(t) { return t < 65 ? 36 === t : t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && Ft.test(String.fromCharCode(t)) : Ut(t, _t))) } function Vt(t) { return t < 48 ? 36 === t : t < 58 || !(t < 65) && (t <= 90 || (t < 97 ? 95 === t : t <= 122 || (t <= 65535 ? t >= 170 && Bt.test(String.fromCharCode(t)) : Ut(t, _t) || Ut(t, jt)))) } var zt = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Ht = new Set(zt.keyword), Kt = new Set(zt.strict), Wt = new Set(zt.strictBind); function Jt(t, e) { return e && "await" === t || "enum" === t } function Xt(t, e) { return Jt(t, e) || Kt.has(t) } function Gt(t) { return Wt.has(t) } function Qt(t, e) { return Xt(t, e) || Gt(t) } function Yt(t) { return Ht.has(t) } var $t = /^in(stanceof)?$/; function Zt(t, e) { return 64 === t && 64 === e } var te = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), ee = Object.freeze({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module", AssignReservedType: "Cannot overwrite reserved type %0", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions", InexactVariance: "Explicit inexact syntax cannot have variance", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`", NestedFlowComment: "Cannot have a flow comment inside another flow comment", OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.", SpreadVariance: "Spread properties cannot have variance", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object", UnexpectedReservedType: "Unexpected reserved type %0", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint"', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module", UnterminatedFlowComment: "Unterminated flow-comment" }); function se(t) { return "DeclareExportAllDeclaration" === t.type || "DeclareExportDeclaration" === t.type && (!t.declaration || "TypeAlias" !== t.declaration.type && "InterfaceDeclaration" !== t.declaration.type) } function ie(t) { return "type" === t.importKind || "typeof" === t.importKind } function ae(t) { return (t.type === N.name || !!t.type.keyword) && "from" !== t.value } var re = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }; function ne(t, e) { for (var s = [], i = [], a = 0; a < t.length; a++)(e(t[a], a, t) ? s : i).push(t[a]); return [s, i] } var oe = /\*?\s*@((?:no)?flow)\b/, he = function (e) { return function (s) { l(a, e); var i = c(a); function a(t, e) { var s; return x(this, a), (s = i.call(this, t, e)).flowPragma = void 0, s.flowPragma = void 0, s } return v(a, [{ key: "shouldParseTypes", value: function () { return this.getPluginOption("flow", "all") || "flow" === this.flowPragma } }, { key: "shouldParseEnums", value: function () { return !!this.getPluginOption("flow", "enums") } }, { key: "finishToken", value: function (t, e) { return t !== N.string && t !== N.semi && t !== N.interpreterDirective && void 0 === this.flowPragma && (this.flowPragma = null), n(f(a.prototype), "finishToken", this).call(this, t, e) } }, { key: "addComment", value: function (t) { if (void 0 === this.flowPragma) { var e = oe.exec(t.value); if (e) if ("flow" === e[1]) this.flowPragma = "flow"; else { if ("noflow" !== e[1]) throw new Error("Unexpected flow pragma"); this.flowPragma = "noflow" } else; } return n(f(a.prototype), "addComment", this).call(this, t) } }, { key: "flowParseTypeInitialiser", value: function (t) { var e = this.state.inType; this.state.inType = !0, this.expect(t || N.colon); var s = this.flowParseType(); return this.state.inType = e, s } }, { key: "flowParsePredicate", value: function () { var t = this.startNode(), e = this.state.startLoc, s = this.state.start; this.expect(N.modulo); var i = this.state.startLoc; return this.expectContextual("checks"), e.line === i.line && e.column === i.column - 1 || this.raise(s, ee.UnexpectedSpaceBetweenModuloChecks), this.eat(N.parenL) ? (t.value = this.parseExpression(), this.expect(N.parenR), this.finishNode(t, "DeclaredPredicate")) : this.finishNode(t, "InferredPredicate") } }, { key: "flowParseTypeAndPredicateInitialiser", value: function () { var t = this.state.inType; this.state.inType = !0, this.expect(N.colon); var e = null, s = null; return this.match(N.modulo) ? (this.state.inType = t, s = this.flowParsePredicate()) : (e = this.flowParseType(), this.state.inType = t, this.match(N.modulo) && (s = this.flowParsePredicate())), [e, s] } }, { key: "flowParseDeclareClass", value: function (t) { return this.next(), this.flowParseInterfaceish(t, !0), this.finishNode(t, "DeclareClass") } }, { key: "flowParseDeclareFunction", value: function (t) { this.next(); var e = t.id = this.parseIdentifier(), s = this.startNode(), i = this.startNode(); this.isRelational("<") ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(N.parenL); var a = this.flowParseFunctionTypeParams(); return s.params = a.params, s.rest = a.rest, this.expect(N.parenR), [s.returnType, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation"), e.typeAnnotation = this.finishNode(i, "TypeAnnotation"), this.resetEndLocation(e), this.semicolon(), this.finishNode(t, "DeclareFunction") } }, { key: "flowParseDeclare", value: function (t, e) { if (this.match(N._class)) return this.flowParseDeclareClass(t); if (this.match(N._function)) return this.flowParseDeclareFunction(t); if (this.match(N._var)) return this.flowParseDeclareVariable(t); if (this.eatContextual("module")) return this.match(N.dot) ? this.flowParseDeclareModuleExports(t) : (e && this.raise(this.state.lastTokStart, ee.NestedDeclareModule), this.flowParseDeclareModule(t)); if (this.isContextual("type")) return this.flowParseDeclareTypeAlias(t); if (this.isContextual("opaque")) return this.flowParseDeclareOpaqueType(t); if (this.isContextual("interface")) return this.flowParseDeclareInterface(t); if (this.match(N._export)) return this.flowParseDeclareExportDeclaration(t, e); throw this.unexpected() } }, { key: "flowParseDeclareVariable", value: function (t) { return this.next(), t.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(t.id.name, $, t.id.start), this.semicolon(), this.finishNode(t, "DeclareVariable") } }, { key: "flowParseDeclareModule", value: function (t) { var e = this; this.scope.enter(I), this.match(N.string) ? t.id = this.parseExprAtom() : t.id = this.parseIdentifier(); var s = t.body = this.startNode(), i = s.body = []; for (this.expect(N.braceL); !this.match(N.braceR);) { var a = this.startNode(); this.match(N._import) ? (this.next(), this.isContextual("type") || this.match(N._typeof) || this.raise(this.state.lastTokStart, ee.InvalidNonTypeImportInDeclareModule), this.parseImport(a)) : (this.expectContextual("declare", ee.UnsupportedStatementInDeclareModule), a = this.flowParseDeclare(a, !0)), i.push(a) } this.scope.exit(), this.expect(N.braceR), this.finishNode(s, "BlockStatement"); var r = null, n = !1; return i.forEach(function (t) { se(t) ? ("CommonJS" === r && e.raise(t.start, ee.AmbiguousDeclareModuleKind), r = "ES") : "DeclareModuleExports" === t.type && (n && e.raise(t.start, ee.DuplicateDeclareModuleExports), "ES" === r && e.raise(t.start, ee.AmbiguousDeclareModuleKind), r = "CommonJS", n = !0) }), t.kind = r || "CommonJS", this.finishNode(t, "DeclareModule") } }, { key: "flowParseDeclareExportDeclaration", value: function (t, e) { if (this.expect(N._export), this.eat(N._default)) return this.match(N._function) || this.match(N._class) ? t.declaration = this.flowParseDeclare(this.startNode()) : (t.declaration = this.flowParseType(), this.semicolon()), t.default = !0, this.finishNode(t, "DeclareExportDeclaration"); if (this.match(N._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !e) { var s = this.state.value, i = re[s]; throw this.raise(this.state.start, ee.UnsupportedDeclareExportKind, s, i) } if (this.match(N._var) || this.match(N._function) || this.match(N._class) || this.isContextual("opaque")) return t.declaration = this.flowParseDeclare(this.startNode()), t.default = !1, this.finishNode(t, "DeclareExportDeclaration"); if (this.match(N.star) || this.match(N.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) return "ExportNamedDeclaration" === (t = this.parseExport(t)).type && (t.type = "ExportDeclaration", t.default = !1, delete t.exportKind), t.type = "Declare" + t.type, t; throw this.unexpected() } }, { key: "flowParseDeclareModuleExports", value: function (t) { return this.next(), this.expectContextual("exports"), t.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(t, "DeclareModuleExports") } }, { key: "flowParseDeclareTypeAlias", value: function (t) { return this.next(), this.flowParseTypeAlias(t), t.type = "DeclareTypeAlias", t } }, { key: "flowParseDeclareOpaqueType", value: function (t) { return this.next(), this.flowParseOpaqueType(t, !0), t.type = "DeclareOpaqueType", t } }, { key: "flowParseDeclareInterface", value: function (t) { return this.next(), this.flowParseInterfaceish(t), this.finishNode(t, "DeclareInterface") } }, { key: "flowParseInterfaceish", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (t.id = this.flowParseRestrictedIdentifier(!e, !0), this.scope.declareName(t.id.name, e ? Z : Y, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.extends = [], t.implements = [], t.mixins = [], this.eat(N._extends)) do { t.extends.push(this.flowParseInterfaceExtends()) } while (!e && this.eat(N.comma)); if (this.isContextual("mixins")) { this.next(); do { t.mixins.push(this.flowParseInterfaceExtends()) } while (this.eat(N.comma)) } if (this.isContextual("implements")) { this.next(); do { t.implements.push(this.flowParseInterfaceExtends()) } while (this.eat(N.comma)) } t.body = this.flowParseObjectType({ allowStatic: e, allowExact: !1, allowSpread: !1, allowProto: e, allowInexact: !1 }) } }, { key: "flowParseInterfaceExtends", value: function () { var t = this.startNode(); return t.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterInstantiation() : t.typeParameters = null, this.finishNode(t, "InterfaceExtends") } }, { key: "flowParseInterface", value: function (t) { return this.flowParseInterfaceish(t), this.finishNode(t, "InterfaceDeclaration") } }, { key: "checkNotUnderscore", value: function (t) { "_" === t && this.raise(this.state.start, ee.UnexpectedReservedUnderscore) } }, { key: "checkReservedType", value: function (t, e, s) { te.has(t) && this.raise(e, s ? ee.AssignReservedType : ee.UnexpectedReservedType, t) } }, { key: "flowParseRestrictedIdentifier", value: function (t, e) { return this.checkReservedType(this.state.value, this.state.start, e), this.parseIdentifier(t) } }, { key: "flowParseTypeAlias", value: function (t) { return t.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(t.id.name, Y, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.right = this.flowParseTypeInitialiser(N.eq), this.semicolon(), this.finishNode(t, "TypeAlias") } }, { key: "flowParseOpaqueType", value: function (t, e) { return this.expectContextual("type"), t.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(t.id.name, Y, t.id.start), this.isRelational("<") ? t.typeParameters = this.flowParseTypeParameterDeclaration() : t.typeParameters = null, t.supertype = null, this.match(N.colon) && (t.supertype = this.flowParseTypeInitialiser(N.colon)), t.impltype = null, e || (t.impltype = this.flowParseTypeInitialiser(N.eq)), this.semicolon(), this.finishNode(t, "OpaqueType") } }, { key: "flowParseTypeParameter", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this.state.start, s = this.startNode(), i = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier(); return s.name = a.name, s.variance = i, s.bound = a.typeAnnotation, this.match(N.eq) ? (this.eat(N.eq), s.default = this.flowParseType()) : t && this.raise(e, ee.MissingTypeParamDefault), this.finishNode(s, "TypeParameter") } }, { key: "flowParseTypeParameterDeclaration", value: function () { var t = this.state.inType, e = this.startNode(); e.params = [], this.state.inType = !0, this.isRelational("<") || this.match(N.jsxTagStart) ? this.next() : this.unexpected(); var s = !1; do { var i = this.flowParseTypeParameter(s); e.params.push(i), i.default && (s = !0), this.isRelational(">") || this.expect(N.comma) } while (!this.isRelational(">")); return this.expectRelational(">"), this.state.inType = t, this.finishNode(e, "TypeParameterDeclaration") } }, { key: "flowParseTypeParameterInstantiation", value: function () { var t = this.startNode(), e = this.state.inType; t.params = [], this.state.inType = !0, this.expectRelational("<"); var s = this.state.noAnonFunctionType; for (this.state.noAnonFunctionType = !1; !this.isRelational(">");)t.params.push(this.flowParseType()), this.isRelational(">") || this.expect(N.comma); return this.state.noAnonFunctionType = s, this.expectRelational(">"), this.state.inType = e, this.finishNode(t, "TypeParameterInstantiation") } }, { key: "flowParseTypeParameterInstantiationCallOrNew", value: function () { var t = this.startNode(), e = this.state.inType; for (t.params = [], this.state.inType = !0, this.expectRelational("<"); !this.isRelational(">");)t.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(N.comma); return this.expectRelational(">"), this.state.inType = e, this.finishNode(t, "TypeParameterInstantiation") } }, { key: "flowParseInterfaceType", value: function () { var t = this.startNode(); if (this.expectContextual("interface"), t.extends = [], this.eat(N._extends)) do { t.extends.push(this.flowParseInterfaceExtends()) } while (this.eat(N.comma)); return t.body = this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !1, allowProto: !1, allowInexact: !1 }), this.finishNode(t, "InterfaceTypeAnnotation") } }, { key: "flowParseObjectPropertyKey", value: function () { return this.match(N.num) || this.match(N.string) ? this.parseExprAtom() : this.parseIdentifier(!0) } }, { key: "flowParseObjectTypeIndexer", value: function (t, e, s) { return t.static = e, this.lookahead().type === N.colon ? (t.id = this.flowParseObjectPropertyKey(), t.key = this.flowParseTypeInitialiser()) : (t.id = null, t.key = this.flowParseType()), this.expect(N.bracketR), t.value = this.flowParseTypeInitialiser(), t.variance = s, this.finishNode(t, "ObjectTypeIndexer") } }, { key: "flowParseObjectTypeInternalSlot", value: function (t, e) { return t.static = e, t.id = this.flowParseObjectPropertyKey(), this.expect(N.bracketR), this.expect(N.bracketR), this.isRelational("<") || this.match(N.parenL) ? (t.method = !0, t.optional = !1, t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start))) : (t.method = !1, this.eat(N.question) && (t.optional = !0), t.value = this.flowParseTypeInitialiser()), this.finishNode(t, "ObjectTypeInternalSlot") } }, { key: "flowParseObjectTypeMethodish", value: function (t) { for (t.params = [], t.rest = null, t.typeParameters = null, this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(N.parenL); !this.match(N.parenR) && !this.match(N.ellipsis);)t.params.push(this.flowParseFunctionTypeParam()), this.match(N.parenR) || this.expect(N.comma); return this.eat(N.ellipsis) && (t.rest = this.flowParseFunctionTypeParam()), this.expect(N.parenR), t.returnType = this.flowParseTypeInitialiser(), this.finishNode(t, "FunctionTypeAnnotation") } }, { key: "flowParseObjectTypeCallProperty", value: function (t, e) { var s = this.startNode(); return t.static = e, t.value = this.flowParseObjectTypeMethodish(s), this.finishNode(t, "ObjectTypeCallProperty") } }, { key: "flowParseObjectType", value: function (t) { var { allowStatic: e, allowExact: s, allowSpread: i, allowProto: a, allowInexact: r } = t, n = this.state.inType; this.state.inType = !0; var o, h, l = this.startNode(); l.callProperties = [], l.properties = [], l.indexers = [], l.internalSlots = []; var p = !1; for (s && this.match(N.braceBarL) ? (this.expect(N.braceBarL), o = N.braceBarR, h = !0) : (this.expect(N.braceL), o = N.braceR, h = !1), l.exact = h; !this.match(o);) { var c = !1, u = null, d = null, m = this.startNode(); if (a && this.isContextual("proto")) { var f = this.lookahead(); f.type !== N.colon && f.type !== N.question && (this.next(), u = this.state.start, e = !1) } if (e && this.isContextual("static")) { var y = this.lookahead(); y.type !== N.colon && y.type !== N.question && (this.next(), c = !0) } var v = this.flowParseVariance(); if (this.eat(N.bracketL)) null != u && this.unexpected(u), this.eat(N.bracketL) ? (v && this.unexpected(v.start), l.internalSlots.push(this.flowParseObjectTypeInternalSlot(m, c))) : l.indexers.push(this.flowParseObjectTypeIndexer(m, c, v)); else if (this.match(N.parenL) || this.isRelational("<")) null != u && this.unexpected(u), v && this.unexpected(v.start), l.callProperties.push(this.flowParseObjectTypeCallProperty(m, c)); else { var x = "init"; if (this.isContextual("get") || this.isContextual("set")) { var P = this.lookahead(); P.type !== N.name && P.type !== N.string && P.type !== N.num || (x = this.state.value, this.next()) } var k = this.flowParseObjectTypeProperty(m, c, u, v, x, i, null != r ? r : !h); null === k ? (p = !0, d = this.state.lastTokStart) : l.properties.push(k) } this.flowObjectTypeSemicolon(), !d || this.match(N.braceR) || this.match(N.braceBarR) || this.raise(d, ee.UnexpectedExplicitInexactInObject) } this.expect(o), i && (l.inexact = p); var g = this.finishNode(l, "ObjectTypeAnnotation"); return this.state.inType = n, g } }, { key: "flowParseObjectTypeProperty", value: function (t, e, s, i, a, r, n) { if (this.eat(N.ellipsis)) return this.match(N.comma) || this.match(N.semi) || this.match(N.braceR) || this.match(N.braceBarR) ? (r ? n || this.raise(this.state.lastTokStart, ee.InexactInsideExact) : this.raise(this.state.lastTokStart, ee.InexactInsideNonObject), i && this.raise(i.start, ee.InexactVariance), null) : (r || this.raise(this.state.lastTokStart, ee.UnexpectedSpreadType), null != s && this.unexpected(s), i && this.raise(i.start, ee.SpreadVariance), t.argument = this.flowParseType(), this.finishNode(t, "ObjectTypeSpreadProperty")); t.key = this.flowParseObjectPropertyKey(), t.static = e, t.proto = null != s, t.kind = a; var o = !1; return this.isRelational("<") || this.match(N.parenL) ? (t.method = !0, null != s && this.unexpected(s), i && this.unexpected(i.start), t.value = this.flowParseObjectTypeMethodish(this.startNodeAt(t.start, t.loc.start)), "get" !== a && "set" !== a || this.flowCheckGetterSetterParams(t)) : ("init" !== a && this.unexpected(), t.method = !1, this.eat(N.question) && (o = !0), t.value = this.flowParseTypeInitialiser(), t.variance = i), t.optional = o, this.finishNode(t, "ObjectTypeProperty") } }, { key: "flowCheckGetterSetterParams", value: function (t) { var e = "get" === t.kind ? 0 : 1, s = t.start; t.value.params.length + (t.value.rest ? 1 : 0) !== e && ("get" === t.kind ? this.raise(s, Ct.BadGetterArity) : this.raise(s, Ct.BadSetterArity)), "set" === t.kind && t.value.rest && this.raise(s, Ct.BadSetterRestParameter) } }, { key: "flowObjectTypeSemicolon", value: function () { this.eat(N.semi) || this.eat(N.comma) || this.match(N.braceR) || this.match(N.braceBarR) || this.unexpected() } }, { key: "flowParseQualifiedTypeIdentifier", value: function (t, e, s) { t = t || this.state.start, e = e || this.state.startLoc; for (var i = s || this.flowParseRestrictedIdentifier(!0); this.eat(N.dot);) { var a = this.startNodeAt(t, e); a.qualification = i, a.id = this.flowParseRestrictedIdentifier(!0), i = this.finishNode(a, "QualifiedTypeIdentifier") } return i } }, { key: "flowParseGenericType", value: function (t, e, s) { var i = this.startNodeAt(t, e); return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(t, e, s), this.isRelational("<") && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation") } }, { key: "flowParseTypeofType", value: function () { var t = this.startNode(); return this.expect(N._typeof), t.argument = this.flowParsePrimaryType(), this.finishNode(t, "TypeofTypeAnnotation") } }, { key: "flowParseTupleType", value: function () { var t = this.startNode(); for (t.types = [], this.expect(N.bracketL); this.state.pos < this.length && !this.match(N.bracketR) && (t.types.push(this.flowParseType()), !this.match(N.bracketR));)this.expect(N.comma); return this.expect(N.bracketR), this.finishNode(t, "TupleTypeAnnotation") } }, { key: "flowParseFunctionTypeParam", value: function () { var t = null, e = !1, s = null, i = this.startNode(), a = this.lookahead(); return a.type === N.colon || a.type === N.question ? (t = this.parseIdentifier(), this.eat(N.question) && (e = !0), s = this.flowParseTypeInitialiser()) : s = this.flowParseType(), i.name = t, i.optional = e, i.typeAnnotation = s, this.finishNode(i, "FunctionTypeParam") } }, { key: "reinterpretTypeAsFunctionTypeParam", value: function (t) { var e = this.startNodeAt(t.start, t.loc.start); return e.name = null, e.optional = !1, e.typeAnnotation = t, this.finishNode(e, "FunctionTypeParam") } }, { key: "flowParseFunctionTypeParams", value: function () { for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e = null; !this.match(N.parenR) && !this.match(N.ellipsis);)t.push(this.flowParseFunctionTypeParam()), this.match(N.parenR) || this.expect(N.comma); return this.eat(N.ellipsis) && (e = this.flowParseFunctionTypeParam()), { params: t, rest: e } } }, { key: "flowIdentToTypeAnnotation", value: function (t, e, s, i) { switch (i.name) { case "any": return this.finishNode(s, "AnyTypeAnnotation"); case "bool": case "boolean": return this.finishNode(s, "BooleanTypeAnnotation"); case "mixed": return this.finishNode(s, "MixedTypeAnnotation"); case "empty": return this.finishNode(s, "EmptyTypeAnnotation"); case "number": return this.finishNode(s, "NumberTypeAnnotation"); case "string": return this.finishNode(s, "StringTypeAnnotation"); case "symbol": return this.finishNode(s, "SymbolTypeAnnotation"); default: return this.checkNotUnderscore(i.name), this.flowParseGenericType(t, e, i) } } }, { key: "flowParsePrimaryType", value: function () { var t, e, s = this.state.start, i = this.state.startLoc, r = this.startNode(), o = !1, h = this.state.noAnonFunctionType; switch (this.state.type) { case N.name: return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(s, i, r, this.parseIdentifier()); case N.braceL: return this.flowParseObjectType({ allowStatic: !1, allowExact: !1, allowSpread: !0, allowProto: !1, allowInexact: !0 }); case N.braceBarL: return this.flowParseObjectType({ allowStatic: !1, allowExact: !0, allowSpread: !0, allowProto: !1, allowInexact: !1 }); case N.bracketL: return this.state.noAnonFunctionType = !1, e = this.flowParseTupleType(), this.state.noAnonFunctionType = h, e; case N.relational: if ("<" === this.state.value) return r.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(N.parenL), t = this.flowParseFunctionTypeParams(), r.params = t.params, r.rest = t.rest, this.expect(N.parenR), this.expect(N.arrow), r.returnType = this.flowParseType(), this.finishNode(r, "FunctionTypeAnnotation"); break; case N.parenL: if (this.next(), !this.match(N.parenR) && !this.match(N.ellipsis)) if (this.match(N.name)) { var l = this.lookahead().type; o = l !== N.question && l !== N.colon } else o = !0; if (o) { if (this.state.noAnonFunctionType = !1, e = this.flowParseType(), this.state.noAnonFunctionType = h, this.state.noAnonFunctionType || !(this.match(N.comma) || this.match(N.parenR) && this.lookahead().type === N.arrow)) return this.expect(N.parenR), e; this.eat(N.comma) } return t = e ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(e)]) : this.flowParseFunctionTypeParams(), r.params = t.params, r.rest = t.rest, this.expect(N.parenR), this.expect(N.arrow), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation"); case N.string: return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation"); case N._true: case N._false: return r.value = this.match(N._true), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation"); case N.plusMin: if ("-" === this.state.value) { if (this.next(), this.match(N.num)) return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", r.start, r.loc.start); if (this.match(N.bigint)) return this.parseLiteral(-this.state.value, "BigIntLiteralTypeAnnotation", r.start, r.loc.start); throw this.raise(this.state.start, ee.UnexpectedSubtractionOperand) } throw this.unexpected(); case N.num: return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation"); case N.bigint: return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation"); case N._void: return this.next(), this.finishNode(r, "VoidTypeAnnotation"); case N._null: return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation"); case N._this: return this.next(), this.finishNode(r, "ThisTypeAnnotation"); case N.star: return this.next(), this.finishNode(r, "ExistsTypeAnnotation"); default: if ("typeof" === this.state.type.keyword) return this.flowParseTypeofType(); if (this.state.type.keyword) { var p = this.state.type.label; return this.next(), n(f(a.prototype), "createIdentifier", this).call(this, r, p) } }throw this.unexpected() } }, { key: "flowParsePostfixType", value: function () { for (var t = this.state.start, e = this.state.startLoc, s = this.flowParsePrimaryType(); this.match(N.bracketL) && !this.canInsertSemicolon();) { var i = this.startNodeAt(t, e); i.elementType = s, this.expect(N.bracketL), this.expect(N.bracketR), s = this.finishNode(i, "ArrayTypeAnnotation") } return s } }, { key: "flowParsePrefixType", value: function () { var t = this.startNode(); return this.eat(N.question) ? (t.typeAnnotation = this.flowParsePrefixType(), this.finishNode(t, "NullableTypeAnnotation")) : this.flowParsePostfixType() } }, { key: "flowParseAnonFunctionWithoutParens", value: function () { var t = this.flowParsePrefixType(); if (!this.state.noAnonFunctionType && this.eat(N.arrow)) { var e = this.startNodeAt(t.start, t.loc.start); return e.params = [this.reinterpretTypeAsFunctionTypeParam(t)], e.rest = null, e.returnType = this.flowParseType(), e.typeParameters = null, this.finishNode(e, "FunctionTypeAnnotation") } return t } }, { key: "flowParseIntersectionType", value: function () { var t = this.startNode(); this.eat(N.bitwiseAND); var e = this.flowParseAnonFunctionWithoutParens(); for (t.types = [e]; this.eat(N.bitwiseAND);)t.types.push(this.flowParseAnonFunctionWithoutParens()); return 1 === t.types.length ? e : this.finishNode(t, "IntersectionTypeAnnotation") } }, { key: "flowParseUnionType", value: function () { var t = this.startNode(); this.eat(N.bitwiseOR); var e = this.flowParseIntersectionType(); for (t.types = [e]; this.eat(N.bitwiseOR);)t.types.push(this.flowParseIntersectionType()); return 1 === t.types.length ? e : this.finishNode(t, "UnionTypeAnnotation") } }, { key: "flowParseType", value: function () { var t = this.state.inType; this.state.inType = !0; var e = this.flowParseUnionType(); return this.state.inType = t, this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType, e } }, { key: "flowParseTypeOrImplicitInstantiation", value: function () { if (this.state.type === N.name && "_" === this.state.value) { var t = this.state.start, e = this.state.startLoc, s = this.parseIdentifier(); return this.flowParseGenericType(t, e, s) } return this.flowParseType() } }, { key: "flowParseTypeAnnotation", value: function () { var t = this.startNode(); return t.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(t, "TypeAnnotation") } }, { key: "flowParseTypeAnnotatableIdentifier", value: function (t) { var e = t ? this.parseIdentifier() : this.flowParseRestrictedIdentifier(); return this.match(N.colon) && (e.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e)), e } }, { key: "typeCastToParameter", value: function (t) { return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression } }, { key: "flowParseVariance", value: function () { var t = null; return this.match(N.plusMin) && (t = this.startNode(), "+" === this.state.value ? t.kind = "plus" : t.kind = "minus", this.next(), this.finishNode(t, "Variance")), t } }, { key: "parseFunctionBody", value: function (t, e) { var s = this, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; return e ? this.forwardNoArrowParamsConversionAt(t, function () { return n(f(a.prototype), "parseFunctionBody", s).call(s, t, !0, i) }) : n(f(a.prototype), "parseFunctionBody", this).call(this, t, !1, i) } }, { key: "parseFunctionBodyAndFinish", value: function (t, e) { var s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; if (this.match(N.colon)) { var i = this.startNode();[i.typeAnnotation, t.predicate] = this.flowParseTypeAndPredicateInitialiser(), t.returnType = i.typeAnnotation ? this.finishNode(i, "TypeAnnotation") : null } n(f(a.prototype), "parseFunctionBodyAndFinish", this).call(this, t, e, s) } }, { key: "parseStatement", value: function (t, e) { if (this.state.strict && this.match(N.name) && "interface" === this.state.value) { var s = this.startNode(); return this.next(), this.flowParseInterface(s) } if (this.shouldParseEnums() && this.isContextual("enum")) { var i = this.startNode(); return this.next(), this.flowParseEnumDeclaration(i) } var r = n(f(a.prototype), "parseStatement", this).call(this, t, e); return void 0 !== this.flowPragma || this.isValidDirective(r) || (this.flowPragma = null), r } }, { key: "parseExpressionStatement", value: function (t, e) { if ("Identifier" === e.type) if ("declare" === e.name) { if (this.match(N._class) || this.match(N.name) || this.match(N._function) || this.match(N._var) || this.match(N._export)) return this.flowParseDeclare(t) } else if (this.match(N.name)) { if ("interface" === e.name) return this.flowParseInterface(t); if ("type" === e.name) return this.flowParseTypeAlias(t); if ("opaque" === e.name) return this.flowParseOpaqueType(t, !1) } return n(f(a.prototype), "parseExpressionStatement", this).call(this, t, e) } }, { key: "shouldParseExportDeclaration", value: function () { return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || n(f(a.prototype), "shouldParseExportDeclaration", this).call(this) } }, { key: "isExportDefaultSpecifier", value: function () { return (!this.match(N.name) || !("type" === this.state.value || "interface" === this.state.value || "opaque" === this.state.value || this.shouldParseEnums() && "enum" === this.state.value)) && n(f(a.prototype), "isExportDefaultSpecifier", this).call(this) } }, { key: "parseExportDefaultExpression", value: function () { if (this.shouldParseEnums() && this.isContextual("enum")) { var t = this.startNode(); return this.next(), this.flowParseEnumDeclaration(t) } return n(f(a.prototype), "parseExportDefaultExpression", this).call(this) } }, { key: "parseConditional", value: function (e, s, i, r) { var o = this; if (!this.match(N.question)) return e; if (r) { var h = this.tryParse(function () { return n(f(a.prototype), "parseConditional", o).call(o, e, s, i) }); return h.node ? (h.error && (this.state = h.failState), h.node) : (r.start = h.error.pos || this.state.start, e) } this.expect(N.question); var l = this.state.clone(), p = this.state.noArrowAt, c = this.startNodeAt(s, i), { consequent: u, failed: d } = this.tryParseConditionalConsequent(), [m, y] = this.getArrowLikeExpressions(u); if (d || y.length > 0) { var v = t(p); if (y.length > 0) { this.state = l, this.state.noArrowAt = v; for (var x = 0; x < y.length; x++)v.push(y[x].start); ({ consequent: u, failed: d } = this.tryParseConditionalConsequent()), [m, y] = this.getArrowLikeExpressions(u) } d && m.length > 1 && this.raise(l.start, ee.AmbiguousConditionalArrow), d && 1 === m.length && (this.state = l, this.state.noArrowAt = v.concat(m[0].start), ({ consequent: u, failed: d } = this.tryParseConditionalConsequent())) } return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = p, this.expect(N.colon), c.test = e, c.consequent = u, c.alternate = this.forwardNoArrowParamsConversionAt(c, function () { return o.parseMaybeAssign(void 0, void 0, void 0) }), this.finishNode(c, "ConditionalExpression") } }, { key: "tryParseConditionalConsequent", value: function () { this.state.noArrowParamsConversionAt.push(this.state.start); var t = this.parseMaybeAssignAllowIn(), e = !this.match(N.colon); return this.state.noArrowParamsConversionAt.pop(), { consequent: t, failed: e } } }, { key: "getArrowLikeExpressions", value: function (t, e) { for (var s = this, i = [t], a = []; 0 !== i.length;) { var r = i.pop(); "ArrowFunctionExpression" === r.type ? (r.typeParameters || !r.returnType ? this.finishArrowValidation(r) : a.push(r), i.push(r.body)) : "ConditionalExpression" === r.type && (i.push(r.consequent), i.push(r.alternate)) } return e ? (a.forEach(function (t) { return s.finishArrowValidation(t) }), [a, []]) : ne(a, function (t) { return t.params.every(function (t) { return s.isAssignable(t, !0) }) }) } }, { key: "finishArrowValidation", value: function (t) { var e; this.toAssignableList(t.params, null == (e = t.extra) ? void 0 : e.trailingComma), this.scope.enter(D | M), n(f(a.prototype), "checkParams", this).call(this, t, !1, !0), this.scope.exit() } }, { key: "forwardNoArrowParamsConversionAt", value: function (t, e) { var s; return -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), s = e(), this.state.noArrowParamsConversionAt.pop()) : s = e(), s } }, { key: "parseParenItem", value: function (t, e, s) { if (t = n(f(a.prototype), "parseParenItem", this).call(this, t, e, s), this.eat(N.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(N.colon)) { var i = this.startNodeAt(e, s); return i.expression = t, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression") } return t } }, { key: "assertModuleNodeAllowed", value: function (t) { "ImportDeclaration" === t.type && ("type" === t.importKind || "typeof" === t.importKind) || "ExportNamedDeclaration" === t.type && "type" === t.exportKind || "ExportAllDeclaration" === t.type && "type" === t.exportKind || n(f(a.prototype), "assertModuleNodeAllowed", this).call(this, t) } }, { key: "parseExport", value: function (t) { var e = n(f(a.prototype), "parseExport", this).call(this, t); return "ExportNamedDeclaration" !== e.type && "ExportAllDeclaration" !== e.type || (e.exportKind = e.exportKind || "value"), e } }, { key: "parseExportDeclaration", value: function (t) { if (this.isContextual("type")) { t.exportKind = "type"; var e = this.startNode(); return this.next(), this.match(N.braceL) ? (t.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(t), null) : this.flowParseTypeAlias(e) } if (this.isContextual("opaque")) { t.exportKind = "type"; var s = this.startNode(); return this.next(), this.flowParseOpaqueType(s, !1) } if (this.isContextual("interface")) { t.exportKind = "type"; var i = this.startNode(); return this.next(), this.flowParseInterface(i) } if (this.shouldParseEnums() && this.isContextual("enum")) { t.exportKind = "value"; var r = this.startNode(); return this.next(), this.flowParseEnumDeclaration(r) } return n(f(a.prototype), "parseExportDeclaration", this).call(this, t) } }, { key: "eatExportStar", value: function (t) { return !!n(f(a.prototype), "eatExportStar", this).apply(this, arguments) || !(!this.isContextual("type") || this.lookahead().type !== N.star) && (t.exportKind = "type", this.next(), this.next(), !0) } }, { key: "maybeParseExportNamespaceSpecifier", value: function (t) { var e = this.state.start, s = n(f(a.prototype), "maybeParseExportNamespaceSpecifier", this).call(this, t); return s && "type" === t.exportKind && this.unexpected(e), s } }, { key: "parseClassId", value: function (t, e, s) { n(f(a.prototype), "parseClassId", this).call(this, t, e, s), this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()) } }, { key: "parseClassMember", value: function (t, e, s) { var i = this.state.start; if (this.isContextual("declare")) { if (this.parseClassMemberFromModifier(t, e)) return; e.declare = !0 } n(f(a.prototype), "parseClassMember", this).call(this, t, e, s), e.declare && ("ClassProperty" !== e.type && "ClassPrivateProperty" !== e.type ? this.raise(i, ee.DeclareClassElement) : e.value && this.raise(e.value.start, ee.DeclareClassFieldInitializer)) } }, { key: "getTokenFromCode", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1); return 123 === t && 124 === e ? this.finishOp(N.braceBarL, 2) : !this.state.inType || 62 !== t && 60 !== t ? this.state.inType && 63 === t ? this.finishOp(N.question, 1) : Zt(t, e) ? (this.state.isIterator = !0, n(f(a.prototype), "readWord", this).call(this)) : n(f(a.prototype), "getTokenFromCode", this).call(this, t) : this.finishOp(N.relational, 1) } }, { key: "isAssignable", value: function (t, e) { var s = this; switch (t.type) { case "Identifier": case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": return !0; case "ObjectExpression": var i = t.properties.length - 1; return t.properties.every(function (t, e) { return "ObjectMethod" !== t.type && (e === i || "SpreadElement" === t.type) && s.isAssignable(t) }); case "ObjectProperty": return this.isAssignable(t.value); case "SpreadElement": return this.isAssignable(t.argument); case "ArrayExpression": return t.elements.every(function (t) { return s.isAssignable(t) }); case "AssignmentExpression": return "=" === t.operator; case "ParenthesizedExpression": case "TypeCastExpression": return this.isAssignable(t.expression); case "MemberExpression": case "OptionalMemberExpression": return !e; default: return !1 } } }, { key: "toAssignable", value: function (t) { return "TypeCastExpression" === t.type ? n(f(a.prototype), "toAssignable", this).call(this, this.typeCastToParameter(t)) : n(f(a.prototype), "toAssignable", this).call(this, t) } }, { key: "toAssignableList", value: function (t, e) { for (var s = 0; s < t.length; s++) { var i = t[s]; "TypeCastExpression" === (null == i ? void 0 : i.type) && (t[s] = this.typeCastToParameter(i)) } return n(f(a.prototype), "toAssignableList", this).call(this, t, e) } }, { key: "toReferencedList", value: function (t, e) { for (var s = 0; s < t.length; s++) { var i, a = t[s]; a && "TypeCastExpression" === a.type && !(null == (i = a.extra) ? void 0 : i.parenthesized) && (t.length > 1 || !e) && this.raise(a.typeAnnotation.start, ee.TypeCastInPattern) } return t } }, { key: "checkLVal", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : at, s = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0; if ("TypeCastExpression" !== t.type) return n(f(a.prototype), "checkLVal", this).call(this, t, e, s, i) } }, { key: "parseClassProperty", value: function (t) { return this.match(N.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), n(f(a.prototype), "parseClassProperty", this).call(this, t) } }, { key: "parseClassPrivateProperty", value: function (t) { return this.match(N.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), n(f(a.prototype), "parseClassPrivateProperty", this).call(this, t) } }, { key: "isClassMethod", value: function () { return this.isRelational("<") || n(f(a.prototype), "isClassMethod", this).call(this) } }, { key: "isClassProperty", value: function () { return this.match(N.colon) || n(f(a.prototype), "isClassProperty", this).call(this) } }, { key: "isNonstaticConstructor", value: function (t) { return !this.match(N.colon) && n(f(a.prototype), "isNonstaticConstructor", this).call(this, t) } }, { key: "pushClassMethod", value: function (t, e, s, i, r, o) { e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational("<") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), n(f(a.prototype), "pushClassMethod", this).call(this, t, e, s, i, r, o) } }, { key: "pushClassPrivateMethod", value: function (t, e, s, i) { e.variance && this.unexpected(e.variance.start), delete e.variance, this.isRelational("<") && (e.typeParameters = this.flowParseTypeParameterDeclaration()), n(f(a.prototype), "pushClassPrivateMethod", this).call(this, t, e, s, i) } }, { key: "parseClassSuper", value: function (t) { if (n(f(a.prototype), "parseClassSuper", this).call(this, t), t.superClass && this.isRelational("<") && (t.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) { this.next(); var e = t.implements = []; do { var s = this.startNode(); s.id = this.flowParseRestrictedIdentifier(!0), this.isRelational("<") ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.typeParameters = null, e.push(this.finishNode(s, "ClassImplements")) } while (this.eat(N.comma)) } } }, { key: "parsePropertyName", value: function (t, e) { var s = this.flowParseVariance(), i = n(f(a.prototype), "parsePropertyName", this).call(this, t, e); return t.variance = s, i } }, { key: "parseObjPropValue", value: function (t, e, s, i, r, o, h, l) { var p; t.variance && this.unexpected(t.variance.start), delete t.variance, this.isRelational("<") && !h && (p = this.flowParseTypeParameterDeclaration(), this.match(N.parenL) || this.unexpected()), n(f(a.prototype), "parseObjPropValue", this).call(this, t, e, s, i, r, o, h, l), p && ((t.value || t).typeParameters = p) } }, { key: "parseAssignableListItemTypes", value: function (t) { return this.eat(N.question) && ("Identifier" !== t.type && this.raise(t.start, ee.OptionalBindingPattern), t.optional = !0), this.match(N.colon) && (t.typeAnnotation = this.flowParseTypeAnnotation()), this.resetEndLocation(t), t } }, { key: "parseMaybeDefault", value: function (t, e, s) { var i = n(f(a.prototype), "parseMaybeDefault", this).call(this, t, e, s); return "AssignmentPattern" === i.type && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(i.typeAnnotation.start, ee.TypeBeforeInitializer), i } }, { key: "shouldParseDefaultImport", value: function (t) { return ie(t) ? ae(this.state) : n(f(a.prototype), "shouldParseDefaultImport", this).call(this, t) } }, { key: "parseImportSpecifierLocal", value: function (t, e, s, i) { e.local = ie(t) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), this.checkLVal(e.local, Y, void 0, i), t.specifiers.push(this.finishNode(e, s)) } }, { key: "maybeParseDefaultImportSpecifier", value: function (t) { t.importKind = "value"; var e = null; if (this.match(N._typeof) ? e = "typeof" : this.isContextual("type") && (e = "type"), e) { var s = this.lookahead(); "type" === e && s.type === N.star && this.unexpected(s.start), (ae(s) || s.type === N.braceL || s.type === N.star) && (this.next(), t.importKind = e) } return n(f(a.prototype), "maybeParseDefaultImportSpecifier", this).call(this, t) } }, { key: "parseImportSpecifier", value: function (t) { var e = this.startNode(), s = this.state.start, i = this.parseIdentifier(!0), a = null; "type" === i.name ? a = "type" : "typeof" === i.name && (a = "typeof"); var r = !1; if (this.isContextual("as") && !this.isLookaheadContextual("as")) { var n = this.parseIdentifier(!0); null === a || this.match(N.name) || this.state.type.keyword ? (e.imported = i, e.importKind = null, e.local = this.parseIdentifier()) : (e.imported = n, e.importKind = a, e.local = n.__clone()) } else null !== a && (this.match(N.name) || this.state.type.keyword) ? (e.imported = this.parseIdentifier(!0), e.importKind = a, this.eatContextual("as") ? e.local = this.parseIdentifier() : (r = !0, e.local = e.imported.__clone())) : (r = !0, e.imported = i, e.importKind = null, e.local = e.imported.__clone()); var o = ie(t), h = ie(e); o && h && this.raise(s, ee.ImportTypeShorthandOnlyInPureImport), (o || h) && this.checkReservedType(e.local.name, e.local.start, !0), !r || o || h || this.checkReservedWord(e.local.name, e.start, !0, !0), this.checkLVal(e.local, Y, void 0, "import specifier"), t.specifiers.push(this.finishNode(e, "ImportSpecifier")) } }, { key: "parseFunctionParams", value: function (t, e) { var s = t.kind; "get" !== s && "set" !== s && this.isRelational("<") && (t.typeParameters = this.flowParseTypeParameterDeclaration()), n(f(a.prototype), "parseFunctionParams", this).call(this, t, e) } }, { key: "parseVarId", value: function (t, e) { n(f(a.prototype), "parseVarId", this).call(this, t, e), this.match(N.colon) && (t.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t.id)) } }, { key: "parseAsyncArrowFromCallExpression", value: function (t, e) { if (this.match(N.colon)) { var s = this.state.noAnonFunctionType; this.state.noAnonFunctionType = !0, t.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = s } return n(f(a.prototype), "parseAsyncArrowFromCallExpression", this).call(this, t, e) } }, { key: "shouldParseAsyncArrow", value: function () { return this.match(N.colon) || n(f(a.prototype), "shouldParseAsyncArrow", this).call(this) } }, { key: "parseMaybeAssign", value: function (t, e, s) { var i, r, o = this, h = null; if (this.hasPlugin("jsx") && (this.match(N.jsxTagStart) || this.isRelational("<"))) { if (h = this.state.clone(), !(r = this.tryParse(function () { return n(f(a.prototype), "parseMaybeAssign", o).call(o, t, e, s) }, h)).error) return r.node; var { context: l } = this.state; l[l.length - 1] === Mt.j_oTag ? l.length -= 2 : l[l.length - 1] === Mt.j_expr && (l.length -= 1) } if ((null == (i = r) ? void 0 : i.error) || this.isRelational("<")) { var p, c, u; h = h || this.state.clone(); var d = this.tryParse(function (i) { var r; u = o.flowParseTypeParameterDeclaration(); var h = o.forwardNoArrowParamsConversionAt(u, function () { var i = n(f(a.prototype), "parseMaybeAssign", o).call(o, t, e, s); return o.resetStartLocationFromNode(i, u), i }); "ArrowFunctionExpression" !== h.type && (null == (r = h.extra) ? void 0 : r.parenthesized) && i(); var l = o.maybeUnwrapTypeCastExpression(h); return l.typeParameters = u, o.resetStartLocationFromNode(l, u), h }, h), m = null; if (d.node && "ArrowFunctionExpression" === this.maybeUnwrapTypeCastExpression(d.node).type) { if (!d.error && !d.aborted) return d.node.async && this.raise(u.start, ee.UnexpectedTypeParameterBeforeAsyncArrowFunction), d.node; m = d.node } if (null == (p = r) ? void 0 : p.node) return this.state = r.failState, r.node; if (m) return this.state = d.failState, m; if (null == (c = r) ? void 0 : c.thrown) throw r.error; if (d.thrown) throw d.error; throw this.raise(u.start, ee.UnexpectedTokenAfterTypeParameter) } return n(f(a.prototype), "parseMaybeAssign", this).call(this, t, e, s) } }, { key: "parseArrow", value: function (t) { var e = this; if (this.match(N.colon)) { var s = this.tryParse(function () { var s = e.state.noAnonFunctionType; e.state.noAnonFunctionType = !0; var i = e.startNode(); return [i.typeAnnotation, t.predicate] = e.flowParseTypeAndPredicateInitialiser(), e.state.noAnonFunctionType = s, e.canInsertSemicolon() && e.unexpected(), e.match(N.arrow) || e.unexpected(), i }); if (s.thrown) return null; s.error && (this.state = s.failState), t.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null } return n(f(a.prototype), "parseArrow", this).call(this, t) } }, { key: "shouldParseArrow", value: function () { return this.match(N.colon) || n(f(a.prototype), "shouldParseArrow", this).call(this) } }, { key: "setArrowFunctionParameters", value: function (t, e) { -1 !== this.state.noArrowParamsConversionAt.indexOf(t.start) ? t.params = e : n(f(a.prototype), "setArrowFunctionParameters", this).call(this, t, e) } }, { key: "checkParams", value: function (t, e, s) { if (!s || -1 === this.state.noArrowParamsConversionAt.indexOf(t.start)) return n(f(a.prototype), "checkParams", this).apply(this, arguments) } }, { key: "parseParenAndDistinguishExpression", value: function (t) { return n(f(a.prototype), "parseParenAndDistinguishExpression", this).call(this, t && -1 === this.state.noArrowAt.indexOf(this.state.start)) } }, { key: "parseSubscripts", value: function (t, e, s, i) { var r = this; if ("Identifier" === t.type && "async" === t.name && -1 !== this.state.noArrowAt.indexOf(e)) { this.next(); var o = this.startNodeAt(e, s); o.callee = t, o.arguments = this.parseCallExpressionArguments(N.parenR, !1), t = this.finishNode(o, "CallExpression") } else if ("Identifier" === t.type && "async" === t.name && this.isRelational("<")) { var h = this.state.clone(), l = this.tryParse(function (t) { return r.parseAsyncArrowWithTypeParameters(e, s) || t() }, h); if (!l.error && !l.aborted) return l.node; var p = this.tryParse(function () { return n(f(a.prototype), "parseSubscripts", r).call(r, t, e, s, i) }, h); if (p.node && !p.error) return p.node; if (l.node) return this.state = l.failState, l.node; if (p.node) return this.state = p.failState, p.node; throw l.error || p.error } return n(f(a.prototype), "parseSubscripts", this).call(this, t, e, s, i) } }, { key: "parseSubscript", value: function (t, e, s, i, r) { var o = this; if (this.match(N.questionDot) && this.isLookaheadToken_lt()) { if (r.optionalChainMember = !0, i) return r.stop = !0, t; this.next(); var h = this.startNodeAt(e, s); return h.callee = t, h.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(N.parenL), h.arguments = this.parseCallExpressionArguments(N.parenR, !1), h.optional = !0, this.finishCallExpression(h, !0) } if (!i && this.shouldParseTypes() && this.isRelational("<")) { var l = this.startNodeAt(e, s); l.callee = t; var p = this.tryParse(function () { return l.typeArguments = o.flowParseTypeParameterInstantiationCallOrNew(), o.expect(N.parenL), l.arguments = o.parseCallExpressionArguments(N.parenR, !1), r.optionalChainMember && (l.optional = !1), o.finishCallExpression(l, r.optionalChainMember) }); if (p.node) return p.error && (this.state = p.failState), p.node } return n(f(a.prototype), "parseSubscript", this).call(this, t, e, s, i, r) } }, { key: "parseNewArguments", value: function (t) { var e = this, s = null; this.shouldParseTypes() && this.isRelational("<") && (s = this.tryParse(function () { return e.flowParseTypeParameterInstantiationCallOrNew() }).node), t.typeArguments = s, n(f(a.prototype), "parseNewArguments", this).call(this, t) } }, { key: "parseAsyncArrowWithTypeParameters", value: function (t, e) { var s = this.startNodeAt(t, e); if (this.parseFunctionParams(s), this.parseArrow(s)) return this.parseArrowExpression(s, void 0, !0) } }, { key: "readToken_mult_modulo", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1); if (42 === t && 47 === e && this.state.hasFlowComment) return this.state.hasFlowComment = !1, this.state.pos += 2, void this.nextToken(); n(f(a.prototype), "readToken_mult_modulo", this).call(this, t) } }, { key: "readToken_pipe_amp", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1); 124 !== t || 125 !== e ? n(f(a.prototype), "readToken_pipe_amp", this).call(this, t) : this.finishOp(N.braceBarR, 2) } }, { key: "parseTopLevel", value: function (t, e) { var s = n(f(a.prototype), "parseTopLevel", this).call(this, t, e); return this.state.hasFlowComment && this.raise(this.state.pos, ee.UnterminatedFlowComment), s } }, { key: "skipBlockComment", value: function () { if (this.hasPlugin("flowComments") && this.skipFlowComment()) return this.state.hasFlowComment && this.unexpected(null, ee.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = !0); if (this.state.hasFlowComment) { var t = this.input.indexOf("*-/", this.state.pos += 2); if (-1 === t) throw this.raise(this.state.pos - 2, Ct.UnterminatedComment); this.state.pos = t + 3 } else n(f(a.prototype), "skipBlockComment", this).call(this) } }, { key: "skipFlowComment", value: function () { for (var { pos: t } = this.state, e = 2; [32, 9].includes(this.input.charCodeAt(t + e));)e++; var s = this.input.charCodeAt(e + t), i = this.input.charCodeAt(e + t + 1); return 58 === s && 58 === i ? e + 2 : "flow-include" === this.input.slice(e + t, e + t + 12) ? e + 12 : 58 === s && 58 !== i && e } }, { key: "hasFlowCommentCompletion", value: function () { if (-1 === this.input.indexOf("*/", this.state.pos)) throw this.raise(this.state.pos, Ct.UnterminatedComment) } }, { key: "flowEnumErrorBooleanMemberNotInitialized", value: function (t, e) { var { enumName: s, memberName: i } = e; this.raise(t, ee.EnumBooleanMemberNotInitialized, i, s) } }, { key: "flowEnumErrorInvalidMemberName", value: function (t, e) { var { enumName: s, memberName: i } = e, a = i[0].toUpperCase() + i.slice(1); this.raise(t, ee.EnumInvalidMemberName, i, a, s) } }, { key: "flowEnumErrorDuplicateMemberName", value: function (t, e) { var { enumName: s, memberName: i } = e; this.raise(t, ee.EnumDuplicateMemberName, i, s) } }, { key: "flowEnumErrorInconsistentMemberValues", value: function (t, e) { var { enumName: s } = e; this.raise(t, ee.EnumInconsistentMemberValues, s) } }, { key: "flowEnumErrorInvalidExplicitType", value: function (t, e) { var { enumName: s, suppliedType: i } = e; return this.raise(t, null === i ? ee.EnumInvalidExplicitTypeUnknownSupplied : ee.EnumInvalidExplicitType, s, i) } }, { key: "flowEnumErrorInvalidMemberInitializer", value: function (t, e) { var { enumName: s, explicitType: i, memberName: a } = e, r = null; switch (i) { case "boolean": case "number": case "string": r = ee.EnumInvalidMemberInitializerPrimaryType; break; case "symbol": r = ee.EnumInvalidMemberInitializerSymbolType; break; default: r = ee.EnumInvalidMemberInitializerUnknownType }return this.raise(t, r, s, a, i) } }, { key: "flowEnumErrorNumberMemberNotInitialized", value: function (t, e) { var { enumName: s, memberName: i } = e; this.raise(t, ee.EnumNumberMemberNotInitialized, s, i) } }, { key: "flowEnumErrorStringMemberInconsistentlyInitailized", value: function (t, e) { var { enumName: s } = e; this.raise(t, ee.EnumStringMemberInconsistentlyInitailized, s) } }, { key: "flowEnumMemberInit", value: function () { var t = this, e = this.state.start, s = function () { return t.match(N.comma) || t.match(N.braceR) }; switch (this.state.type) { case N.num: var i = this.parseLiteral(this.state.value, "NumericLiteral"); return s() ? { type: "number", pos: i.start, value: i } : { type: "invalid", pos: e }; case N.string: var a = this.parseLiteral(this.state.value, "StringLiteral"); return s() ? { type: "string", pos: a.start, value: a } : { type: "invalid", pos: e }; case N._true: case N._false: var r = this.parseBooleanLiteral(); return s() ? { type: "boolean", pos: r.start, value: r } : { type: "invalid", pos: e }; default: return { type: "invalid", pos: e } } } }, { key: "flowEnumMemberRaw", value: function () { var t = this.state.start; return { id: this.parseIdentifier(!0), init: this.eat(N.eq) ? this.flowEnumMemberInit() : { type: "none", pos: t } } } }, { key: "flowEnumCheckExplicitTypeMismatch", value: function (t, e, s) { var { explicitType: i } = e; null !== i && i !== s && this.flowEnumErrorInvalidMemberInitializer(t, e) } }, { key: "flowEnumMembers", value: function (t) { for (var { enumName: e, explicitType: s } = t, i = new Set, a = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }; !this.match(N.braceR);) { var r = this.startNode(), { id: n, init: o } = this.flowEnumMemberRaw(), h = n.name; if ("" !== h) { /^[a-z]/.test(h) && this.flowEnumErrorInvalidMemberName(n.start, { enumName: e, memberName: h }), i.has(h) && this.flowEnumErrorDuplicateMemberName(n.start, { enumName: e, memberName: h }), i.add(h); var l = { enumName: e, explicitType: s, memberName: h }; switch (r.id = n, o.type) { case "boolean": this.flowEnumCheckExplicitTypeMismatch(o.pos, l, "boolean"), r.init = o.value, a.booleanMembers.push(this.finishNode(r, "EnumBooleanMember")); break; case "number": this.flowEnumCheckExplicitTypeMismatch(o.pos, l, "number"), r.init = o.value, a.numberMembers.push(this.finishNode(r, "EnumNumberMember")); break; case "string": this.flowEnumCheckExplicitTypeMismatch(o.pos, l, "string"), r.init = o.value, a.stringMembers.push(this.finishNode(r, "EnumStringMember")); break; case "invalid": throw this.flowEnumErrorInvalidMemberInitializer(o.pos, l); case "none": switch (s) { case "boolean": this.flowEnumErrorBooleanMemberNotInitialized(o.pos, l); break; case "number": this.flowEnumErrorNumberMemberNotInitialized(o.pos, l); break; default: a.defaultedMembers.push(this.finishNode(r, "EnumDefaultedMember")) } }this.match(N.braceR) || this.expect(N.comma) } } return a } }, { key: "flowEnumStringMembers", value: function (t, e, s) { var { enumName: i } = s; if (0 === t.length) return e; if (0 === e.length) return t; if (e.length > t.length) { for (var a = 0; a < t.length; a++) { var r = t[a]; this.flowEnumErrorStringMemberInconsistentlyInitailized(r.start, { enumName: i }) } return e } for (var n = 0; n < e.length; n++) { var o = e[n]; this.flowEnumErrorStringMemberInconsistentlyInitailized(o.start, { enumName: i }) } return t } }, { key: "flowEnumParseExplicitType", value: function (t) { var { enumName: e } = t; if (this.eatContextual("of")) { if (!this.match(N.name)) throw this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e, suppliedType: null }); var { value: s } = this.state; return this.next(), "boolean" !== s && "number" !== s && "string" !== s && "symbol" !== s && this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e, suppliedType: s }), s } return null } }, { key: "flowEnumBody", value: function (t, e) { var s = this, { enumName: i, nameLoc: a } = e, r = this.flowEnumParseExplicitType({ enumName: i }); this.expect(N.braceL); var n = this.flowEnumMembers({ enumName: i, explicitType: r }); switch (r) { case "boolean": return t.explicitType = !0, t.members = n.booleanMembers, this.expect(N.braceR), this.finishNode(t, "EnumBooleanBody"); case "number": return t.explicitType = !0, t.members = n.numberMembers, this.expect(N.braceR), this.finishNode(t, "EnumNumberBody"); case "string": return t.explicitType = !0, t.members = this.flowEnumStringMembers(n.stringMembers, n.defaultedMembers, { enumName: i }), this.expect(N.braceR), this.finishNode(t, "EnumStringBody"); case "symbol": return t.members = n.defaultedMembers, this.expect(N.braceR), this.finishNode(t, "EnumSymbolBody"); default: var o = function () { return t.members = [], s.expect(N.braceR), s.finishNode(t, "EnumStringBody") }; t.explicitType = !1; var h = n.booleanMembers.length, l = n.numberMembers.length, p = n.stringMembers.length, c = n.defaultedMembers.length; if (h || l || p || c) { if (h || l) { if (!l && !p && h >= c) { for (var u = 0, d = n.defaultedMembers; u < d.length; u++) { var m = d[u]; this.flowEnumErrorBooleanMemberNotInitialized(m.start, { enumName: i, memberName: m.id.name }) } return t.members = n.booleanMembers, this.expect(N.braceR), this.finishNode(t, "EnumBooleanBody") } if (!h && !p && l >= c) { for (var f = 0, y = n.defaultedMembers; f < y.length; f++) { var v = y[f]; this.flowEnumErrorNumberMemberNotInitialized(v.start, { enumName: i, memberName: v.id.name }) } return t.members = n.numberMembers, this.expect(N.braceR), this.finishNode(t, "EnumNumberBody") } return this.flowEnumErrorInconsistentMemberValues(a, { enumName: i }), o() } return t.members = this.flowEnumStringMembers(n.stringMembers, n.defaultedMembers, { enumName: i }), this.expect(N.braceR), this.finishNode(t, "EnumStringBody") } return o() } } }, { key: "flowParseEnumDeclaration", value: function (t) { var e = this.parseIdentifier(); return t.id = e, t.body = this.flowEnumBody(this.startNode(), { enumName: e.name, nameLoc: e.start }), this.finishNode(t, "EnumDeclaration") } }, { key: "updateContext", value: function (t) { this.match(N.name) && "of" === this.state.value && t === N.name && "interface" === this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) ? this.state.exprAllowed = !1 : n(f(a.prototype), "updateContext", this).call(this, t) } }, { key: "isLookaheadToken_lt", value: function () { var t = this.nextTokenStart(); if (60 === this.input.charCodeAt(t)) { var e = this.input.charCodeAt(t + 1); return 60 !== e && 61 !== e } return !1 } }, { key: "maybeUnwrapTypeCastExpression", value: function (t) { return "TypeCastExpression" === t.type ? t.expression : t } }]), a }() }, le = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "", iexcl: "", cent: "", pound: "", curren: "", yen: "", brvbar: "", sect: "", uml: "", copy: "", ordf: "", laquo: "", not: "", shy: "", reg: "", macr: "", deg: "", plusmn: "", sup2: "", sup3: "", acute: "", micro: "", para: "", middot: "", cedil: "", sup1: "", ordm: "", raquo: "", frac14: "", frac12: "", frac34: "", iquest: "", Agrave: "", Aacute: "", Acirc: "", Atilde: "", Auml: "", Aring: "", AElig: "", Ccedil: "", Egrave: "", Eacute: "", Ecirc: "", Euml: "", Igrave: "", Iacute: "", Icirc: "", Iuml: "", ETH: "", Ntilde: "", Ograve: "", Oacute: "", Ocirc: "", Otilde: "", Ouml: "", times: "", Oslash: "", Ugrave: "", Uacute: "", Ucirc: "", Uuml: "", Yacute: "", THORN: "", szlig: "", agrave: "", aacute: "", acirc: "", atilde: "", auml: "", aring: "", aelig: "", ccedil: "", egrave: "", eacute: "", ecirc: "", euml: "", igrave: "", iacute: "", icirc: "", iuml: "", eth: "", ntilde: "", ograve: "", oacute: "", ocirc: "", otilde: "", ouml: "", divide: "", oslash: "", ugrave: "", uacute: "", ucirc: "", uuml: "", yacute: "", thorn: "", yuml: "", OElig: "", oelig: "", Scaron: "", scaron: "", Yuml: "", fnof: "", circ: "", tilde: "", Alpha: "", Beta: "", Gamma: "", Delta: "", Epsilon: "", Zeta: "", Eta: "", Theta: "", Iota: "", Kappa: "", Lambda: "", Mu: "", Nu: "", Xi: "", Omicron: "", Pi: "", Rho: "", Sigma: "", Tau: "", Upsilon: "", Phi: "", Chi: "", Psi: "", Omega: "", alpha: "", beta: "", gamma: "", delta: "", epsilon: "", zeta: "", eta: "", theta: "", iota: "", kappa: "", lambda: "", mu: "", nu: "", xi: "", omicron: "", pi: "", rho: "", sigmaf: "", sigma: "", tau: "", upsilon: "", phi: "", chi: "", psi: "", omega: "", thetasym: "", upsih: "", piv: "", ensp: "", emsp: "", thinsp: "", zwnj: "", zwj: "", lrm: "", rlm: "", ndash: "", mdash: "", lsquo: "", rsquo: "", sbquo: "", ldquo: "", rdquo: "", bdquo: "", dagger: "", Dagger: "", bull: "", hellip: "", permil: "", prime: "", Prime: "", lsaquo: "", rsaquo: "", oline: "", frasl: "", euro: "", image: "", weierp: "", real: "", trade: "", alefsym: "", larr: "", uarr: "", rarr: "", darr: "", harr: "", crarr: "", lArr: "", uArr: "", rArr: "", dArr: "", hArr: "", forall: "", part: "", exist: "", empty: "", nabla: "", isin: "", notin: "", ni: "", prod: "", sum: "", minus: "", lowast: "", radic: "", prop: "", infin: "", ang: "", and: "", or: "", cap: "", cup: "", int: "", there4: "", sim: "", cong: "", asymp: "", ne: "", equiv: "", le: "", ge: "", sub: "", sup: "", nsub: "", sube: "", supe: "", oplus: "", otimes: "", perp: "", sdot: "", lceil: "", rceil: "", lfloor: "", rfloor: "", lang: "", rang: "", loz: "", spades: "", clubs: "", hearts: "", diams: "" }, pe = /^[\da-fA-F]+$/, ce = /^\d+$/, ue = Object.freeze({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text", UnterminatedJsxContent: "Unterminated JSX contents", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" }); function de(t) { return !!t && ("JSXOpeningFragment" === t.type || "JSXClosingFragment" === t.type) } function me(t) { if ("JSXIdentifier" === t.type) return t.name; if ("JSXNamespacedName" === t.type) return t.namespace.name + ":" + t.name.name; if ("JSXMemberExpression" === t.type) return me(t.object) + "." + me(t.property); throw new Error("Node had unexpected type: " + t.type) } Mt.j_oTag = new Dt("<tag", !1), Mt.j_cTag = new Dt("</tag", !1), Mt.j_expr = new Dt("<tag>...</tag>", !0, !0), N.jsxName = new A("jsxName"), N.jsxText = new A("jsxText", { beforeExpr: !0 }), N.jsxTagStart = new A("jsxTagStart", { startsExpr: !0 }), N.jsxTagEnd = new A("jsxTagEnd"), N.jsxTagStart.updateContext = function () { this.state.context.push(Mt.j_expr), this.state.context.push(Mt.j_oTag), this.state.exprAllowed = !1 }, N.jsxTagEnd.updateContext = function (t) { var e = this.state.context.pop(); e === Mt.j_oTag && t === N.slash || e === Mt.j_cTag ? (this.state.context.pop(), this.state.exprAllowed = this.curContext() === Mt.j_expr) : this.state.exprAllowed = !0 }; var fe = function (t) { return function (e) { l(i, t); var s = c(i); function i() { return x(this, i), s.apply(this, arguments) } return v(i, [{ key: "jsxReadToken", value: function () { for (var t = "", e = this.state.pos; ;) { if (this.state.pos >= this.length) throw this.raise(this.state.start, ue.UnterminatedJsxContent); var s = this.input.charCodeAt(this.state.pos); switch (s) { case 60: case 123: return this.state.pos === this.state.start ? 60 === s && this.state.exprAllowed ? (++this.state.pos, this.finishToken(N.jsxTagStart)) : n(f(i.prototype), "getTokenFromCode", this).call(this, s) : (t += this.input.slice(e, this.state.pos), this.finishToken(N.jsxText, t)); case 38: t += this.input.slice(e, this.state.pos), t += this.jsxReadEntity(), e = this.state.pos; break; default: Pt(s) ? (t += this.input.slice(e, this.state.pos), t += this.jsxReadNewLine(!0), e = this.state.pos) : ++this.state.pos } } } }, { key: "jsxReadNewLine", value: function (t) { var e, s = this.input.charCodeAt(this.state.pos); return ++this.state.pos, 13 === s && 10 === this.input.charCodeAt(this.state.pos) ? (++this.state.pos, e = t ? "\n" : "\r\n") : e = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, e } }, { key: "jsxReadString", value: function (t) { for (var e = "", s = ++this.state.pos; ;) { if (this.state.pos >= this.length) throw this.raise(this.state.start, Ct.UnterminatedString); var i = this.input.charCodeAt(this.state.pos); if (i === t) break; 38 === i ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos) : Pt(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos } return e += this.input.slice(s, this.state.pos++), this.finishToken(N.string, e) } }, { key: "jsxReadEntity", value: function () { for (var t, e = "", s = 0, i = this.input[this.state.pos], a = ++this.state.pos; this.state.pos < this.length && s++ < 10;) { if (";" === (i = this.input[this.state.pos++])) { "#" === e[0] ? "x" === e[1] ? (e = e.substr(2), pe.test(e) && (t = String.fromCodePoint(parseInt(e, 16)))) : (e = e.substr(1), ce.test(e) && (t = String.fromCodePoint(parseInt(e, 10)))) : t = le[e]; break } e += i } return t || (this.state.pos = a, "&") } }, { key: "jsxReadWord", value: function () { var t, e = this.state.pos; do { t = this.input.charCodeAt(++this.state.pos) } while (Vt(t) || 45 === t); return this.finishToken(N.jsxName, this.input.slice(e, this.state.pos)) } }, { key: "jsxParseIdentifier", value: function () { var t = this.startNode(); return this.match(N.jsxName) ? t.name = this.state.value : this.state.type.keyword ? t.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(t, "JSXIdentifier") } }, { key: "jsxParseNamespacedName", value: function () { var t = this.state.start, e = this.state.startLoc, s = this.jsxParseIdentifier(); if (!this.eat(N.colon)) return s; var i = this.startNodeAt(t, e); return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName") } }, { key: "jsxParseElementName", value: function () { var t = this.state.start, e = this.state.startLoc, s = this.jsxParseNamespacedName(); if ("JSXNamespacedName" === s.type) return s; for (; this.eat(N.dot);) { var i = this.startNodeAt(t, e); i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression") } return s } }, { key: "jsxParseAttributeValue", value: function () { var t; switch (this.state.type) { case N.braceL: return t = this.startNode(), this.next(), "JSXEmptyExpression" === (t = this.jsxParseExpressionContainer(t)).expression.type && this.raise(t.start, ue.AttributeIsEmpty), t; case N.jsxTagStart: case N.string: return this.parseExprAtom(); default: throw this.raise(this.state.start, ue.UnsupportedJsxValue) } } }, { key: "jsxParseEmptyExpression", value: function () { var t = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc); return this.finishNodeAt(t, "JSXEmptyExpression", this.state.start, this.state.startLoc) } }, { key: "jsxParseSpreadChild", value: function (t) { return this.next(), t.expression = this.parseExpression(), this.expect(N.braceR), this.finishNode(t, "JSXSpreadChild") } }, { key: "jsxParseExpressionContainer", value: function (t) { return this.match(N.braceR) ? t.expression = this.jsxParseEmptyExpression() : t.expression = this.parseExpression(), this.expect(N.braceR), this.finishNode(t, "JSXExpressionContainer") } }, { key: "jsxParseAttribute", value: function () { var t = this.startNode(); return this.eat(N.braceL) ? (this.expect(N.ellipsis), t.argument = this.parseMaybeAssignAllowIn(), this.expect(N.braceR), this.finishNode(t, "JSXSpreadAttribute")) : (t.name = this.jsxParseNamespacedName(), t.value = this.eat(N.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(t, "JSXAttribute")) } }, { key: "jsxParseOpeningElementAt", value: function (t, e) { var s = this.startNodeAt(t, e); return this.match(N.jsxTagEnd) ? (this.expect(N.jsxTagEnd), this.finishNode(s, "JSXOpeningFragment")) : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s)) } }, { key: "jsxParseOpeningElementAfterName", value: function (t) { for (var e = []; !this.match(N.slash) && !this.match(N.jsxTagEnd);)e.push(this.jsxParseAttribute()); return t.attributes = e, t.selfClosing = this.eat(N.slash), this.expect(N.jsxTagEnd), this.finishNode(t, "JSXOpeningElement") } }, { key: "jsxParseClosingElementAt", value: function (t, e) { var s = this.startNodeAt(t, e); return this.match(N.jsxTagEnd) ? (this.expect(N.jsxTagEnd), this.finishNode(s, "JSXClosingFragment")) : (s.name = this.jsxParseElementName(), this.expect(N.jsxTagEnd), this.finishNode(s, "JSXClosingElement")) } }, { key: "jsxParseElementAt", value: function (t, e) { var s = this.startNodeAt(t, e), i = [], a = this.jsxParseOpeningElementAt(t, e), r = null; if (!a.selfClosing) { t: for (; ;)switch (this.state.type) { case N.jsxTagStart: if (t = this.state.start, e = this.state.startLoc, this.next(), this.eat(N.slash)) { r = this.jsxParseClosingElementAt(t, e); break t } i.push(this.jsxParseElementAt(t, e)); break; case N.jsxText: i.push(this.parseExprAtom()); break; case N.braceL: var n = this.startNode(); this.next(), this.match(N.ellipsis) ? i.push(this.jsxParseSpreadChild(n)) : i.push(this.jsxParseExpressionContainer(n)); break; default: throw this.unexpected() }de(a) && !de(r) ? this.raise(r.start, ue.MissingClosingTagFragment) : !de(a) && de(r) ? this.raise(r.start, ue.MissingClosingTagElement, me(a.name)) : de(a) || de(r) || me(r.name) !== me(a.name) && this.raise(r.start, ue.MissingClosingTagElement, me(a.name)) } if (de(a) ? (s.openingFragment = a, s.closingFragment = r) : (s.openingElement = a, s.closingElement = r), s.children = i, this.isRelational("<")) throw this.raise(this.state.start, ue.UnwrappedAdjacentJSXElements); return de(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement") } }, { key: "jsxParseElement", value: function () { var t = this.state.start, e = this.state.startLoc; return this.next(), this.jsxParseElementAt(t, e) } }, { key: "parseExprAtom", value: function (t) { return this.match(N.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(N.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && 33 !== this.input.charCodeAt(this.state.pos) ? (this.finishToken(N.jsxTagStart), this.jsxParseElement()) : n(f(i.prototype), "parseExprAtom", this).call(this, t) } }, { key: "getTokenFromCode", value: function (t) { if (this.state.inPropertyName) return n(f(i.prototype), "getTokenFromCode", this).call(this, t); var e = this.curContext(); if (e === Mt.j_expr) return this.jsxReadToken(); if (e === Mt.j_oTag || e === Mt.j_cTag) { if (qt(t)) return this.jsxReadWord(); if (62 === t) return ++this.state.pos, this.finishToken(N.jsxTagEnd); if ((34 === t || 39 === t) && e === Mt.j_oTag) return this.jsxReadString(t) } return 60 === t && this.state.exprAllowed && 33 !== this.input.charCodeAt(this.state.pos + 1) ? (++this.state.pos, this.finishToken(N.jsxTagStart)) : n(f(i.prototype), "getTokenFromCode", this).call(this, t) } }, { key: "updateContext", value: function (t) { if (this.match(N.braceL)) { var e = this.curContext(); e === Mt.j_oTag ? this.state.context.push(Mt.braceExpression) : e === Mt.j_expr ? this.state.context.push(Mt.templateQuasi) : n(f(i.prototype), "updateContext", this).call(this, t), this.state.exprAllowed = !0 } else { if (!this.match(N.slash) || t !== N.jsxTagStart) return n(f(i.prototype), "updateContext", this).call(this, t); this.state.context.length -= 2, this.state.context.push(Mt.j_cTag), this.state.exprAllowed = !1 } } }]), i }() }, ye = function t(e) { x(this, t), this.flags = void 0, this.var = [], this.lexical = [], this.functions = [], this.flags = e }, ve = function () { function t(e, s) { x(this, t), this.scopeStack = [], this.raise = void 0, this.inModule = void 0, this.undefinedExports = new Map, this.undefinedPrivateNames = new Map, this.raise = e, this.inModule = s } return v(t, [{ key: "createScope", value: function (t) { return new ye(t) } }, { key: "enter", value: function (t) { this.scopeStack.push(this.createScope(t)) } }, { key: "exit", value: function () { this.scopeStack.pop() } }, { key: "treatFunctionsAsVarInScope", value: function (t) { return !!(t.flags & D || !this.inModule && t.flags & L) } }, { key: "declareName", value: function (t, e, s) { var i = this.currentScope(); if (e & z || e & H) this.checkRedeclarationInScope(i, t, e, s), e & H ? i.functions.push(t) : i.lexical.push(t), e & z && this.maybeExportDefined(i, t); else if (e & V) for (var a = this.scopeStack.length - 1; a >= 0 && (i = this.scopeStack[a], this.checkRedeclarationInScope(i, t, e, s), i.var.push(t), this.maybeExportDefined(i, t), !(i.flags & j)); --a); this.inModule && i.flags & L && this.undefinedExports.delete(t) } }, { key: "maybeExportDefined", value: function (t, e) { this.inModule && t.flags & L && this.undefinedExports.delete(e) } }, { key: "checkRedeclarationInScope", value: function (t, e, s, i) { this.isRedeclaredInScope(t, e, s) && this.raise(i, Ct.VarRedeclaration, e) } }, { key: "isRedeclaredInScope", value: function (t, e, s) { return !!(s & U) && (s & z ? t.lexical.indexOf(e) > -1 || t.functions.indexOf(e) > -1 || t.var.indexOf(e) > -1 : s & H ? t.lexical.indexOf(e) > -1 || !this.treatFunctionsAsVarInScope(t) && t.var.indexOf(e) > -1 : t.lexical.indexOf(e) > -1 && !(t.flags & R && t.lexical[0] === e) || !this.treatFunctionsAsVarInScope(t) && t.functions.indexOf(e) > -1) } }, { key: "checkLocalExport", value: function (t) { -1 === this.scopeStack[0].lexical.indexOf(t.name) && -1 === this.scopeStack[0].var.indexOf(t.name) && -1 === this.scopeStack[0].functions.indexOf(t.name) && this.undefinedExports.set(t.name, t.start) } }, { key: "currentScope", value: function () { return this.scopeStack[this.scopeStack.length - 1] } }, { key: "currentVarScope", value: function () { for (var t = this.scopeStack.length - 1; ; t--) { var e = this.scopeStack[t]; if (e.flags & j) return e } } }, { key: "currentThisScope", value: function () { for (var t = this.scopeStack.length - 1; ; t--) { var e = this.scopeStack[t]; if ((e.flags & j || e.flags & B) && !(e.flags & M)) return e } } }, { key: "inFunction", get: function () { return (this.currentVarScope().flags & D) > 0 } }, { key: "allowSuper", get: function () { return (this.currentThisScope().flags & O) > 0 } }, { key: "allowDirectSuper", get: function () { return (this.currentThisScope().flags & F) > 0 } }, { key: "inClass", get: function () { return (this.currentThisScope().flags & B) > 0 } }, { key: "inNonArrowFunction", get: function () { return (this.currentThisScope().flags & D) > 0 } }, { key: "treatFunctionsAsVar", get: function () { return this.treatFunctionsAsVarInScope(this.currentScope()) } }]), t }(), xe = function (t) { l(s, ye); var e = c(s); function s() { var t; x(this, s); for (var i = arguments.length, a = new Array(i), r = 0; r < i; r++)a[r] = arguments[r]; return (t = e.call.apply(e, [this].concat(a))).types = [], t.enums = [], t.constEnums = [], t.classes = [], t.exportOnlyBindings = [], t } return s }(), Pe = function (t) { l(s, ve); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "createScope", value: function (t) { return new xe(t) } }, { key: "declareName", value: function (t, e, i) { var a = this.currentScope(); if (e & G) return this.maybeExportDefined(a, t), void a.exportOnlyBindings.push(t); n(f(s.prototype), "declareName", this).apply(this, arguments), e & q && (e & U || (this.checkRedeclarationInScope(a, t, e, i), this.maybeExportDefined(a, t)), a.types.push(t)), e & J && a.enums.push(t), e & X && a.constEnums.push(t), e & W && a.classes.push(t) } }, { key: "isRedeclaredInScope", value: function (t, e, i) { return t.enums.indexOf(e) > -1 ? !(i & J) || !!(i & X) !== t.constEnums.indexOf(e) > -1 : i & W && t.classes.indexOf(e) > -1 ? t.lexical.indexOf(e) > -1 && !!(i & U) : !!(i & q && t.types.indexOf(e) > -1) || n(f(s.prototype), "isRedeclaredInScope", this).apply(this, arguments) } }, { key: "checkLocalExport", value: function (t) { -1 === this.scopeStack[0].types.indexOf(t.name) && -1 === this.scopeStack[0].exportOnlyBindings.indexOf(t.name) && n(f(s.prototype), "checkLocalExport", this).call(this, t) } }]), s }(), ke = 0, ge = 1, be = 2, Te = 4, we = 8, Ae = function () { function t() { x(this, t), this.stacks = [] } return v(t, [{ key: "enter", value: function (t) { this.stacks.push(t) } }, { key: "exit", value: function () { this.stacks.pop() } }, { key: "currentFlags", value: function () { return this.stacks[this.stacks.length - 1] } }, { key: "hasAwait", get: function () { return (this.currentFlags() & be) > 0 } }, { key: "hasYield", get: function () { return (this.currentFlags() & ge) > 0 } }, { key: "hasReturn", get: function () { return (this.currentFlags() & Te) > 0 } }, { key: "hasIn", get: function () { return (this.currentFlags() & we) > 0 } }]), t }(); function Ee(t, e) { return (t ? be : 0) | (e ? ge : 0) } function Se(t) { if (null == t) throw new Error("Unexpected ".concat(t, " value.")); return t } function Ce(t) { if (!t) throw new Error("Assert fail") } var Ne = Object.freeze({ ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateModifier: "Duplicate modifier: '%0'", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0')", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0')", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0" }); function Ie(t) { switch (t) { case "any": return "TSAnyKeyword"; case "boolean": return "TSBooleanKeyword"; case "bigint": return "TSBigIntKeyword"; case "never": return "TSNeverKeyword"; case "number": return "TSNumberKeyword"; case "object": return "TSObjectKeyword"; case "string": return "TSStringKeyword"; case "symbol": return "TSSymbolKeyword"; case "undefined": return "TSUndefinedKeyword"; case "unknown": return "TSUnknownKeyword"; default: return } } var Le = function (t) { return function (e) { l(i, t); var s = c(i); function i() { return x(this, i), s.apply(this, arguments) } return v(i, [{ key: "getScopeHandler", value: function () { return Pe } }, { key: "tsIsIdentifier", value: function () { return this.match(N.name) } }, { key: "tsNextTokenCanFollowModifier", value: function () { return this.next(), !(this.hasPrecedingLineBreak() || this.match(N.parenL) || this.match(N.parenR) || this.match(N.colon) || this.match(N.eq) || this.match(N.question) || this.match(N.bang)) } }, { key: "tsParseModifier", value: function (t) { if (this.match(N.name)) { var e = this.state.value; return -1 !== t.indexOf(e) && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? e : void 0 } } }, { key: "tsParseModifiers", value: function (t, e) { for (; ;) { var s = this.state.start, i = this.tsParseModifier(e); if (!i) break; Object.hasOwnProperty.call(t, i) && this.raise(s, Ne.DuplicateModifier, i), t[i] = !0 } } }, { key: "tsIsListTerminator", value: function (t) { switch (t) { case "EnumMembers": case "TypeMembers": return this.match(N.braceR); case "HeritageClauseElement": return this.match(N.braceL); case "TupleElementTypes": return this.match(N.bracketR); case "TypeParametersOrArguments": return this.isRelational(">") }throw new Error("Unreachable") } }, { key: "tsParseList", value: function (t, e) { for (var s = []; !this.tsIsListTerminator(t);)s.push(e()); return s } }, { key: "tsParseDelimitedList", value: function (t, e) { return Se(this.tsParseDelimitedListWorker(t, e, !0)) } }, { key: "tsParseDelimitedListWorker", value: function (t, e, s) { for (var i = []; !this.tsIsListTerminator(t);) { var a = e(); if (null == a) return; if (i.push(a), !this.eat(N.comma)) { if (this.tsIsListTerminator(t)) break; return void (s && this.expect(N.comma)) } } return i } }, { key: "tsParseBracketedList", value: function (t, e, s, i) { i || (s ? this.expect(N.bracketL) : this.expectRelational("<")); var a = this.tsParseDelimitedList(t, e); return s ? this.expect(N.bracketR) : this.expectRelational(">"), a } }, { key: "tsParseImportType", value: function () { var t = this.startNode(); return this.expect(N._import), this.expect(N.parenL), this.match(N.string) || this.raise(this.state.start, Ne.UnsupportedImportTypeArgument), t.argument = this.parseExprAtom(), this.expect(N.parenR), this.eat(N.dot) && (t.qualifier = this.tsParseEntityName(!0)), this.isRelational("<") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSImportType") } }, { key: "tsParseEntityName", value: function (t) { for (var e = this.parseIdentifier(); this.eat(N.dot);) { var s = this.startNodeAtNode(e); s.left = e, s.right = this.parseIdentifier(t), e = this.finishNode(s, "TSQualifiedName") } return e } }, { key: "tsParseTypeReference", value: function () { var t = this.startNode(); return t.typeName = this.tsParseEntityName(!1), !this.hasPrecedingLineBreak() && this.isRelational("<") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSTypeReference") } }, { key: "tsParseThisTypePredicate", value: function (t) { this.next(); var e = this.startNodeAtNode(t); return e.parameterName = t, e.typeAnnotation = this.tsParseTypeAnnotation(!1), this.finishNode(e, "TSTypePredicate") } }, { key: "tsParseThisTypeNode", value: function () { var t = this.startNode(); return this.next(), this.finishNode(t, "TSThisType") } }, { key: "tsParseTypeQuery", value: function () { var t = this.startNode(); return this.expect(N._typeof), this.match(N._import) ? t.exprName = this.tsParseImportType() : t.exprName = this.tsParseEntityName(!0), this.finishNode(t, "TSTypeQuery") } }, { key: "tsParseTypeParameter", value: function () { var t = this.startNode(); return t.name = this.parseIdentifierName(t.start), t.constraint = this.tsEatThenParseType(N._extends), t.default = this.tsEatThenParseType(N.eq), this.finishNode(t, "TSTypeParameter") } }, { key: "tsTryParseTypeParameters", value: function () { if (this.isRelational("<")) return this.tsParseTypeParameters() } }, { key: "tsParseTypeParameters", value: function () { var t = this.startNode(); return this.isRelational("<") || this.match(N.jsxTagStart) ? this.next() : this.unexpected(), t.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), !1, !0), 0 === t.params.length && this.raise(t.start, Ne.EmptyTypeParameters), this.finishNode(t, "TSTypeParameterDeclaration") } }, { key: "tsTryNextParseConstantContext", value: function () { return this.lookahead().type === N._const ? (this.next(), this.tsParseTypeReference()) : null } }, { key: "tsFillSignature", value: function (t, e) { var s = t === N.arrow; e.typeParameters = this.tsTryParseTypeParameters(), this.expect(N.parenL), e.parameters = this.tsParseBindingListForSignature(), s ? e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t) : this.match(t) && (e.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(t)) } }, { key: "tsParseBindingListForSignature", value: function () { var t = this; return this.parseBindingList(N.parenR, 41).map(function (e) { return "Identifier" !== e.type && "RestElement" !== e.type && "ObjectPattern" !== e.type && "ArrayPattern" !== e.type && t.raise(e.start, Ne.UnsupportedSignatureParameterKind, e.type), e }) } }, { key: "tsParseTypeMemberSemicolon", value: function () { this.eat(N.comma) || this.semicolon() } }, { key: "tsParseSignatureMember", value: function (t, e) { return this.tsFillSignature(N.colon, e), this.tsParseTypeMemberSemicolon(), this.finishNode(e, t) } }, { key: "tsIsUnambiguouslyIndexSignature", value: function () { return this.next(), this.eat(N.name) && this.match(N.colon) } }, { key: "tsTryParseIndexSignature", value: function (t) { if (this.match(N.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))) { this.expect(N.bracketL); var e = this.parseIdentifier(); e.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(e), this.expect(N.bracketR), t.parameters = [e]; var s = this.tsTryParseTypeAnnotation(); return s && (t.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(t, "TSIndexSignature") } } }, { key: "tsParsePropertyOrMethodSignature", value: function (t, e) { this.eat(N.question) && (t.optional = !0); var s = t; if (e || !this.match(N.parenL) && !this.isRelational("<")) { var i = s; e && (i.readonly = !0); var a = this.tsTryParseTypeAnnotation(); return a && (i.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature") } var r = s; return this.tsFillSignature(N.colon, r), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSMethodSignature") } }, { key: "tsParseTypeMember", value: function () { var t = this.startNode(); if (this.match(N.parenL) || this.isRelational("<")) return this.tsParseSignatureMember("TSCallSignatureDeclaration", t); if (this.match(N._new)) { var e = this.startNode(); return this.next(), this.match(N.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", t) : (t.key = this.createIdentifier(e, "new"), this.tsParsePropertyOrMethodSignature(t, !1)) } var s = !!this.tsParseModifier(["readonly"]), i = this.tsTryParseIndexSignature(t); return i ? (s && (t.readonly = !0), i) : (this.parsePropertyName(t, !1), this.tsParsePropertyOrMethodSignature(t, s)) } }, { key: "tsParseTypeLiteral", value: function () { var t = this.startNode(); return t.members = this.tsParseObjectTypeMembers(), this.finishNode(t, "TSTypeLiteral") } }, { key: "tsParseObjectTypeMembers", value: function () { this.expect(N.braceL); var t = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this)); return this.expect(N.braceR), t } }, { key: "tsIsStartOfMappedType", value: function () { return this.next(), this.eat(N.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(N.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(N._in)))) } }, { key: "tsParseMappedTypeParameter", value: function () { var t = this.startNode(); return t.name = this.parseIdentifierName(t.start), t.constraint = this.tsExpectThenParseType(N._in), this.finishNode(t, "TSTypeParameter") } }, { key: "tsParseMappedType", value: function () { var t = this.startNode(); return this.expect(N.braceL), this.match(N.plusMin) ? (t.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (t.readonly = !0), this.expect(N.bracketL), t.typeParameter = this.tsParseMappedTypeParameter(), t.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(N.bracketR), this.match(N.plusMin) ? (t.optional = this.state.value, this.next(), this.expect(N.question)) : this.eat(N.question) && (t.optional = !0), t.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(N.braceR), this.finishNode(t, "TSMappedType") } }, { key: "tsParseTupleType", value: function () { var t = this, e = this.startNode(); e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1); var s = !1, i = null; return e.elementTypes.forEach(function (e) { var a, { type: r } = e; !s || "TSRestType" === r || "TSOptionalType" === r || "TSNamedTupleMember" === r && e.optional || t.raise(e.start, Ne.OptionalTypeBeforeRequired), s = s || "TSNamedTupleMember" === r && e.optional || "TSOptionalType" === r, "TSRestType" === r && (r = (e = e.typeAnnotation).type); var n = "TSNamedTupleMember" === r; (i = null != (a = i) ? a : n) !== n && t.raise(e.start, Ne.MixedLabeledAndUnlabeledElements) }), this.finishNode(e, "TSTupleType") } }, { key: "tsParseTupleElementType", value: function () { var { start: t, startLoc: e } = this.state, s = this.eat(N.ellipsis), i = this.tsParseType(), a = this.eat(N.question); if (this.eat(N.colon)) { var r = this.startNodeAtNode(i); r.optional = a, "TSTypeReference" !== i.type || i.typeParameters || "Identifier" !== i.typeName.type ? (this.raise(i.start, Ne.InvalidTupleMemberLabel), r.label = i) : r.label = i.typeName, r.elementType = this.tsParseType(), i = this.finishNode(r, "TSNamedTupleMember") } else if (a) { var n = this.startNodeAtNode(i); n.typeAnnotation = i, i = this.finishNode(n, "TSOptionalType") } if (s) { var o = this.startNodeAt(t, e); o.typeAnnotation = i, i = this.finishNode(o, "TSRestType") } return i } }, { key: "tsParseParenthesizedType", value: function () { var t = this.startNode(); return this.expect(N.parenL), t.typeAnnotation = this.tsParseType(), this.expect(N.parenR), this.finishNode(t, "TSParenthesizedType") } }, { key: "tsParseFunctionOrConstructorType", value: function (t) { var e = this.startNode(); return "TSConstructorType" === t && this.expect(N._new), this.tsFillSignature(N.arrow, e), this.finishNode(e, t) } }, { key: "tsParseLiteralTypeNode", value: function () { var t = this, e = this.startNode(); return e.literal = function () { switch (t.state.type) { case N.num: case N.bigint: case N.string: case N._true: case N._false: return t.parseExprAtom(); default: throw t.unexpected() } }(), this.finishNode(e, "TSLiteralType") } }, { key: "tsParseTemplateLiteralType", value: function () { var t = this.startNode(); return t.literal = this.parseTemplate(!1), this.finishNode(t, "TSLiteralType") } }, { key: "parseTemplateSubstitution", value: function () { return this.state.inType ? this.tsParseType() : n(f(i.prototype), "parseTemplateSubstitution", this).call(this) } }, { key: "tsParseThisTypeOrThisTypePredicate", value: function () { var t = this.tsParseThisTypeNode(); return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(t) : t } }, { key: "tsParseNonArrayType", value: function () { switch (this.state.type) { case N.name: case N._void: case N._null: var t = this.match(N._void) ? "TSVoidKeyword" : this.match(N._null) ? "TSNullKeyword" : Ie(this.state.value); if (void 0 !== t && 46 !== this.lookaheadCharCode()) { var e = this.startNode(); return this.next(), this.finishNode(e, t) } return this.tsParseTypeReference(); case N.string: case N.num: case N.bigint: case N._true: case N._false: return this.tsParseLiteralTypeNode(); case N.plusMin: if ("-" === this.state.value) { var s = this.startNode(), i = this.lookahead(); if (i.type !== N.num && i.type !== N.bigint) throw this.unexpected(); return s.literal = this.parseMaybeUnary(), this.finishNode(s, "TSLiteralType") } break; case N._this: return this.tsParseThisTypeOrThisTypePredicate(); case N._typeof: return this.tsParseTypeQuery(); case N._import: return this.tsParseImportType(); case N.braceL: return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral(); case N.bracketL: return this.tsParseTupleType(); case N.parenL: return this.tsParseParenthesizedType(); case N.backQuote: return this.tsParseTemplateLiteralType() }throw this.unexpected() } }, { key: "tsParseArrayTypeOrHigher", value: function () { for (var t = this.tsParseNonArrayType(); !this.hasPrecedingLineBreak() && this.eat(N.bracketL);)if (this.match(N.bracketR)) { var e = this.startNodeAtNode(t); e.elementType = t, this.expect(N.bracketR), t = this.finishNode(e, "TSArrayType") } else { var s = this.startNodeAtNode(t); s.objectType = t, s.indexType = this.tsParseType(), this.expect(N.bracketR), t = this.finishNode(s, "TSIndexedAccessType") } return t } }, { key: "tsParseTypeOperator", value: function (t) { var e = this.startNode(); return this.expectContextual(t), e.operator = t, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator") } }, { key: "tsCheckTypeAnnotationForReadOnly", value: function (t) { switch (t.typeAnnotation.type) { case "TSTupleType": case "TSArrayType": return; default: this.raise(t.start, Ne.UnexpectedReadonly) } } }, { key: "tsParseInferType", value: function () { var t = this.startNode(); this.expectContextual("infer"); var e = this.startNode(); return e.name = this.parseIdentifierName(e.start), t.typeParameter = this.finishNode(e, "TSTypeParameter"), this.finishNode(t, "TSInferType") } }, { key: "tsParseTypeOperatorOrHigher", value: function () { var t = this, e = ["keyof", "unique", "readonly"].find(function (e) { return t.isContextual(e) }); return e ? this.tsParseTypeOperator(e) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher() } }, { key: "tsParseUnionOrIntersectionType", value: function (t, e, s) { this.eat(s); var i = e(); if (this.match(s)) { for (var a = [i]; this.eat(s);)a.push(e()); var r = this.startNodeAtNode(i); r.types = a, i = this.finishNode(r, t) } return i } }, { key: "tsParseIntersectionTypeOrHigher", value: function () { return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), N.bitwiseAND) } }, { key: "tsParseUnionTypeOrHigher", value: function () { return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), N.bitwiseOR) } }, { key: "tsIsStartOfFunctionType", value: function () { return !!this.isRelational("<") || this.match(N.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this)) } }, { key: "tsSkipParameterStart", value: function () { if (this.match(N.name) || this.match(N._this)) return this.next(), !0; if (this.match(N.braceL)) { var t = 1; for (this.next(); t > 0;)this.match(N.braceL) ? ++t : this.match(N.braceR) && --t, this.next(); return !0 } if (this.match(N.bracketL)) { var e = 1; for (this.next(); e > 0;)this.match(N.bracketL) ? ++e : this.match(N.bracketR) && --e, this.next(); return !0 } return !1 } }, { key: "tsIsUnambiguouslyStartOfFunctionType", value: function () { if (this.next(), this.match(N.parenR) || this.match(N.ellipsis)) return !0; if (this.tsSkipParameterStart()) { if (this.match(N.colon) || this.match(N.comma) || this.match(N.question) || this.match(N.eq)) return !0; if (this.match(N.parenR) && (this.next(), this.match(N.arrow))) return !0 } return !1 } }, { key: "tsParseTypeOrTypePredicateAnnotation", value: function (t) { var e = this; return this.tsInType(function () { var s = e.startNode(); e.expect(t); var i = !!e.tsTryParse(e.tsParseTypePredicateAsserts.bind(e)); if (i && e.match(N._this)) { var a = e.tsParseThisTypeOrThisTypePredicate(); if ("TSThisType" === a.type) { var r = e.startNodeAtNode(s); r.parameterName = a, r.asserts = !0, a = e.finishNode(r, "TSTypePredicate") } else a.asserts = !0; return s.typeAnnotation = a, e.finishNode(s, "TSTypeAnnotation") } var n = e.tsIsIdentifier() && e.tsTryParse(e.tsParseTypePredicatePrefix.bind(e)); if (!n) { if (!i) return e.tsParseTypeAnnotation(!1, s); var o = e.startNodeAtNode(s); return o.parameterName = e.parseIdentifier(), o.asserts = i, s.typeAnnotation = e.finishNode(o, "TSTypePredicate"), e.finishNode(s, "TSTypeAnnotation") } var h = e.tsParseTypeAnnotation(!1), l = e.startNodeAtNode(s); return l.parameterName = n, l.typeAnnotation = h, l.asserts = i, s.typeAnnotation = e.finishNode(l, "TSTypePredicate"), e.finishNode(s, "TSTypeAnnotation") }) } }, { key: "tsTryParseTypeOrTypePredicateAnnotation", value: function () { return this.match(N.colon) ? this.tsParseTypeOrTypePredicateAnnotation(N.colon) : void 0 } }, { key: "tsTryParseTypeAnnotation", value: function () { return this.match(N.colon) ? this.tsParseTypeAnnotation() : void 0 } }, { key: "tsTryParseType", value: function () { return this.tsEatThenParseType(N.colon) } }, { key: "tsParseTypePredicatePrefix", value: function () { var t = this.parseIdentifier(); if (this.isContextual("is") && !this.hasPrecedingLineBreak()) return this.next(), t } }, { key: "tsParseTypePredicateAsserts", value: function () { if (!this.match(N.name) || "asserts" !== this.state.value || this.hasPrecedingLineBreak()) return !1; var t = this.state.containsEsc; return this.next(), !(!this.match(N.name) && !this.match(N._this)) && (t && this.raise(this.state.lastTokStart, Ct.InvalidEscapedReservedWord, "asserts"), !0) } }, { key: "tsParseTypeAnnotation", value: function () { var t = this, e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.startNode(); return this.tsInType(function () { e && t.expect(N.colon), s.typeAnnotation = t.tsParseType() }), this.finishNode(s, "TSTypeAnnotation") } }, { key: "tsParseType", value: function () { Ce(this.state.inType); var t = this.tsParseNonConditionalType(); if (this.hasPrecedingLineBreak() || !this.eat(N._extends)) return t; var e = this.startNodeAtNode(t); return e.checkType = t, e.extendsType = this.tsParseNonConditionalType(), this.expect(N.question), e.trueType = this.tsParseType(), this.expect(N.colon), e.falseType = this.tsParseType(), this.finishNode(e, "TSConditionalType") } }, { key: "tsParseNonConditionalType", value: function () { return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(N._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.tsParseUnionTypeOrHigher() } }, { key: "tsParseTypeAssertion", value: function () { var t = this.startNode(), e = this.tsTryNextParseConstantContext(); return t.typeAnnotation = e || this.tsNextThenParseType(), this.expectRelational(">"), t.expression = this.parseMaybeUnary(), this.finishNode(t, "TSTypeAssertion") } }, { key: "tsParseHeritageClause", value: function (t) { var e = this.state.start, s = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this)); return s.length || this.raise(e, Ne.EmptyHeritageClauseType, t), s } }, { key: "tsParseExpressionWithTypeArguments", value: function () { var t = this.startNode(); return t.expression = this.tsParseEntityName(!1), this.isRelational("<") && (t.typeParameters = this.tsParseTypeArguments()), this.finishNode(t, "TSExpressionWithTypeArguments") } }, { key: "tsParseInterfaceDeclaration", value: function (t) { t.id = this.parseIdentifier(), this.checkLVal(t.id, tt, void 0, "typescript interface declaration"), t.typeParameters = this.tsTryParseTypeParameters(), this.eat(N._extends) && (t.extends = this.tsParseHeritageClause("extends")); var e = this.startNode(); return e.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), t.body = this.finishNode(e, "TSInterfaceBody"), this.finishNode(t, "TSInterfaceDeclaration") } }, { key: "tsParseTypeAliasDeclaration", value: function (t) { var e = this; return t.id = this.parseIdentifier(), this.checkLVal(t.id, et, void 0, "typescript type alias"), t.typeParameters = this.tsTryParseTypeParameters(), t.typeAnnotation = this.tsInType(function () { if (e.expect(N.eq), e.isContextual("intrinsic") && e.lookahead().type !== N.dot) { var t = e.startNode(); return e.next(), e.finishNode(t, "TSIntrinsicKeyword") } return e.tsParseType() }), this.semicolon(), this.finishNode(t, "TSTypeAliasDeclaration") } }, { key: "tsInNoContext", value: function (t) { var e = this.state.context; this.state.context = [e[0]]; try { return t() } finally { this.state.context = e } } }, { key: "tsInType", value: function (t) { var e = this.state.inType; this.state.inType = !0; try { return t() } finally { this.state.inType = e } } }, { key: "tsEatThenParseType", value: function (t) { return this.match(t) ? this.tsNextThenParseType() : void 0 } }, { key: "tsExpectThenParseType", value: function (t) { var e = this; return this.tsDoThenParseType(function () { return e.expect(t) }) } }, { key: "tsNextThenParseType", value: function () { var t = this; return this.tsDoThenParseType(function () { return t.next() }) } }, { key: "tsDoThenParseType", value: function (t) { var e = this; return this.tsInType(function () { return t(), e.tsParseType() }) } }, { key: "tsParseEnumMember", value: function () { var t = this.startNode(); return t.id = this.match(N.string) ? this.parseExprAtom() : this.parseIdentifier(!0), this.eat(N.eq) && (t.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(t, "TSEnumMember") } }, { key: "tsParseEnumDeclaration", value: function (t, e) { return e && (t.const = !0), t.id = this.parseIdentifier(), this.checkLVal(t.id, e ? nt : st, void 0, "typescript enum declaration"), this.expect(N.braceL), t.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(N.braceR), this.finishNode(t, "TSEnumDeclaration") } }, { key: "tsParseModuleBlock", value: function () { var t = this.startNode(); return this.scope.enter(I), this.expect(N.braceL), this.parseBlockOrModuleBlockBody(t.body = [], void 0, !0, N.braceR), this.scope.exit(), this.finishNode(t, "TSModuleBlock") } }, { key: "tsParseModuleOrNamespaceDeclaration", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if (t.id = this.parseIdentifier(), e || this.checkLVal(t.id, ot, null, "module or namespace declaration"), this.eat(N.dot)) { var s = this.startNode(); this.tsParseModuleOrNamespaceDeclaration(s, !0), t.body = s } else this.scope.enter(_), this.prodParam.enter(ke), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit(); return this.finishNode(t, "TSModuleDeclaration") } }, { key: "tsParseAmbientExternalModuleDeclaration", value: function (t) { return this.isContextual("global") ? (t.global = !0, t.id = this.parseIdentifier()) : this.match(N.string) ? t.id = this.parseExprAtom() : this.unexpected(), this.match(N.braceL) ? (this.scope.enter(_), this.prodParam.enter(ke), t.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(t, "TSModuleDeclaration") } }, { key: "tsParseImportEqualsDeclaration", value: function (t, e) { return t.isExport = e || !1, t.id = this.parseIdentifier(), this.checkLVal(t.id, Y, void 0, "import equals declaration"), this.expect(N.eq), t.moduleReference = this.tsParseModuleReference(), this.semicolon(), this.finishNode(t, "TSImportEqualsDeclaration") } }, { key: "tsIsExternalModuleReference", value: function () { return this.isContextual("require") && 40 === this.lookaheadCharCode() } }, { key: "tsParseModuleReference", value: function () { return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(!1) } }, { key: "tsParseExternalModuleReference", value: function () { var t = this.startNode(); if (this.expectContextual("require"), this.expect(N.parenL), !this.match(N.string)) throw this.unexpected(); return t.expression = this.parseExprAtom(), this.expect(N.parenR), this.finishNode(t, "TSExternalModuleReference") } }, { key: "tsLookAhead", value: function (t) { var e = this.state.clone(), s = t(); return this.state = e, s } }, { key: "tsTryParseAndCatch", value: function (t) { var e = this.tryParse(function (e) { return t() || e() }); if (!e.aborted && e.node) return e.error && (this.state = e.failState), e.node } }, { key: "tsTryParse", value: function (t) { var e = this.state.clone(), s = t(); return void 0 !== s && !1 !== s ? s : void (this.state = e) } }, { key: "tsTryParseDeclare", value: function (t) { var e = this; if (!this.isLineTerminator()) { var s, i = this.state.type; return this.isContextual("let") && (i = N._var, s = "let"), this.tsInDeclareContext(function () { switch (i) { case N._function: return t.declare = !0, e.parseFunctionStatement(t, !1, !0); case N._class: return t.declare = !0, e.parseClass(t, !0, !1); case N._const: if (e.match(N._const) && e.isLookaheadContextual("enum")) return e.expect(N._const), e.expectContextual("enum"), e.tsParseEnumDeclaration(t, !0); case N._var: return s = s || e.state.value, e.parseVarStatement(t, s); case N.name: var a = e.state.value; return "global" === a ? e.tsParseAmbientExternalModuleDeclaration(t) : e.tsParseDeclaration(t, a, !0) } }) } } }, { key: "tsTryParseExportDeclaration", value: function () { return this.tsParseDeclaration(this.startNode(), this.state.value, !0) } }, { key: "tsParseExpressionStatement", value: function (t, e) { switch (e.name) { case "declare": var s = this.tsTryParseDeclare(t); if (s) return s.declare = !0, s; break; case "global": if (this.match(N.braceL)) { this.scope.enter(_), this.prodParam.enter(ke); var i = t; return i.global = !0, i.id = e, i.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(i, "TSModuleDeclaration") } break; default: return this.tsParseDeclaration(t, e.name, !1) } } }, { key: "tsParseDeclaration", value: function (t, e, s) { switch (e) { case "abstract": if (this.tsCheckLineTerminatorAndMatch(N._class, s)) { var i = t; return i.abstract = !0, s && (this.next(), this.match(N._class) || this.unexpected(null, N._class)), this.parseClass(i, !0, !1) } break; case "enum": if (s || this.match(N.name)) return s && this.next(), this.tsParseEnumDeclaration(t, !1); break; case "interface": if (this.tsCheckLineTerminatorAndMatch(N.name, s)) return s && this.next(), this.tsParseInterfaceDeclaration(t); break; case "module": if (s && this.next(), this.match(N.string)) return this.tsParseAmbientExternalModuleDeclaration(t); if (this.tsCheckLineTerminatorAndMatch(N.name, s)) return this.tsParseModuleOrNamespaceDeclaration(t); break; case "namespace": if (this.tsCheckLineTerminatorAndMatch(N.name, s)) return s && this.next(), this.tsParseModuleOrNamespaceDeclaration(t); break; case "type": if (this.tsCheckLineTerminatorAndMatch(N.name, s)) return s && this.next(), this.tsParseTypeAliasDeclaration(t) } } }, { key: "tsCheckLineTerminatorAndMatch", value: function (t, e) { return (e || this.match(t)) && !this.isLineTerminator() } }, { key: "tsTryParseGenericAsyncArrowFunction", value: function (t, e) { var s = this; if (this.isRelational("<")) { var a = this.state.maybeInArrowParameters, r = this.state.yieldPos, o = this.state.awaitPos; this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1; var h = this.tsTryParseAndCatch(function () { var a = s.startNodeAt(t, e); return a.typeParameters = s.tsParseTypeParameters(), n(f(i.prototype), "parseFunctionParams", s).call(s, a), a.returnType = s.tsTryParseTypeOrTypePredicateAnnotation(), s.expect(N.arrow), a }); if (this.state.maybeInArrowParameters = a, this.state.yieldPos = r, this.state.awaitPos = o, h) return this.parseArrowExpression(h, null, !0) } } }, { key: "tsParseTypeArguments", value: function () { var t = this, e = this.startNode(); return e.params = this.tsInType(function () { return t.tsInNoContext(function () { return t.expectRelational("<"), t.tsParseDelimitedList("TypeParametersOrArguments", t.tsParseType.bind(t)) }) }), 0 === e.params.length && this.raise(e.start, Ne.EmptyTypeArguments), this.state.exprAllowed = !1, this.expectRelational(">"), this.finishNode(e, "TSTypeParameterInstantiation") } }, { key: "tsIsDeclarationStart", value: function () { if (this.match(N.name)) switch (this.state.value) { case "abstract": case "declare": case "enum": case "interface": case "module": case "namespace": case "type": return !0 }return !1 } }, { key: "isExportDefaultSpecifier", value: function () { return !this.tsIsDeclarationStart() && n(f(i.prototype), "isExportDefaultSpecifier", this).call(this) } }, { key: "parseAssignableListItem", value: function (t, e) { var s, i = this.state.start, a = this.state.startLoc, r = !1; void 0 !== t && (s = this.parseAccessModifier(), r = !!this.tsParseModifier(["readonly"]), !1 === t && (s || r) && this.raise(i, Ne.UnexpectedParameterModifier)); var n = this.parseMaybeDefault(); this.parseAssignableListItemTypes(n); var o = this.parseMaybeDefault(n.start, n.loc.start, n); if (s || r) { var h = this.startNodeAt(i, a); return e.length && (h.decorators = e), s && (h.accessibility = s), r && (h.readonly = r), "Identifier" !== o.type && "AssignmentPattern" !== o.type && this.raise(h.start, Ne.UnsupportedParameterPropertyKind), h.parameter = o, this.finishNode(h, "TSParameterProperty") } return e.length && (n.decorators = e), o } }, { key: "parseFunctionBodyAndFinish", value: function (t, e) { var s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; this.match(N.colon) && (t.returnType = this.tsParseTypeOrTypePredicateAnnotation(N.colon)); var a = "FunctionDeclaration" === e ? "TSDeclareFunction" : "ClassMethod" === e ? "TSDeclareMethod" : void 0; a && !this.match(N.braceL) && this.isLineTerminator() ? this.finishNode(t, a) : "TSDeclareFunction" === a && this.state.isDeclareContext && (this.raise(t.start, Ne.DeclareFunctionHasImplementation), t.declare) ? n(f(i.prototype), "parseFunctionBodyAndFinish", this).call(this, t, a, s) : n(f(i.prototype), "parseFunctionBodyAndFinish", this).call(this, t, e, s) } }, { key: "registerFunctionStatementId", value: function (t) { !t.body && t.id ? this.checkLVal(t.id, it, null, "function name") : n(f(i.prototype), "registerFunctionStatementId", this).apply(this, arguments) } }, { key: "tsCheckForInvalidTypeCasts", value: function (t) { var e = this; t.forEach(function (t) { "TSTypeCastExpression" === (null == t ? void 0 : t.type) && e.raise(t.typeAnnotation.start, Ne.UnexpectedTypeAnnotation) }) } }, { key: "toReferencedList", value: function (t, e) { return this.tsCheckForInvalidTypeCasts(t), t } }, { key: "parseSubscript", value: function (t, e, s, a, r) { var o = this; if (!this.hasPrecedingLineBreak() && this.match(N.bang)) { this.state.exprAllowed = !1, this.next(); var h = this.startNodeAt(e, s); return h.expression = t, this.finishNode(h, "TSNonNullExpression") } if (this.isRelational("<")) { var l = this.tsTryParseAndCatch(function () { if (!a && o.atPossibleAsyncArrow(t)) { var i = o.tsTryParseGenericAsyncArrowFunction(e, s); if (i) return i } var n = o.startNodeAt(e, s); n.callee = t; var h = o.tsParseTypeArguments(); if (h) { if (!a && o.eat(N.parenL)) return n.arguments = o.parseCallExpressionArguments(N.parenR, !1), o.tsCheckForInvalidTypeCasts(n.arguments), n.typeParameters = h, o.finishCallExpression(n, r.optionalChainMember); if (o.match(N.backQuote)) { var l = o.parseTaggedTemplateExpression(t, e, s, r); return l.typeParameters = h, l } } o.unexpected() }); if (l) return l } return n(f(i.prototype), "parseSubscript", this).call(this, t, e, s, a, r) } }, { key: "parseNewArguments", value: function (t) { var e = this; if (this.isRelational("<")) { var s = this.tsTryParseAndCatch(function () { var t = e.tsParseTypeArguments(); return e.match(N.parenL) || e.unexpected(), t }); s && (t.typeParameters = s) } n(f(i.prototype), "parseNewArguments", this).call(this, t) } }, { key: "parseExprOp", value: function (t, e, s, a) { if (Se(N._in.binop) > a && !this.hasPrecedingLineBreak() && this.isContextual("as")) { var r = this.startNodeAt(e, s); r.expression = t; var o = this.tsTryNextParseConstantContext(); return r.typeAnnotation = o || this.tsNextThenParseType(), this.finishNode(r, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(r, e, s, a) } return n(f(i.prototype), "parseExprOp", this).call(this, t, e, s, a) } }, { key: "checkReservedWord", value: function (t, e, s, i) { } }, { key: "checkDuplicateExports", value: function () { } }, { key: "parseImport", value: function (t) { if (this.match(N.name) || this.match(N.star) || this.match(N.braceL)) { var e = this.lookahead(); if (this.match(N.name) && e.type === N.eq) return this.tsParseImportEqualsDeclaration(t); !this.isContextual("type") || e.type === N.comma || e.type === N.name && "from" === e.value ? t.importKind = "value" : (t.importKind = "type", this.next()) } var s = n(f(i.prototype), "parseImport", this).call(this, t); return "type" === s.importKind && s.specifiers.length > 1 && "ImportDefaultSpecifier" === s.specifiers[0].type && this.raise(s.start, "A type-only import can specify a default import or named bindings, but not both."), s } }, { key: "parseExport", value: function (t) { if (this.match(N._import)) return this.expect(N._import), this.tsParseImportEqualsDeclaration(t, !0); if (this.eat(N.eq)) { var e = t; return e.expression = this.parseExpression(), this.semicolon(), this.finishNode(e, "TSExportAssignment") } if (this.eatContextual("as")) { var s = t; return this.expectContextual("namespace"), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration") } return this.isContextual("type") && this.lookahead().type === N.braceL ? (this.next(), t.exportKind = "type") : t.exportKind = "value", n(f(i.prototype), "parseExport", this).call(this, t) } }, { key: "isAbstractClass", value: function () { return this.isContextual("abstract") && this.lookahead().type === N._class } }, { key: "parseExportDefaultExpression", value: function () { if (this.isAbstractClass()) { var t = this.startNode(); return this.next(), this.parseClass(t, !0, !0), t.abstract = !0, t } if ("interface" === this.state.value) { var e = this.tsParseDeclaration(this.startNode(), this.state.value, !0); if (e) return e } return n(f(i.prototype), "parseExportDefaultExpression", this).call(this) } }, { key: "parseStatementContent", value: function (t, e) { if (this.state.type === N._const) { var s = this.lookahead(); if (s.type === N.name && "enum" === s.value) { var a = this.startNode(); return this.expect(N._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(a, !0) } } return n(f(i.prototype), "parseStatementContent", this).call(this, t, e) } }, { key: "parseAccessModifier", value: function () { return this.tsParseModifier(["public", "protected", "private"]) } }, { key: "parseClassMember", value: function (t, e, s) { var a = this; this.tsParseModifiers(e, ["declare"]); var r = this.parseAccessModifier(); r && (e.accessibility = r), this.tsParseModifiers(e, ["declare"]); var o = function () { n(f(i.prototype), "parseClassMember", a).call(a, t, e, s) }; e.declare ? this.tsInDeclareContext(o) : o() } }, { key: "parseClassMemberWithIsStatic", value: function (t, e, s, a) { this.tsParseModifiers(e, ["abstract", "readonly", "declare"]); var r = this.tsTryParseIndexSignature(e); if (r) return t.body.push(r), e.abstract && this.raise(e.start, Ne.IndexSignatureHasAbstract), a && this.raise(e.start, Ne.IndexSignatureHasStatic), e.accessibility && this.raise(e.start, Ne.IndexSignatureHasAccessibility, e.accessibility), void (e.declare && this.raise(e.start, Ne.IndexSignatureHasDeclare)); n(f(i.prototype), "parseClassMemberWithIsStatic", this).call(this, t, e, s, a) } }, { key: "parsePostMemberNameModifiers", value: function (t) { this.eat(N.question) && (t.optional = !0), t.readonly && this.match(N.parenL) && this.raise(t.start, Ne.ClassMethodHasReadonly), t.declare && this.match(N.parenL) && this.raise(t.start, Ne.ClassMethodHasDeclare) } }, { key: "parseExpressionStatement", value: function (t, e) { return ("Identifier" === e.type ? this.tsParseExpressionStatement(t, e) : void 0) || n(f(i.prototype), "parseExpressionStatement", this).call(this, t, e) } }, { key: "shouldParseExportDeclaration", value: function () { return !!this.tsIsDeclarationStart() || n(f(i.prototype), "shouldParseExportDeclaration", this).call(this) } }, { key: "parseConditional", value: function (t, e, s, a) { var r = this; if (!a || !this.match(N.question)) return n(f(i.prototype), "parseConditional", this).call(this, t, e, s, a); var o = this.tryParse(function () { return n(f(i.prototype), "parseConditional", r).call(r, t, e, s) }); return o.node ? (o.error && (this.state = o.failState), o.node) : (a.start = o.error.pos || this.state.start, t) } }, { key: "parseParenItem", value: function (t, e, s) { if (t = n(f(i.prototype), "parseParenItem", this).call(this, t, e, s), this.eat(N.question) && (t.optional = !0, this.resetEndLocation(t)), this.match(N.colon)) { var a = this.startNodeAt(e, s); return a.expression = t, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression") } return t } }, { key: "parseExportDeclaration", value: function (t) { var e, s = this.state.start, a = this.state.startLoc, r = this.eatContextual("declare"); return this.match(N.name) && (e = this.tsTryParseExportDeclaration()), e || (e = n(f(i.prototype), "parseExportDeclaration", this).call(this, t)), e && ("TSInterfaceDeclaration" === e.type || "TSTypeAliasDeclaration" === e.type || r) && (t.exportKind = "type"), e && r && (this.resetStartLocation(e, s, a), e.declare = !0), e } }, { key: "parseClassId", value: function (t, e, s) { if (e && !s || !this.isContextual("implements")) { n(f(i.prototype), "parseClassId", this).call(this, t, e, s, t.declare ? it : Q); var a = this.tsTryParseTypeParameters(); a && (t.typeParameters = a) } } }, { key: "parseClassPropertyAnnotation", value: function (t) { !t.optional && this.eat(N.bang) && (t.definite = !0); var e = this.tsTryParseTypeAnnotation(); e && (t.typeAnnotation = e) } }, { key: "parseClassProperty", value: function (t) { return this.parseClassPropertyAnnotation(t), this.state.isDeclareContext && this.match(N.eq) && this.raise(this.state.start, Ne.DeclareClassFieldHasInitializer), n(f(i.prototype), "parseClassProperty", this).call(this, t) } }, { key: "parseClassPrivateProperty", value: function (t) { return t.abstract && this.raise(t.start, Ne.PrivateElementHasAbstract), t.accessibility && this.raise(t.start, Ne.PrivateElementHasAccessibility, t.accessibility), this.parseClassPropertyAnnotation(t), n(f(i.prototype), "parseClassPrivateProperty", this).call(this, t) } }, { key: "pushClassMethod", value: function (t, e, s, a, r, o) { var h = this.tsTryParseTypeParameters(); h && r && this.raise(h.start, Ne.ConstructorHasTypeParameters), h && (e.typeParameters = h), n(f(i.prototype), "pushClassMethod", this).call(this, t, e, s, a, r, o) } }, { key: "pushClassPrivateMethod", value: function (t, e, s, a) { var r = this.tsTryParseTypeParameters(); r && (e.typeParameters = r), n(f(i.prototype), "pushClassPrivateMethod", this).call(this, t, e, s, a) } }, { key: "parseClassSuper", value: function (t) { n(f(i.prototype), "parseClassSuper", this).call(this, t), t.superClass && this.isRelational("<") && (t.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (t.implements = this.tsParseHeritageClause("implements")) } }, { key: "parseObjPropValue", value: function (t) { var e, s = this.tsTryParseTypeParameters(); s && (t.typeParameters = s); for (var a = arguments.length, r = new Array(a > 1 ? a - 1 : 0), o = 1; o < a; o++)r[o - 1] = arguments[o]; (e = n(f(i.prototype), "parseObjPropValue", this)).call.apply(e, [this, t].concat(r)) } }, { key: "parseFunctionParams", value: function (t, e) { var s = this.tsTryParseTypeParameters(); s && (t.typeParameters = s), n(f(i.prototype), "parseFunctionParams", this).call(this, t, e) } }, { key: "parseVarId", value: function (t, e) { n(f(i.prototype), "parseVarId", this).call(this, t, e), "Identifier" === t.id.type && this.eat(N.bang) && (t.definite = !0); var s = this.tsTryParseTypeAnnotation(); s && (t.id.typeAnnotation = s, this.resetEndLocation(t.id)) } }, { key: "parseAsyncArrowFromCallExpression", value: function (t, e) { return this.match(N.colon) && (t.returnType = this.tsParseTypeAnnotation()), n(f(i.prototype), "parseAsyncArrowFromCallExpression", this).call(this, t, e) } }, { key: "parseMaybeAssign", value: function () { for (var t, e, s, a, r, o, h, l, p, c, u, d, m = this, y = arguments.length, v = new Array(y), x = 0; x < y; x++)v[x] = arguments[x]; if (this.match(N.jsxTagStart)) { if (l = this.state.clone(), !(p = this.tryParse(function () { var t; return (t = n(f(i.prototype), "parseMaybeAssign", m)).call.apply(t, [m].concat(v)) }, l)).error) return p.node; var { context: P } = this.state; P[P.length - 1] === Mt.j_oTag ? P.length -= 2 : P[P.length - 1] === Mt.j_expr && (P.length -= 1) } if (!(null == (t = p) ? void 0 : t.error) && !this.isRelational("<")) return (u = n(f(i.prototype), "parseMaybeAssign", this)).call.apply(u, [this].concat(v)); l = l || this.state.clone(); var k = this.tryParse(function (t) { var e, s; d = m.tsParseTypeParameters(); var a = (e = n(f(i.prototype), "parseMaybeAssign", m)).call.apply(e, [m].concat(v)); return ("ArrowFunctionExpression" !== a.type || a.extra && a.extra.parenthesized) && t(), 0 !== (null == (s = d) ? void 0 : s.params.length) && m.resetStartLocationFromNode(a, d), a.typeParameters = d, a }, l); if (!k.error && !k.aborted) return k.node; if (!p && (Ce(!this.hasPlugin("jsx")), !(c = this.tryParse(function () { var t; return (t = n(f(i.prototype), "parseMaybeAssign", m)).call.apply(t, [m].concat(v)) }, l)).error)) return c.node; if (null == (e = p) ? void 0 : e.node) return this.state = p.failState, p.node; if (k.node) return this.state = k.failState, k.node; if (null == (s = c) ? void 0 : s.node) return this.state = c.failState, c.node; if (null == (a = p) ? void 0 : a.thrown) throw p.error; if (k.thrown) throw k.error; if (null == (r = c) ? void 0 : r.thrown) throw c.error; throw (null == (o = p) ? void 0 : o.error) || k.error || (null == (h = c) ? void 0 : h.error) } }, { key: "parseMaybeUnary", value: function (t) { return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : n(f(i.prototype), "parseMaybeUnary", this).call(this, t) } }, { key: "parseArrow", value: function (t) { var e = this; if (this.match(N.colon)) { var s = this.tryParse(function (t) { var s = e.tsParseTypeOrTypePredicateAnnotation(N.colon); return !e.canInsertSemicolon() && e.match(N.arrow) || t(), s }); if (s.aborted) return; s.thrown || (s.error && (this.state = s.failState), t.returnType = s.node) } return n(f(i.prototype), "parseArrow", this).call(this, t) } }, { key: "parseAssignableListItemTypes", value: function (t) { this.eat(N.question) && ("Identifier" === t.type || this.state.isDeclareContext || this.raise(t.start, Ne.PatternIsOptional), t.optional = !0); var e = this.tsTryParseTypeAnnotation(); return e && (t.typeAnnotation = e), this.resetEndLocation(t), t } }, { key: "toAssignable", value: function (t) { switch (t.type) { case "TSTypeCastExpression": return n(f(i.prototype), "toAssignable", this).call(this, this.typeCastToParameter(t)); case "TSParameterProperty": return n(f(i.prototype), "toAssignable", this).call(this, t); case "TSAsExpression": case "TSNonNullExpression": case "TSTypeAssertion": return t.expression = this.toAssignable(t.expression), t; default: return n(f(i.prototype), "toAssignable", this).call(this, t) } } }, { key: "checkLVal", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : at, s = arguments.length > 2 ? arguments[2] : void 0, a = arguments.length > 3 ? arguments[3] : void 0; switch (t.type) { case "TSTypeCastExpression": return; case "TSParameterProperty": return void this.checkLVal(t.parameter, e, s, "parameter property"); case "TSAsExpression": case "TSNonNullExpression": case "TSTypeAssertion": return void this.checkLVal(t.expression, e, s, a); default: return void n(f(i.prototype), "checkLVal", this).call(this, t, e, s, a) } } }, { key: "parseBindingAtom", value: function () { switch (this.state.type) { case N._this: return this.parseIdentifier(!0); default: return n(f(i.prototype), "parseBindingAtom", this).call(this) } } }, { key: "parseMaybeDecoratorArguments", value: function (t) { if (this.isRelational("<")) { var e = this.tsParseTypeArguments(); if (this.match(N.parenL)) { var s = n(f(i.prototype), "parseMaybeDecoratorArguments", this).call(this, t); return s.typeParameters = e, s } this.unexpected(this.state.start, N.parenL) } return n(f(i.prototype), "parseMaybeDecoratorArguments", this).call(this, t) } }, { key: "isClassMethod", value: function () { return this.isRelational("<") || n(f(i.prototype), "isClassMethod", this).call(this) } }, { key: "isClassProperty", value: function () { return this.match(N.bang) || this.match(N.colon) || n(f(i.prototype), "isClassProperty", this).call(this) } }, { key: "parseMaybeDefault", value: function () { for (var t, e = arguments.length, s = new Array(e), a = 0; a < e; a++)s[a] = arguments[a]; var r = (t = n(f(i.prototype), "parseMaybeDefault", this)).call.apply(t, [this].concat(s)); return "AssignmentPattern" === r.type && r.typeAnnotation && r.right.start < r.typeAnnotation.start && this.raise(r.typeAnnotation.start, Ne.TypeAnnotationAfterAssign), r } }, { key: "getTokenFromCode", value: function (t) { return !this.state.inType || 62 !== t && 60 !== t ? n(f(i.prototype), "getTokenFromCode", this).call(this, t) : this.finishOp(N.relational, 1) } }, { key: "reScan_lt_gt", value: function () { if (this.match(N.relational)) { var t = this.input.charCodeAt(this.state.start); 60 !== t && 62 !== t || (this.state.pos -= 1, this.readToken_lt_gt(t)) } } }, { key: "toAssignableList", value: function (t) { for (var e = 0; e < t.length; e++) { var s = t[e]; if (s) switch (s.type) { case "TSTypeCastExpression": t[e] = this.typeCastToParameter(s); break; case "TSAsExpression": case "TSTypeAssertion": this.state.maybeInArrowParameters ? this.raise(s.start, Ne.UnexpectedTypeCastInParameter) : t[e] = this.typeCastToParameter(s) } } return n(f(i.prototype), "toAssignableList", this).apply(this, arguments) } }, { key: "typeCastToParameter", value: function (t) { return t.expression.typeAnnotation = t.typeAnnotation, this.resetEndLocation(t.expression, t.typeAnnotation.end, t.typeAnnotation.loc.end), t.expression } }, { key: "shouldParseArrow", value: function () { return this.match(N.colon) || n(f(i.prototype), "shouldParseArrow", this).call(this) } }, { key: "shouldParseAsyncArrow", value: function () { return this.match(N.colon) || n(f(i.prototype), "shouldParseAsyncArrow", this).call(this) } }, { key: "canHaveLeadingDecorator", value: function () { return n(f(i.prototype), "canHaveLeadingDecorator", this).call(this) || this.isAbstractClass() } }, { key: "jsxParseOpeningElementAfterName", value: function (t) { var e = this; if (this.isRelational("<")) { var s = this.tsTryParseAndCatch(function () { return e.tsParseTypeArguments() }); s && (t.typeParameters = s) } return n(f(i.prototype), "jsxParseOpeningElementAfterName", this).call(this, t) } }, { key: "getGetterSetterExpectedParamCount", value: function (t) { var e = n(f(i.prototype), "getGetterSetterExpectedParamCount", this).call(this, t), s = t.params[0]; return s && "Identifier" === s.type && "this" === s.name ? e + 1 : e } }, { key: "parseCatchClauseParam", value: function () { var t = n(f(i.prototype), "parseCatchClauseParam", this).call(this), e = this.tsTryParseTypeAnnotation(); return e && (t.typeAnnotation = e, this.resetEndLocation(t)), t } }, { key: "tsInDeclareContext", value: function (t) { var e = this.state.isDeclareContext; this.state.isDeclareContext = !0; try { return t() } finally { this.state.isDeclareContext = e } } }]), i }() }; N.placeholder = new A("%%", { startsExpr: !0 }); var De = function (t) { return function (e) { l(i, t); var s = c(i); function i() { return x(this, i), s.apply(this, arguments) } return v(i, [{ key: "parsePlaceholder", value: function (t) { if (this.match(N.placeholder)) { var e = this.startNode(); return this.next(), this.assertNoSpace("Unexpected space in placeholder."), e.name = n(f(i.prototype), "parseIdentifier", this).call(this, !0), this.assertNoSpace("Unexpected space in placeholder."), this.expect(N.placeholder), this.finishPlaceholder(e, t) } } }, { key: "finishPlaceholder", value: function (t, e) { var s = !(!t.expectedNode || "Placeholder" !== t.type); return t.expectedNode = e, s ? t : this.finishNode(t, "Placeholder") } }, { key: "getTokenFromCode", value: function (t) { return 37 === t && 37 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(N.placeholder, 2) : n(f(i.prototype), "getTokenFromCode", this).apply(this, arguments) } }, { key: "parseExprAtom", value: function () { return this.parsePlaceholder("Expression") || n(f(i.prototype), "parseExprAtom", this).apply(this, arguments) } }, { key: "parseIdentifier", value: function () { return this.parsePlaceholder("Identifier") || n(f(i.prototype), "parseIdentifier", this).apply(this, arguments) } }, { key: "checkReservedWord", value: function (t) { void 0 !== t && n(f(i.prototype), "checkReservedWord", this).apply(this, arguments) } }, { key: "parseBindingAtom", value: function () { return this.parsePlaceholder("Pattern") || n(f(i.prototype), "parseBindingAtom", this).apply(this, arguments) } }, { key: "checkLVal", value: function (t) { "Placeholder" !== t.type && n(f(i.prototype), "checkLVal", this).apply(this, arguments) } }, { key: "toAssignable", value: function (t) { return t && "Placeholder" === t.type && "Expression" === t.expectedNode ? (t.expectedNode = "Pattern", t) : n(f(i.prototype), "toAssignable", this).apply(this, arguments) } }, { key: "verifyBreakContinue", value: function (t) { t.label && "Placeholder" === t.label.type || n(f(i.prototype), "verifyBreakContinue", this).apply(this, arguments) } }, { key: "parseExpressionStatement", value: function (t, e) { if ("Placeholder" !== e.type || e.extra && e.extra.parenthesized) return n(f(i.prototype), "parseExpressionStatement", this).apply(this, arguments); if (this.match(N.colon)) { var s = t; return s.label = this.finishPlaceholder(e, "Identifier"), this.next(), s.body = this.parseStatement("label"), this.finishNode(s, "LabeledStatement") } return this.semicolon(), t.name = e.name, this.finishPlaceholder(t, "Statement") } }, { key: "parseBlock", value: function () { return this.parsePlaceholder("BlockStatement") || n(f(i.prototype), "parseBlock", this).apply(this, arguments) } }, { key: "parseFunctionId", value: function () { return this.parsePlaceholder("Identifier") || n(f(i.prototype), "parseFunctionId", this).apply(this, arguments) } }, { key: "parseClass", value: function (t, e, s) { var i = e ? "ClassDeclaration" : "ClassExpression"; this.next(), this.takeDecorators(t); var a = this.state.strict, r = this.parsePlaceholder("Identifier"); if (r) if (this.match(N._extends) || this.match(N.placeholder) || this.match(N.braceL)) t.id = r; else { if (s || !e) return t.id = null, t.body = this.finishPlaceholder(r, "ClassBody"), this.finishNode(t, i); this.unexpected(null, "A class name is required") } else this.parseClassId(t, e, s); return this.parseClassSuper(t), t.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!t.superClass, a), this.finishNode(t, i) } }, { key: "parseExport", value: function (t) { var e = this.parsePlaceholder("Identifier"); if (!e) return n(f(i.prototype), "parseExport", this).apply(this, arguments); if (!this.isContextual("from") && !this.match(N.comma)) return t.specifiers = [], t.source = null, t.declaration = this.finishPlaceholder(e, "Declaration"), this.finishNode(t, "ExportNamedDeclaration"); this.expectPlugin("exportDefaultFrom"); var s = this.startNode(); return s.exported = e, t.specifiers = [this.finishNode(s, "ExportDefaultSpecifier")], n(f(i.prototype), "parseExport", this).call(this, t) } }, { key: "isExportDefaultSpecifier", value: function () { if (this.match(N._default)) { var t = this.nextTokenStart(); if (this.isUnparsedContextual(t, "from") && this.input.startsWith(N.placeholder.label, this.nextTokenStartSince(t + 4))) return !0 } return n(f(i.prototype), "isExportDefaultSpecifier", this).call(this) } }, { key: "maybeParseExportDefaultSpecifier", value: function (t) { return !!(t.specifiers && t.specifiers.length > 0) || n(f(i.prototype), "maybeParseExportDefaultSpecifier", this).apply(this, arguments) } }, { key: "checkExport", value: function (t) { var { specifiers: e } = t; (null == e ? void 0 : e.length) && (t.specifiers = e.filter(function (t) { return "Placeholder" === t.exported.type })), n(f(i.prototype), "checkExport", this).call(this, t), t.specifiers = e } }, { key: "parseImport", value: function (t) { var e = this.parsePlaceholder("Identifier"); if (!e) return n(f(i.prototype), "parseImport", this).apply(this, arguments); if (t.specifiers = [], !this.isContextual("from") && !this.match(N.comma)) return t.source = this.finishPlaceholder(e, "StringLiteral"), this.semicolon(), this.finishNode(t, "ImportDeclaration"); var s = this.startNodeAtNode(e); (s.local = e, this.finishNode(s, "ImportDefaultSpecifier"), t.specifiers.push(s), this.eat(N.comma)) && (this.maybeParseStarImportSpecifier(t) || this.parseNamedImportSpecifiers(t)); return this.expectContextual("from"), t.source = this.parseImportSource(), this.semicolon(), this.finishNode(t, "ImportDeclaration") } }, { key: "parseImportSource", value: function () { return this.parsePlaceholder("StringLiteral") || n(f(i.prototype), "parseImportSource", this).apply(this, arguments) } }]), i }() }, Me = function (t) { return function (e) { l(i, t); var s = c(i); function i() { return x(this, i), s.apply(this, arguments) } return v(i, [{ key: "parseV8Intrinsic", value: function () { if (this.match(N.modulo)) { var t = this.state.start, e = this.startNode(); if (this.eat(N.modulo), this.match(N.name)) { var s = this.parseIdentifierName(this.state.start), i = this.createIdentifier(e, s); if (i.type = "V8IntrinsicIdentifier", this.match(N.parenL)) return i } this.unexpected(t) } } }, { key: "parseExprAtom", value: function () { return this.parseV8Intrinsic() || n(f(i.prototype), "parseExprAtom", this).apply(this, arguments) } }]), i }() }; function Re(t, e) { return t.some(function (t) { return Array.isArray(t) ? t[0] === e : t === e }) } function Oe(t, e, s) { var i = t.find(function (t) { return Array.isArray(t) ? t[0] === e : t === e }); return i && Array.isArray(i) ? i[1][s] : null } var Fe = ["minimal", "smart", "fsharp"], Be = ["hash", "bar"]; function _e(t) { if (Re(t, "decorators")) { if (Re(t, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together"); var e = Oe(t, "decorators", "decoratorsBeforeExport"); if (null == e) throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'."); if ("boolean" != typeof e) throw new Error("'decoratorsBeforeExport' must be a boolean.") } if (Re(t, "flow") && Re(t, "typescript")) throw new Error("Cannot combine flow and typescript plugins."); if (Re(t, "placeholders") && Re(t, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins."); if (Re(t, "pipelineOperator") && !Fe.includes(Oe(t, "pipelineOperator", "proposal"))) throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + Fe.map(function (t) { return "'".concat(t, "'") }).join(", ")); if (Re(t, "moduleAttributes")) { if (Re(t, "importAssertions")) throw new Error("Cannot combine importAssertions and moduleAttributes plugins."); if ("may-2020" !== Oe(t, "moduleAttributes", "version")) throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.") } if (Re(t, "recordAndTuple") && !Be.includes(Oe(t, "recordAndTuple", "syntaxType"))) throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + Be.map(function (t) { return "'".concat(t, "'") }).join(", ")) } var je = { estree: Lt, jsx: fe, flow: he, typescript: Le, v8intrinsic: Me, placeholders: De }, Ue = Object.keys(je), qe = { sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: !1, allowReturnOutsideFunction: !1, allowImportExportEverywhere: !1, allowSuperOutsideMethod: !1, allowUndeclaredExports: !1, plugins: [], strictMode: null, ranges: !1, tokens: !1, createParenthesizedExpressions: !1, errorRecovery: !1 }; function Ve(t) { for (var e = {}, s = 0, i = Object.keys(qe); s < i.length; s++) { var a = i[s]; e[a] = t && null != t[a] ? t[a] : qe[a] } return e } var ze = function () { function t() { x(this, t), this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.inParameters = !1, this.maybeInArrowParameters = !1, this.maybeInAsyncArrowHead = !1, this.inPipeline = !1, this.inType = !1, this.noAnonFunctionType = !1, this.inPropertyName = !1, this.hasFlowComment = !1, this.isIterator = !1, this.isDeclareContext = !1, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = !1, this.inFSharpPipelineDirectBody = !1, this.labels = [], this.decoratorStack = [[]], this.yieldPos = -1, this.awaitPos = -1, this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = N.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [Mt.braceStatement], this.exprAllowed = !0, this.containsEsc = !1, this.octalPositions = [], this.exportedIdentifiers = [], this.tokensLength = 0 } return v(t, [{ key: "init", value: function (t) { this.strict = !1 !== t.strictMode && "module" === t.sourceType, this.curLine = t.startLine, this.startLoc = this.endLoc = this.curPosition() } }, { key: "curPosition", value: function () { return new bt(this.curLine, this.pos - this.lineStart) } }, { key: "clone", value: function (e) { for (var s = new t, i = Object.keys(this), a = 0, r = i.length; a < r; a++) { var n = i[a], o = this[n]; !e && Array.isArray(o) && (o = o.slice()), s[n] = o } return s } }]), t }(), He = function (t) { return t >= 48 && t <= 57 }, Ke = new Set(["g", "m", "s", "i", "y", "u"]), We = { decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120] }, Je = { bin: [48, 49] }; Je.oct = [].concat(t(Je.bin), [50, 51, 52, 53, 54, 55]), Je.dec = [].concat(t(Je.oct), [56, 57]), Je.hex = [].concat(t(Je.dec), [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]); var Xe = function t(e) { x(this, t), this.type = void 0, this.value = void 0, this.start = void 0, this.end = void 0, this.loc = void 0, this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, this.loc = new Tt(e.startLoc, e.endLoc) }, Ge = function (t) { l(s, Nt); var e = c(s); function s(t, i) { var a; return x(this, s), (a = e.call(this)).isLookahead = void 0, a.tokens = [], a.state = new ze, a.state.init(t), a.input = i, a.length = i.length, a.isLookahead = !1, a } return v(s, [{ key: "pushToken", value: function (t) { this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength } }, { key: "next", value: function () { this.isLookahead || (this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Xe(this.state))), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken() } }, { key: "eat", value: function (t) { return !!this.match(t) && (this.next(), !0) } }, { key: "match", value: function (t) { return this.state.type === t } }, { key: "lookahead", value: function () { var t = this.state; this.state = t.clone(!0), this.isLookahead = !0, this.next(), this.isLookahead = !1; var e = this.state; return this.state = t, e } }, { key: "nextTokenStart", value: function () { return this.nextTokenStartSince(this.state.pos) } }, { key: "nextTokenStartSince", value: function (t) { return kt.lastIndex = t, t + kt.exec(this.input)[0].length } }, { key: "lookaheadCharCode", value: function () { return this.input.charCodeAt(this.nextTokenStart()) } }, { key: "setStrict", value: function (t) { if (this.state.strict = t, this.match(N.num) || this.match(N.string)) { for (this.state.pos = this.state.start; this.state.pos < this.state.lineStart;)this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1, --this.state.curLine; this.nextToken() } } }, { key: "curContext", value: function () { return this.state.context[this.state.context.length - 1] } }, { key: "nextToken", value: function () { var t = this.curContext(); if ((null == t ? void 0 : t.preserveSpace) || this.skipSpace(), this.state.octalPositions = [], this.state.start = this.state.pos, this.state.startLoc = this.state.curPosition(), this.state.pos >= this.length) this.finishToken(N.eof); else { var e = null == t ? void 0 : t.override; e ? e(this) : this.getTokenFromCode(this.input.codePointAt(this.state.pos)) } } }, { key: "pushComment", value: function (t, e, s, i, a, r) { var n = { type: t ? "CommentBlock" : "CommentLine", value: e, start: s, end: i, loc: new Tt(a, r) }; this.options.tokens && this.pushToken(n), this.state.comments.push(n), this.addComment(n) } }, { key: "skipBlockComment", value: function () { var t, e = this.state.curPosition(), s = this.state.pos, i = this.input.indexOf("*/", this.state.pos + 2); if (-1 === i) throw this.raise(s, Ct.UnterminatedComment); for (this.state.pos = i + 2, xt.lastIndex = s; (t = xt.exec(this.input)) && t.index < this.state.pos;)++this.state.curLine, this.state.lineStart = t.index + t[0].length; this.isLookahead || this.pushComment(!0, this.input.slice(s + 2, i), s, this.state.pos, e, this.state.curPosition()) } }, { key: "skipLineComment", value: function (t) { var e = this.state.pos, s = this.state.curPosition(), i = this.input.charCodeAt(this.state.pos += t); if (this.state.pos < this.length) for (; !Pt(i) && ++this.state.pos < this.length;)i = this.input.charCodeAt(this.state.pos); this.isLookahead || this.pushComment(!1, this.input.slice(e + t, this.state.pos), e, this.state.pos, s, this.state.curPosition()) } }, { key: "skipSpace", value: function () { t: for (; this.state.pos < this.length;) { var t = this.input.charCodeAt(this.state.pos); switch (t) { case 32: case 160: case 9: ++this.state.pos; break; case 13: 10 === this.input.charCodeAt(this.state.pos + 1) && ++this.state.pos; case 10: case 8232: case 8233: ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos; break; case 47: switch (this.input.charCodeAt(this.state.pos + 1)) { case 42: this.skipBlockComment(); break; case 47: this.skipLineComment(2); break; default: break t }break; default: if (!gt(t)) break t; ++this.state.pos } } } }, { key: "finishToken", value: function (t, e) { this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition(); var s = this.state.type; this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s) } }, { key: "readToken_numberSign", value: function () { if (0 !== this.state.pos || !this.readToken_interpreter()) { var t = this.state.pos + 1, e = this.input.charCodeAt(t); if (e >= 48 && e <= 57) throw this.raise(this.state.pos, Ct.UnexpectedDigitAfterHash); if (123 === e || 91 === e && this.hasPlugin("recordAndTuple")) { if (this.expectPlugin("recordAndTuple"), "hash" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, 123 === e ? Ct.RecordExpressionHashIncorrectStartSyntaxType : Ct.TupleExpressionHashIncorrectStartSyntaxType); 123 === e ? this.finishToken(N.braceHashL) : this.finishToken(N.bracketHashL), this.state.pos += 2 } else this.finishOp(N.hash, 1) } } }, { key: "readToken_dot", value: function () { var t = this.input.charCodeAt(this.state.pos + 1); t >= 48 && t <= 57 ? this.readNumber(!0) : 46 === t && 46 === this.input.charCodeAt(this.state.pos + 2) ? (this.state.pos += 3, this.finishToken(N.ellipsis)) : (++this.state.pos, this.finishToken(N.dot)) } }, { key: "readToken_slash", value: function () { if (this.state.exprAllowed && !this.state.inType) return ++this.state.pos, void this.readRegexp(); 61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(N.assign, 2) : this.finishOp(N.slash, 1) } }, { key: "readToken_interpreter", value: function () { if (0 !== this.state.pos || this.length < 2) return !1; var t = this.input.charCodeAt(this.state.pos + 1); if (33 !== t) return !1; var e = this.state.pos; for (this.state.pos += 1; !Pt(t) && ++this.state.pos < this.length;)t = this.input.charCodeAt(this.state.pos); var s = this.input.slice(e + 2, this.state.pos); return this.finishToken(N.interpreterDirective, s), !0 } }, { key: "readToken_mult_modulo", value: function (t) { var e = 42 === t ? N.star : N.modulo, s = 1, i = this.input.charCodeAt(this.state.pos + 1), a = this.state.exprAllowed; 42 === t && 42 === i && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = N.exponent), 61 !== i || a || (s++, e = N.assign), this.finishOp(e, s) } }, { key: "readToken_pipe_amp", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1); if (e !== t) { if (124 === t) { if (62 === e) return void this.finishOp(N.pipeline, 2); if (this.hasPlugin("recordAndTuple") && 125 === e) { if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, Ct.RecordExpressionBarIncorrectEndSyntaxType); return void this.finishOp(N.braceBarR, 2) } if (this.hasPlugin("recordAndTuple") && 93 === e) { if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, Ct.TupleExpressionBarIncorrectEndSyntaxType); return void this.finishOp(N.bracketBarR, 2) } } 61 !== e ? this.finishOp(124 === t ? N.bitwiseOR : N.bitwiseAND, 1) : this.finishOp(N.assign, 2) } else 61 === this.input.charCodeAt(this.state.pos + 2) ? this.finishOp(N.assign, 3) : this.finishOp(124 === t ? N.logicalOR : N.logicalAND, 2) } }, { key: "readToken_caret", value: function () { 61 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(N.assign, 2) : this.finishOp(N.bitwiseXOR, 1) } }, { key: "readToken_plus_min", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1); if (e === t) return 45 !== e || this.inModule || 62 !== this.input.charCodeAt(this.state.pos + 2) || 0 !== this.state.lastTokEnd && !this.hasPrecedingLineBreak() ? void this.finishOp(N.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken()); 61 === e ? this.finishOp(N.assign, 2) : this.finishOp(N.plusMin, 1) } }, { key: "readToken_lt_gt", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1), s = 1; return e === t ? (s = 62 === t && 62 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2, 61 === this.input.charCodeAt(this.state.pos + s) ? void this.finishOp(N.assign, s + 1) : void this.finishOp(N.bitShift, s)) : 33 !== e || 60 !== t || this.inModule || 45 !== this.input.charCodeAt(this.state.pos + 2) || 45 !== this.input.charCodeAt(this.state.pos + 3) ? (61 === e && (s = 2), void this.finishOp(N.relational, s)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken()) } }, { key: "readToken_eq_excl", value: function (t) { var e = this.input.charCodeAt(this.state.pos + 1); if (61 !== e) return 61 === t && 62 === e ? (this.state.pos += 2, void this.finishToken(N.arrow)) : void this.finishOp(61 === t ? N.eq : N.bang, 1); this.finishOp(N.equality, 61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2) } }, { key: "readToken_question", value: function () { var t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2); 63 === t ? 61 === e ? this.finishOp(N.assign, 3) : this.finishOp(N.nullishCoalescing, 2) : 46 !== t || e >= 48 && e <= 57 ? (++this.state.pos, this.finishToken(N.question)) : (this.state.pos += 2, this.finishToken(N.questionDot)) } }, { key: "getTokenFromCode", value: function (t) { switch (t) { case 46: return void this.readToken_dot(); case 40: return ++this.state.pos, void this.finishToken(N.parenL); case 41: return ++this.state.pos, void this.finishToken(N.parenR); case 59: return ++this.state.pos, void this.finishToken(N.semi); case 44: return ++this.state.pos, void this.finishToken(N.comma); case 91: if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) { if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, Ct.TupleExpressionBarIncorrectStartSyntaxType); this.finishToken(N.bracketBarL), this.state.pos += 2 } else ++this.state.pos, this.finishToken(N.bracketL); return; case 93: return ++this.state.pos, void this.finishToken(N.bracketR); case 123: if (this.hasPlugin("recordAndTuple") && 124 === this.input.charCodeAt(this.state.pos + 1)) { if ("bar" !== this.getPluginOption("recordAndTuple", "syntaxType")) throw this.raise(this.state.pos, Ct.RecordExpressionBarIncorrectStartSyntaxType); this.finishToken(N.braceBarL), this.state.pos += 2 } else ++this.state.pos, this.finishToken(N.braceL); return; case 125: return ++this.state.pos, void this.finishToken(N.braceR); case 58: return void (this.hasPlugin("functionBind") && 58 === this.input.charCodeAt(this.state.pos + 1) ? this.finishOp(N.doubleColon, 2) : (++this.state.pos, this.finishToken(N.colon))); case 63: return void this.readToken_question(); case 96: return ++this.state.pos, void this.finishToken(N.backQuote); case 48: var e = this.input.charCodeAt(this.state.pos + 1); if (120 === e || 88 === e) return void this.readRadixNumber(16); if (111 === e || 79 === e) return void this.readRadixNumber(8); if (98 === e || 66 === e) return void this.readRadixNumber(2); case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: return void this.readNumber(!1); case 34: case 39: return void this.readString(t); case 47: return void this.readToken_slash(); case 37: case 42: return void this.readToken_mult_modulo(t); case 124: case 38: return void this.readToken_pipe_amp(t); case 94: return void this.readToken_caret(); case 43: case 45: return void this.readToken_plus_min(t); case 60: case 62: return void this.readToken_lt_gt(t); case 61: case 33: return void this.readToken_eq_excl(t); case 126: return void this.finishOp(N.tilde, 1); case 64: return ++this.state.pos, void this.finishToken(N.at); case 35: return void this.readToken_numberSign(); case 92: return void this.readWord(); default: if (qt(t)) return void this.readWord() }throw this.raise(this.state.pos, Ct.InvalidOrUnexpectedToken, String.fromCodePoint(t)) } }, { key: "finishOp", value: function (t, e) { var s = this.input.slice(this.state.pos, this.state.pos + e); this.state.pos += e, this.finishToken(t, s) } }, { key: "readRegexp", value: function () { for (var t, e, s = this.state.pos; ;) { if (this.state.pos >= this.length) throw this.raise(s, Ct.UnterminatedRegExp); var i = this.input.charAt(this.state.pos); if (vt.test(i)) throw this.raise(s, Ct.UnterminatedRegExp); if (t) t = !1; else { if ("[" === i) e = !0; else if ("]" === i && e) e = !1; else if ("/" === i && !e) break; t = "\\" === i } ++this.state.pos } var a = this.input.slice(s, this.state.pos); ++this.state.pos; for (var r = ""; this.state.pos < this.length;) { var n = this.input[this.state.pos], o = this.input.codePointAt(this.state.pos); if (Ke.has(n)) r.indexOf(n) > -1 && this.raise(this.state.pos + 1, Ct.DuplicateRegExpFlags); else { if (!Vt(o) && 92 !== o) break; this.raise(this.state.pos + 1, Ct.MalformedRegExpFlags) } ++this.state.pos, r += n } this.finishToken(N.regexp, { pattern: a, flags: r }) } }, { key: "readInt", value: function (t, e, s) { for (var i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a = this.state.pos, r = 16 === t ? We.hex : We.decBinOct, n = 16 === t ? Je.hex : 10 === t ? Je.dec : 8 === t ? Je.oct : Je.bin, o = !1, h = 0, l = 0, p = null == e ? 1 / 0 : e; l < p; ++l) { var c = this.input.charCodeAt(this.state.pos), u = void 0; if (95 !== c) { if ((u = c >= 97 ? c - 97 + 10 : c >= 65 ? c - 65 + 10 : He(c) ? c - 48 : 1 / 0) >= t) if (this.options.errorRecovery && u <= 9) u = 0, this.raise(this.state.start + l + 2, Ct.InvalidDigit, t); else { if (!s) break; u = 0, o = !0 } ++this.state.pos, h = h * t + u } else { var d = this.input.charCodeAt(this.state.pos - 1), m = this.input.charCodeAt(this.state.pos + 1); -1 === n.indexOf(m) ? this.raise(this.state.pos, Ct.UnexpectedNumericSeparator) : (r.indexOf(d) > -1 || r.indexOf(m) > -1 || Number.isNaN(m)) && this.raise(this.state.pos, Ct.UnexpectedNumericSeparator), i || this.raise(this.state.pos, Ct.NumericSeparatorInEscapeSequence), ++this.state.pos } } return this.state.pos === a || null != e && this.state.pos - a !== e || o ? null : h } }, { key: "readRadixNumber", value: function (t) { var e = this.state.pos, s = !1; this.state.pos += 2; var i = this.readInt(t); null == i && this.raise(this.state.start + 2, Ct.InvalidDigit, t); var a = this.input.charCodeAt(this.state.pos); if (110 === a) ++this.state.pos, s = !0; else if (109 === a) throw this.raise(e, Ct.InvalidDecimal); if (qt(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, Ct.NumberIdentifier); if (s) { var r = this.input.slice(e, this.state.pos).replace(/[_n]/g, ""); this.finishToken(N.bigint, r) } else this.finishToken(N.num, i) } }, { key: "readNumber", value: function (t) { var e = this.state.pos, s = !1, i = !1, a = !1, r = !1, n = !1; t || null !== this.readInt(10) || this.raise(e, Ct.InvalidNumber); var o = this.state.pos - e >= 2 && 48 === this.input.charCodeAt(e); if (o) { var h = this.input.slice(e, this.state.pos); if (this.state.strict) this.raise(e, Ct.StrictOctalLiteral); else { var l = h.indexOf("_"); l > 0 && this.raise(l + e, Ct.ZeroDigitNumericSeparator) } n = o && !/[89]/.test(h) } var p = this.input.charCodeAt(this.state.pos); if (46 !== p || n || (++this.state.pos, this.readInt(10), s = !0, p = this.input.charCodeAt(this.state.pos)), 69 !== p && 101 !== p || n || (43 !== (p = this.input.charCodeAt(++this.state.pos)) && 45 !== p || ++this.state.pos, null === this.readInt(10) && this.raise(e, Ct.InvalidOrMissingExponent), s = !0, r = !0, p = this.input.charCodeAt(this.state.pos)), 110 === p && ((s || o) && this.raise(e, Ct.InvalidBigIntLiteral), ++this.state.pos, i = !0), 109 === p && (this.expectPlugin("decimal", this.state.pos), (r || o) && this.raise(e, Ct.InvalidDecimal), ++this.state.pos, a = !0), qt(this.input.codePointAt(this.state.pos))) throw this.raise(this.state.pos, Ct.NumberIdentifier); var c = this.input.slice(e, this.state.pos).replace(/[_mn]/g, ""); if (i) this.finishToken(N.bigint, c); else if (a) this.finishToken(N.decimal, c); else { var u = n ? parseInt(c, 8) : parseFloat(c); this.finishToken(N.num, u) } } }, { key: "readCodePoint", value: function (t) { var e; if (123 === this.input.charCodeAt(this.state.pos)) { var s = ++this.state.pos; if (e = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, !0, t), ++this.state.pos, null !== e && e > 1114111) { if (!t) return null; this.raise(s, Ct.InvalidCodePoint) } } else e = this.readHexChar(4, !1, t); return e } }, { key: "readString", value: function (t) { for (var e = "", s = ++this.state.pos; ;) { if (this.state.pos >= this.length) throw this.raise(this.state.start, Ct.UnterminatedString); var i = this.input.charCodeAt(this.state.pos); if (i === t) break; if (92 === i) e += this.input.slice(s, this.state.pos), e += this.readEscapedChar(!1), s = this.state.pos; else if (8232 === i || 8233 === i) ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos; else { if (Pt(i)) throw this.raise(this.state.start, Ct.UnterminatedString); ++this.state.pos } } e += this.input.slice(s, this.state.pos++), this.finishToken(N.string, e) } }, { key: "readTmplToken", value: function () { for (var t = "", e = this.state.pos, s = !1; ;) { if (this.state.pos >= this.length) throw this.raise(this.state.start, Ct.UnterminatedTemplate); var i = this.input.charCodeAt(this.state.pos); if (96 === i || 36 === i && 123 === this.input.charCodeAt(this.state.pos + 1)) return this.state.pos === this.state.start && this.match(N.template) ? 36 === i ? (this.state.pos += 2, void this.finishToken(N.dollarBraceL)) : (++this.state.pos, void this.finishToken(N.backQuote)) : (t += this.input.slice(e, this.state.pos), void this.finishToken(N.template, s ? null : t)); if (92 === i) { t += this.input.slice(e, this.state.pos); var a = this.readEscapedChar(!0); null === a ? s = !0 : t += a, e = this.state.pos } else if (Pt(i)) { switch (t += this.input.slice(e, this.state.pos), ++this.state.pos, i) { case 13: 10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos; case 10: t += "\n"; break; default: t += String.fromCharCode(i) }++this.state.curLine, this.state.lineStart = this.state.pos, e = this.state.pos } else ++this.state.pos } } }, { key: "readEscapedChar", value: function (t) { var e = !t, s = this.input.charCodeAt(++this.state.pos); switch (++this.state.pos, s) { case 110: return "\n"; case 114: return "\r"; case 120: var i = this.readHexChar(2, !1, e); return null === i ? null : String.fromCharCode(i); case 117: var a = this.readCodePoint(e); return null === a ? null : String.fromCodePoint(a); case 116: return "\t"; case 98: return "\b"; case 118: return "\v"; case 102: return "\f"; case 13: 10 === this.input.charCodeAt(this.state.pos) && ++this.state.pos; case 10: this.state.lineStart = this.state.pos, ++this.state.curLine; case 8232: case 8233: return ""; case 56: case 57: if (t) return null; this.state.strict && this.raise(this.state.pos - 1, Ct.StrictNumericEscape); default: if (s >= 48 && s <= 55) { var r = this.state.pos - 1, n = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], o = parseInt(n, 8); o > 255 && (n = n.slice(0, -1), o = parseInt(n, 8)), this.state.pos += n.length - 1; var h = this.input.charCodeAt(this.state.pos); if ("0" !== n || 56 === h || 57 === h) { if (t) return null; this.state.strict ? this.raise(r, Ct.StrictNumericEscape) : this.state.octalPositions.push(r) } return String.fromCharCode(o) } return String.fromCharCode(s) } } }, { key: "readHexChar", value: function (t, e, s) { var i = this.state.pos, a = this.readInt(16, t, e, !1); return null === a && (s ? this.raise(i, Ct.InvalidEscapeSequence) : this.state.pos = i - 1), a } }, { key: "readWord1", value: function () { var t = ""; this.state.containsEsc = !1; for (var e = this.state.pos, s = this.state.pos; this.state.pos < this.length;) { var i = this.input.codePointAt(this.state.pos); if (Vt(i)) this.state.pos += i <= 65535 ? 1 : 2; else if (this.state.isIterator && 64 === i) ++this.state.pos; else { if (92 !== i) break; this.state.containsEsc = !0, t += this.input.slice(s, this.state.pos); var a = this.state.pos, r = this.state.pos === e ? qt : Vt; if (117 !== this.input.charCodeAt(++this.state.pos)) { this.raise(this.state.pos, Ct.MissingUnicodeEscape); continue } ++this.state.pos; var n = this.readCodePoint(!0); null !== n && (r(n) || this.raise(a, Ct.EscapedCharNotAnIdentifier), t += String.fromCodePoint(n)), s = this.state.pos } } return t + this.input.slice(s, this.state.pos) } }, { key: "isIterator", value: function (t) { return "@@iterator" === t || "@@asyncIterator" === t } }, { key: "readWord", value: function () { var t = this.readWord1(), e = E.get(t) || N.name; !this.state.isIterator || this.isIterator(t) && this.state.inType || this.raise(this.state.pos, Ct.InvalidIdentifier, t), this.finishToken(e, t) } }, { key: "checkKeywordEscapes", value: function () { var t = this.state.type.keyword; t && this.state.containsEsc && this.raise(this.state.start, Ct.InvalidEscapedReservedWord, t) } }, { key: "braceIsBlock", value: function (t) { var e = this.curContext(); return e === Mt.functionExpression || e === Mt.functionStatement || (t !== N.colon || e !== Mt.braceStatement && e !== Mt.braceExpression ? t === N._return || t === N.name && this.state.exprAllowed ? this.hasPrecedingLineBreak() : t === N._else || t === N.semi || t === N.eof || t === N.parenR || t === N.arrow || (t === N.braceL ? e === Mt.braceStatement : t !== N._var && t !== N._const && t !== N.name && (t === N.relational || !this.state.exprAllowed)) : !e.isExpr) } }, { key: "updateContext", value: function (t) { var e, s = this.state.type; !s.keyword || t !== N.dot && t !== N.questionDot ? (e = s.updateContext) ? e.call(this, t) : this.state.exprAllowed = s.beforeExpr : this.state.exprAllowed = !1 } }]), s }(), Qe = function (t) { l(s, Ge); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "addExtra", value: function (t, e, s) { t && ((t.extra = t.extra || {})[e] = s) } }, { key: "isRelational", value: function (t) { return this.match(N.relational) && this.state.value === t } }, { key: "expectRelational", value: function (t) { this.isRelational(t) ? this.next() : this.unexpected(null, N.relational) } }, { key: "isContextual", value: function (t) { return this.match(N.name) && this.state.value === t && !this.state.containsEsc } }, { key: "isUnparsedContextual", value: function (t, e) { var s = t + e.length; return this.input.slice(t, s) === e && (s === this.input.length || !Vt(this.input.charCodeAt(s))) } }, { key: "isLookaheadContextual", value: function (t) { var e = this.nextTokenStart(); return this.isUnparsedContextual(e, t) } }, { key: "eatContextual", value: function (t) { return this.isContextual(t) && this.eat(N.name) } }, { key: "expectContextual", value: function (t, e) { this.eatContextual(t) || this.unexpected(null, e) } }, { key: "canInsertSemicolon", value: function () { return this.match(N.eof) || this.match(N.braceR) || this.hasPrecedingLineBreak() } }, { key: "hasPrecedingLineBreak", value: function () { return vt.test(this.input.slice(this.state.lastTokEnd, this.state.start)) } }, { key: "isLineTerminator", value: function () { return this.eat(N.semi) || this.canInsertSemicolon() } }, { key: "semicolon", value: function () { this.isLineTerminator() || this.unexpected(null, N.semi) } }, { key: "expect", value: function (t, e) { this.eat(t) || this.unexpected(e, t) } }, { key: "assertNoSpace", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "Unexpected space."; this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, t) } }, { key: "unexpected", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "Unexpected token"; throw "string" != typeof e && (e = 'Unexpected token, expected "'.concat(e.label, '"')), this.raise(null != t ? t : this.state.start, e) } }, { key: "expectPlugin", value: function (t, e) { if (!this.hasPlugin(t)) throw this.raiseWithData(null != e ? e : this.state.start, { missingPlugin: [t] }, "This experimental syntax requires enabling the parser plugin: '".concat(t, "'")); return !0 } }, { key: "expectOnePlugin", value: function (t, e) { var s = this; if (!t.some(function (t) { return s.hasPlugin(t) })) throw this.raiseWithData(null != e ? e : this.state.start, { missingPlugin: t }, "This experimental syntax requires enabling one of the following parser plugin(s): '".concat(t.join(", "), "'")) } }, { key: "checkYieldAwaitInDefaultParams", value: function () { -1 !== this.state.yieldPos && (-1 === this.state.awaitPos || this.state.yieldPos < this.state.awaitPos) && this.raise(this.state.yieldPos, Ct.YieldBindingIdentifier), -1 !== this.state.awaitPos && this.raise(this.state.awaitPos, Ct.AwaitBindingIdentifier) } }, { key: "tryParse", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.clone(), s = { node: null }; try { var i = t(function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; throw s.node = t, s }); if (this.state.errors.length > e.errors.length) { var a = this.state; return this.state = e, { node: i, error: a.errors[e.errors.length], thrown: !1, aborted: !1, failState: a } } return { node: i, error: null, thrown: !1, aborted: !1, failState: null } } catch (n) { var r = this.state; if (this.state = e, n instanceof SyntaxError) return { node: null, error: n, thrown: !0, aborted: !1, failState: r }; if (n === s) return { node: s.node, error: null, thrown: !1, aborted: !0, failState: r }; throw n } } }, { key: "checkExpressionErrors", value: function (t, e) { if (!t) return !1; var { shorthandAssign: s, doubleProto: i } = t; if (!e) return s >= 0 || i >= 0; s >= 0 && this.unexpected(s), i >= 0 && this.raise(i, Ct.DuplicateProto) } }, { key: "isLiteralPropertyName", value: function () { return this.match(N.name) || !!this.state.type.keyword || this.match(N.string) || this.match(N.num) || this.match(N.bigint) || this.match(N.decimal) } }]), s }(), Ye = function t() { x(this, t), this.shorthandAssign = -1, this.doubleProto = -1 }, $e = function () { function t(e, s, i) { x(this, t), this.type = void 0, this.start = void 0, this.end = void 0, this.loc = void 0, this.range = void 0, this.leadingComments = void 0, this.trailingComments = void 0, this.innerComments = void 0, this.extra = void 0, this.type = "", this.start = s, this.end = 0, this.loc = new Tt(i), (null == e ? void 0 : e.options.ranges) && (this.range = [s, 0]), (null == e ? void 0 : e.filename) && (this.loc.filename = e.filename) } return v(t, [{ key: "__clone", value: function () { for (var e = new t, s = Object.keys(this), i = 0, a = s.length; i < a; i++) { var r = s[i]; "leadingComments" !== r && "trailingComments" !== r && "innerComments" !== r && (e[r] = this[r]) } return e } }]), t }(), Ze = function (t) { l(s, Qe); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "startNode", value: function () { return new $e(this, this.state.start, this.state.startLoc) } }, { key: "startNodeAt", value: function (t, e) { return new $e(this, t, e) } }, { key: "startNodeAtNode", value: function (t) { return this.startNodeAt(t.start, t.loc.start) } }, { key: "finishNode", value: function (t, e) { return this.finishNodeAt(t, e, this.state.lastTokEnd, this.state.lastTokEndLoc) } }, { key: "finishNodeAt", value: function (t, e, s, i) { return t.type = e, t.end = s, t.loc.end = i, this.options.ranges && (t.range[1] = s), this.processComment(t), t } }, { key: "resetStartLocation", value: function (t, e, s) { t.start = e, t.loc.start = s, this.options.ranges && (t.range[0] = e) } }, { key: "resetEndLocation", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.state.lastTokEnd, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.state.lastTokEndLoc; t.end = e, t.loc.end = s, this.options.ranges && (t.range[1] = e) } }, { key: "resetStartLocationFromNode", value: function (t, e) { this.resetStartLocation(t, e.start, e.loc.start) } }]), s }(), ts = function (t) { return "ParenthesizedExpression" === t.type ? ts(t.expression) : t }, es = function (t) { l(s, Ze); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "toAssignable", value: function (t) { var e, s, i = void 0; switch (("ParenthesizedExpression" === t.type || (null == (e = t.extra) ? void 0 : e.parenthesized)) && "Identifier" !== (i = ts(t)).type && "MemberExpression" !== i.type && this.raise(t.start, Ct.InvalidParenthesizedAssignment), t.type) { case "Identifier": case "ObjectPattern": case "ArrayPattern": case "AssignmentPattern": break; case "ObjectExpression": t.type = "ObjectPattern"; for (var a = 0, r = t.properties.length, n = r - 1; a < r; a++) { var o, h = t.properties[a], l = a === n; this.toAssignableObjectExpressionProp(h, l), l && "RestElement" === h.type && (null == (o = t.extra) ? void 0 : o.trailingComma) && this.raiseRestNotLast(t.extra.trailingComma) } break; case "ObjectProperty": this.toAssignable(t.value); break; case "SpreadElement": this.checkToRestConversion(t), t.type = "RestElement"; var p = t.argument; this.toAssignable(p); break; case "ArrayExpression": t.type = "ArrayPattern", this.toAssignableList(t.elements, null == (s = t.extra) ? void 0 : s.trailingComma); break; case "AssignmentExpression": "=" !== t.operator && this.raise(t.left.end, Ct.MissingEqInAssignment), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left); break; case "ParenthesizedExpression": this.toAssignable(i) }return t } }, { key: "toAssignableObjectExpressionProp", value: function (t, e) { if ("ObjectMethod" === t.type) { var s = "get" === t.kind || "set" === t.kind ? Ct.PatternHasAccessor : Ct.PatternHasMethod; this.raise(t.key.start, s) } else "SpreadElement" !== t.type || e ? this.toAssignable(t) : this.raiseRestNotLast(t.start) } }, { key: "toAssignableList", value: function (t, e) { var s = t.length; if (s) { var i = t[s - 1]; if ("RestElement" === (null == i ? void 0 : i.type)) --s; else if ("SpreadElement" === (null == i ? void 0 : i.type)) { i.type = "RestElement"; var a = i.argument; this.toAssignable(a), "Identifier" !== a.type && "MemberExpression" !== a.type && "ArrayPattern" !== a.type && "ObjectPattern" !== a.type && this.unexpected(a.start), e && this.raiseTrailingCommaAfterRest(e), --s } } for (var r = 0; r < s; r++) { var n = t[r]; n && (this.toAssignable(n), "RestElement" === n.type && this.raiseRestNotLast(n.start)) } return t } }, { key: "toReferencedList", value: function (t, e) { return t } }, { key: "toReferencedListDeep", value: function (t, e) { this.toReferencedList(t, e); for (var s = 0; s < t.length; s++) { var i = t[s]; "ArrayExpression" === (null == i ? void 0 : i.type) && this.toReferencedListDeep(i.elements) } } }, { key: "parseSpread", value: function (t, e) { var s = this.startNode(); return this.next(), s.argument = this.parseMaybeAssignAllowIn(t, void 0, e), this.finishNode(s, "SpreadElement") } }, { key: "parseRestBinding", value: function () { var t = this.startNode(); return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement") } }, { key: "parseBindingAtom", value: function () { switch (this.state.type) { case N.bracketL: var t = this.startNode(); return this.next(), t.elements = this.parseBindingList(N.bracketR, 93, !0), this.finishNode(t, "ArrayPattern"); case N.braceL: return this.parseObjectLike(N.braceR, !0) }return this.parseIdentifier() } }, { key: "parseBindingList", value: function (t, e, s, i) { for (var a = [], r = !0; !this.eat(t);)if (r ? r = !1 : this.expect(N.comma), s && this.match(N.comma)) a.push(null); else { if (this.eat(t)) break; if (this.match(N.ellipsis)) { a.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(e), this.expect(t); break } var n = []; for (this.match(N.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Ct.UnsupportedParameterDecorator); this.match(N.at);)n.push(this.parseDecorator()); a.push(this.parseAssignableListItem(i, n)) } return a } }, { key: "parseAssignableListItem", value: function (t, e) { var s = this.parseMaybeDefault(); this.parseAssignableListItemTypes(s); var i = this.parseMaybeDefault(s.start, s.loc.start, s); return e.length && (s.decorators = e), i } }, { key: "parseAssignableListItemTypes", value: function (t) { return t } }, { key: "parseMaybeDefault", value: function (t, e, s) { var i, a, r; if (e = null != (i = e) ? i : this.state.startLoc, t = null != (a = t) ? a : this.state.start, s = null != (r = s) ? r : this.parseBindingAtom(), !this.eat(N.eq)) return s; var n = this.startNodeAt(t, e); return n.left = s, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern") } }, { key: "checkLVal", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : at, s = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0, a = arguments.length > 4 ? arguments[4] : void 0, r = arguments.length > 5 && void 0 !== arguments[5] && arguments[5]; switch (t.type) { case "Identifier": if (this.state.strict && (r ? Qt(t.name, this.inModule) : Gt(t.name)) && this.raise(t.start, e === at ? Ct.StrictEvalArguments : Ct.StrictEvalArgumentsBinding, t.name), s) { var n = "_".concat(t.name); s[n] ? this.raise(t.start, Ct.ParamDupe) : s[n] = !0 } a && "let" === t.name && this.raise(t.start, Ct.LetInLexicalBinding), e & at || this.scope.declareName(t.name, e, t.start); break; case "MemberExpression": e !== at && this.raise(t.start, Ct.InvalidPropertyBindingPattern); break; case "ObjectPattern": for (var o = 0, h = t.properties; o < h.length; o++) { var l = h[o]; if ("ObjectProperty" === l.type) l = l.value; else if ("ObjectMethod" === l.type) continue; this.checkLVal(l, e, s, "object destructuring pattern", a) } break; case "ArrayPattern": for (var p = 0, c = t.elements; p < c.length; p++) { var u = c[p]; u && this.checkLVal(u, e, s, "array destructuring pattern", a) } break; case "AssignmentPattern": this.checkLVal(t.left, e, s, "assignment pattern"); break; case "RestElement": this.checkLVal(t.argument, e, s, "rest element"); break; case "ParenthesizedExpression": this.checkLVal(t.expression, e, s, "parenthesized expression"); break; default: this.raise(t.start, e === at ? Ct.InvalidLhs : Ct.InvalidLhsBinding, i) } } }, { key: "checkToRestConversion", value: function (t) { "Identifier" !== t.argument.type && "MemberExpression" !== t.argument.type && this.raise(t.argument.start, Ct.InvalidRestAssignmentPattern) } }, { key: "checkCommaAfterRest", value: function (t) { this.match(N.comma) && (this.lookaheadCharCode() === t ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start)) } }, { key: "raiseRestNotLast", value: function (t) { throw this.raise(t, Ct.ElementAfterRest) } }, { key: "raiseTrailingCommaAfterRest", value: function (t) { this.raise(t, Ct.RestTrailingComma) } }]), s }(), ss = function (t) { l(s, es); var e = c(s); function s() { return x(this, s), e.apply(this, arguments) } return v(s, [{ key: "checkProto", value: function (t, e, s, i) { if ("SpreadElement" !== t.type && "ObjectMethod" !== t.type && !t.computed && !t.shorthand) { var a = t.key; if ("__proto__" === ("Identifier" === a.type ? a.name : a.value)) { if (e) return void this.raise(a.start, Ct.RecordNoProto); s.used && (i ? -1 === i.doubleProto && (i.doubleProto = a.start) : this.raise(a.start, Ct.DuplicateProto)), s.used = !0 } } } }, { key: "shouldExitDescending", value: function (t, e) { return "ArrowFunctionExpression" === t.type && t.start === e } }, { key: "getExpression", value: function () { var t = ke; this.hasPlugin("topLevelAwait") && this.inModule && (t |= be), this.scope.enter(L), this.prodParam.enter(t), this.nextToken(); var e = this.parseExpression(); return this.match(N.eof) || this.unexpected(), e.comments = this.state.comments, e.errors = this.state.errors, e } }, { key: "parseExpression", value: function (t, e) { var s = this; return t ? this.disallowInAnd(function () { return s.parseExpressionBase(e) }) : this.allowInAnd(function () { return s.parseExpressionBase(e) }) } }, { key: "parseExpressionBase", value: function (t) { var e = this.state.start, s = this.state.startLoc, i = this.parseMaybeAssign(t); if (this.match(N.comma)) { var a = this.startNodeAt(e, s); for (a.expressions = [i]; this.eat(N.comma);)a.expressions.push(this.parseMaybeAssign(t)); return this.toReferencedList(a.expressions), this.finishNode(a, "SequenceExpression") } return i } }, { key: "parseMaybeAssignDisallowIn", value: function (t, e, s) { var i = this; return this.disallowInAnd(function () { return i.parseMaybeAssign(t, e, s) }) } }, { key: "parseMaybeAssignAllowIn", value: function (t, e, s) { var i = this; return this.allowInAnd(function () { return i.parseMaybeAssign(t, e, s) }) } }, { key: "parseMaybeAssign", value: function (t, e, s) { var i, a = this.state.start, r = this.state.startLoc; if (this.isContextual("yield")) { if (this.prodParam.hasYield) { var n = this.parseYield(); return e && (n = e.call(this, n, a, r)), n } this.state.exprAllowed = !1 } t ? i = !1 : (t = new Ye, i = !0), (this.match(N.parenL) || this.match(N.name)) && (this.state.potentialArrowAt = this.state.start); var o = this.parseMaybeConditional(t, s); if (e && (o = e.call(this, o, a, r)), this.state.type.isAssign) { var h = this.startNodeAt(a, r), l = this.state.value; return h.operator = l, this.match(N.eq) ? (h.left = this.toAssignable(o), t.doubleProto = -1) : h.left = o, t.shorthandAssign >= h.left.start && (t.shorthandAssign = -1), this.checkLVal(o, void 0, void 0, "assignment expression"), this.next(), h.right = this.parseMaybeAssign(), this.finishNode(h, "AssignmentExpression") } return i && this.checkExpressionErrors(t, !0), o } }, { key: "parseMaybeConditional", value: function (t, e) { var s = this.state.start, i = this.state.startLoc, a = this.state.potentialArrowAt, r = this.parseExprOps(t); return this.shouldExitDescending(r, a) ? r : this.parseConditional(r, s, i, e) } }, { key: "parseConditional", value: function (t, e, s, i) { if (this.eat(N.question)) { var a = this.startNodeAt(e, s); return a.test = t, a.consequent = this.parseMaybeAssignAllowIn(), this.expect(N.colon), a.alternate = this.parseMaybeAssign(), this.finishNode(a, "ConditionalExpression") } return t } }, { key: "parseExprOps", value: function (t) { var e = this.state.start, s = this.state.startLoc, i = this.state.potentialArrowAt, a = this.parseMaybeUnary(t); return this.shouldExitDescending(a, i) ? a : this.parseExprOp(a, e, s, -1) } }, { key: "parseExprOp", value: function (t, e, s, i) { var a = this.state.type.binop; if (null != a && (this.prodParam.hasIn || !this.match(N._in)) && a > i) { var r = this.state.type; if (r === N.pipeline) { if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t; this.state.inPipeline = !0, this.checkPipelineAtInfixOperator(t, e) } var n = this.startNodeAt(e, s); n.left = t, n.operator = this.state.value, r !== N.exponent || "UnaryExpression" !== t.type || !this.options.createParenthesizedExpressions && t.extra && t.extra.parenthesized || this.raise(t.argument.start, Ct.UnexpectedTokenUnaryExponentiation); var o = r === N.logicalOR || r === N.logicalAND, h = r === N.nullishCoalescing; if (h && (a = N.logicalAND.binop), this.next(), r === N.pipeline && "minimal" === this.getPluginOption("pipelineOperator", "proposal") && this.match(N.name) && "await" === this.state.value && this.prodParam.hasAwait) throw this.raise(this.state.start, Ct.UnexpectedAwaitAfterPipelineBody); n.right = this.parseExprOpRightExpr(r, a), this.finishNode(n, o || h ? "LogicalExpression" : "BinaryExpression"); var l = this.state.type; if (h && (l === N.logicalOR || l === N.logicalAND) || o && l === N.nullishCoalescing) throw this.raise(this.state.start, Ct.MixingCoalesceWithLogical); return this.parseExprOp(n, e, s, i) } return t } }, { key: "parseExprOpRightExpr", value: function (t, e) { var s = this, i = this.state.start, a = this.state.startLoc; switch (t) { case N.pipeline: switch (this.getPluginOption("pipelineOperator", "proposal")) { case "smart": return this.withTopicPermittingContext(function () { return s.parseSmartPipelineBody(s.parseExprOpBaseRightExpr(t, e), i, a) }); case "fsharp": return this.withSoloAwaitPermittingContext(function () { return s.parseFSharpPipelineBody(e) }) }default: return this.parseExprOpBaseRightExpr(t, e) } } }, { key: "parseExprOpBaseRightExpr", value: function (t, e) { var s = this.state.start, i = this.state.startLoc; return this.parseExprOp(this.parseMaybeUnary(), s, i, t.rightAssociative ? e - 1 : e) } }, { key: "parseMaybeUnary", value: function (t) { if (this.isContextual("await") && this.isAwaitAllowed()) return this.parseAwait(); var e = this.match(N.incDec), s = this.startNode(); if (this.state.type.prefix) { s.operator = this.state.value, s.prefix = !0, this.match(N._throw) && this.expectPlugin("throwExpressions"); var i = this.match(N._delete); if (this.next(), s.argument = this.parseMaybeUnary(), this.checkExpressionErrors(t, !0), this.state.strict && i) { var a = s.argument; "Identifier" === a.type ? this.raise(s.start, Ct.StrictDelete) : "MemberExpression" !== a.type && "OptionalMemberExpression" !== a.type || "PrivateName" !== a.property.type || this.raise(s.start, Ct.DeletePrivateField) } if (!e) return this.finishNode(s, "UnaryExpression") } return this.parseUpdate(s, e, t) } }, { key: "parseUpdate", value: function (t, e, s) { if (e) return this.checkLVal(t.argument, void 0, void 0, "prefix operation"), this.finishNode(t, "UpdateExpression"); var i = this.state.start, a = this.state.startLoc, r = this.parseExprSubscripts(s); if (this.checkExpressionErrors(s, !1)) return r; for (; this.state.type.postfix && !this.canInsertSemicolon();) { var n = this.startNodeAt(i, a); n.operator = this.state.value, n.prefix = !1, n.argument = r, this.checkLVal(r, void 0, void 0, "postfix operation"), this.next(), r = this.finishNode(n, "UpdateExpression") } return r } }, { key: "parseExprSubscripts", value: function (t) { var e = this.state.start, s = this.state.startLoc, i = this.state.potentialArrowAt, a = this.parseExprAtom(t); return this.shouldExitDescending(a, i) ? a : this.parseSubscripts(a, e, s) } }, { key: "parseSubscripts", value: function (t, e, s, i) { var a = { optionalChainMember: !1, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: !1 }; do { var r = this.state.maybeInAsyncArrowHead; a.maybeAsyncArrow && (this.state.maybeInAsyncArrowHead = !0), t = this.parseSubscript(t, e, s, i, a), a.maybeAsyncArrow = !1, this.state.maybeInAsyncArrowHead = r } while (!a.stop); return t } }, { key: "parseSubscript", value: function (t, e, s, i, a) { if (!i && this.eat(N.doubleColon)) return this.parseBind(t, e, s, i, a); if (this.match(N.backQuote)) return this.parseTaggedTemplateExpression(t, e, s, a); var r = !1; if (this.match(N.questionDot)) { if (a.optionalChainMember = r = !0, i && 40 === this.lookaheadCharCode()) return a.stop = !0, t; this.next() } return !i && this.match(N.parenL) ? this.parseCoverCallAndAsyncArrowHead(t, e, s, a, r) : r || this.match(N.bracketL) || this.eat(N.dot) ? this.parseMember(t, e, s, a, r) : (a.stop = !0, t) } }, { key: "parseMember", value: function (t, e, s, i, a) { var r = this.startNodeAt(e, s), n = this.eat(N.bracketL); r.object = t, r.computed = n; var o = n ? this.parseExpression() : this.parseMaybePrivateName(!0); return "PrivateName" === o.type && ("Super" === r.object.type && this.raise(e, Ct.SuperPrivateField), this.classScope.usePrivateName(o.id.name, o.start)), r.property = o, n && this.expect(N.bracketR), i.optionalChainMember ? (r.optional = a, this.finishNode(r, "OptionalMemberExpression")) : this.finishNode(r, "MemberExpression") } }, { key: "parseBind", value: function (t, e, s, i, a) { var r = this.startNodeAt(e, s); return r.object = t, r.callee = this.parseNoCallExpr(), a.stop = !0, this.parseSubscripts(this.finishNode(r, "BindExpression"), e, s, i) } }, { key: "parseCoverCallAndAsyncArrowHead", value: function (t, e, s, i, a) { var r = this.state.maybeInArrowParameters, n = this.state.yieldPos, o = this.state.awaitPos; this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1, this.next(); var h = this.startNodeAt(e, s); return h.callee = t, i.optionalChainMember && (h.optional = a), h.arguments = a ? this.parseCallExpressionArguments(N.parenR, !1) : this.parseCallExpressionArguments(N.parenR, i.maybeAsyncArrow, "Import" === t.type, "Super" !== t.type, h), this.finishCallExpression(h, i.optionalChainMember), i.maybeAsyncArrow && this.shouldParseAsyncArrow() && !a ? (i.stop = !0, h = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s), h), this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = n, this.state.awaitPos = o) : (this.toReferencedListDeep(h.arguments), -1 !== n && (this.state.yieldPos = n), (this.isAwaitAllowed() || r) && -1 === o || (this.state.awaitPos = o)), this.state.maybeInArrowParameters = r, h } }, { key: "parseTaggedTemplateExpression", value: function (t, e, s, i) { var a = this.startNodeAt(e, s); return a.tag = t, a.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(e, Ct.OptionalChainingNoTemplate), this.finishNode(a, "TaggedTemplateExpression") } }, { key: "atPossibleAsyncArrow", value: function (t) { return "Identifier" === t.type && "async" === t.name && this.state.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start == 5 && t.start === this.state.potentialArrowAt } }, { key: "finishCallExpression", value: function (t, e) { if ("Import" === t.callee.type) if (2 === t.arguments.length && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), 0 === t.arguments.length || t.arguments.length > 2) this.raise(t.start, Ct.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument"); else for (var s = 0, i = t.arguments; s < i.length; s++) { var a = i[s]; "SpreadElement" === a.type && this.raise(a.start, Ct.ImportCallSpreadArgument) } return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression") } }, { key: "parseCallExpressionArguments", value: function (t, e, s, i, a) { var r, n = [], o = !0, h = this.state.inFSharpPipelineDirectBody; for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(t);) { if (o) o = !1; else if (this.expect(N.comma), this.match(t)) { !s || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Ct.ImportCallArgumentTrailingComma), a && this.addExtra(a, "trailingComma", this.state.lastTokStart), this.next(); break } this.match(N.parenL) && !r && (r = this.state.start), n.push(this.parseExprListItem(!1, e ? new Ye : void 0, e ? { start: 0 } : void 0, i)) } return e && r && this.shouldParseAsyncArrow() && this.unexpected(), this.state.inFSharpPipelineDirectBody = h, n } }, { key: "shouldParseAsyncArrow", value: function () { return this.match(N.arrow) && !this.canInsertSemicolon() } }, { key: "parseAsyncArrowFromCallExpression", value: function (t, e) { var s; return this.expect(N.arrow), this.parseArrowExpression(t, e.arguments, !0, null == (s = e.extra) ? void 0 : s.trailingComma), t } }, { key: "parseNoCallExpr", value: function () { var t = this.state.start, e = this.state.startLoc; return this.parseSubscripts(this.parseExprAtom(), t, e, !0) } }, { key: "parseExprAtom", value: function (t) { this.state.type === N.slash && this.readRegexp(); var e, s = this.state.potentialArrowAt === this.state.start; switch (this.state.type) { case N._super: return this.parseSuper(); case N._import: return e = this.startNode(), this.next(), this.match(N.dot) ? this.parseImportMetaProperty(e) : (this.match(N.parenL) || this.raise(this.state.lastTokStart, Ct.UnsupportedImport), this.finishNode(e, "Import")); case N._this: return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression"); case N.name: var i = this.state.containsEsc, a = this.parseIdentifier(); if (!i && "async" === a.name && !this.canInsertSemicolon()) { if (this.match(N._function)) { var r = this.state.context.length - 1; if (this.state.context[r] !== Mt.functionStatement) throw new Error("Internal error"); return this.state.context[r] = Mt.functionExpression, this.next(), this.parseFunction(this.startNodeAtNode(a), void 0, !0) } if (this.match(N.name)) return this.parseAsyncArrowUnaryFunction(a) } return s && this.match(N.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(a), [a], !1)) : a; case N._do: return this.parseDo(); case N.regexp: var n = this.state.value; return (e = this.parseLiteral(n.value, "RegExpLiteral")).pattern = n.pattern, e.flags = n.flags, e; case N.num: return this.parseLiteral(this.state.value, "NumericLiteral"); case N.bigint: return this.parseLiteral(this.state.value, "BigIntLiteral"); case N.decimal: return this.parseLiteral(this.state.value, "DecimalLiteral"); case N.string: return this.parseLiteral(this.state.value, "StringLiteral"); case N._null: return e = this.startNode(), this.next(), this.finishNode(e, "NullLiteral"); case N._true: case N._false: return this.parseBooleanLiteral(); case N.parenL: return this.parseParenAndDistinguishExpression(s); case N.bracketBarL: case N.bracketHashL: return this.parseArrayLike(this.state.type === N.bracketBarL ? N.bracketBarR : N.bracketR, !1, !0, t); case N.bracketL: return this.parseArrayLike(N.bracketR, !0, !1, t); case N.braceBarL: case N.braceHashL: return this.parseObjectLike(this.state.type === N.braceBarL ? N.braceBarR : N.braceR, !1, !0, t); case N.braceL: return this.parseObjectLike(N.braceR, !1, !1, t); case N._function: return this.parseFunctionOrFunctionSent(); case N.at: this.parseDecorators(); case N._class: return e = this.startNode(), this.takeDecorators(e), this.parseClass(e, !1); case N._new: return this.parseNewOrNewTarget(); case N.backQuote: return this.parseTemplate(!1); case N.doubleColon: e = this.startNode(), this.next(), e.object = null; var o = e.callee = this.parseNoCallExpr(); if ("MemberExpression" === o.type) return this.finishNode(e, "BindExpression"); throw this.raise(o.start, Ct.UnsupportedBind); case N.hash: if (this.state.inPipeline) return e = this.startNode(), "smart" !== this.getPluginOption("pipelineOperator", "proposal") && this.raise(e.start, Ct.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(e.start, Ct.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(e, "PipelinePrimaryTopicReference"); var h = this.input.codePointAt(this.state.end); if (qt(h) || 92 === h) { var l = this.state.start; if (e = this.parseMaybePrivateName(!0), this.match(N._in)) this.expectPlugin("privateIn"), this.classScope.usePrivateName(e.id.name, e.start); else { if (!this.hasPlugin("privateIn")) throw this.unexpected(l); this.raise(this.state.start, Ct.PrivateInExpectedIn, e.id.name) } return e } case N.relational: if ("<" === this.state.value) { var p = this.input.codePointAt(this.nextTokenStart()); (qt(p) || 62 === p) && this.expectOnePlugin(["jsx", "flow", "typescript"]) } default: throw this.unexpected() } } }, { key: "parseAsyncArrowUnaryFunction", value: function (t) { var e = this.startNodeAtNode(t), s = this.state.maybeInArrowParameters, i = this.state.maybeInAsyncArrowHead, a = this.state.yieldPos, r = this.state.awaitPos; this.state.maybeInArrowParameters = !0, this.state.maybeInAsyncArrowHead = !0, this.state.yieldPos = -1, this.state.awaitPos = -1; var n = [this.parseIdentifier()]; return this.hasPrecedingLineBreak() && this.raise(this.state.pos, Ct.LineTerminatorBeforeArrow), this.expect(N.arrow), this.checkYieldAwaitInDefaultParams(), this.state.maybeInArrowParameters = s, this.state.maybeInAsyncArrowHead = i, this.state.yieldPos = a, this.state.awaitPos = r, this.parseArrowExpression(e, n, !0), e } }, { key: "parseDo", value: function () { this.expectPlugin("doExpressions"); var t = this.startNode(); this.next(); var e = this.state.labels; return this.state.labels = [], t.body = this.parseBlock(), this.state.labels = e, this.finishNode(t, "DoExpression") } }, { key: "parseSuper", value: function () { var t = this.startNode(); return this.next(), !this.match(N.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(t.start, Ct.UnexpectedSuper) : this.raise(t.start, Ct.SuperNotAllowed), this.match(N.parenL) || this.match(N.bracketL) || this.match(N.dot) || this.raise(t.start, Ct.UnsupportedSuper), this.finishNode(t, "Super") } }, { key: "parseBooleanLiteral", value: function () { var t = this.startNode(); return t.value = this.match(N._true), this.next(), this.finishNode(t, "BooleanLiteral") } }, { key: "parseMaybePrivateName", value: function (t) { if (this.match(N.hash)) { this.expectOnePlugin(["classPrivateProperties", "classPrivateMethods"]), t || this.raise(this.state.pos, Ct.UnexpectedPrivateField); var e = this.startNode(); return this.next(), this.assertNoSpace("Unexpected space between # and identifier"), e.id = this.parseIdentifier(!0), this.finishNode(e, "PrivateName") } return this.parseIdentifier(!0) } }, { key: "parseFunctionOrFunctionSent", value: function () { var t = this.startNode(); if (this.next(), this.prodParam.hasYield && this.match(N.dot)) { var e = this.createIdentifier(this.startNodeAtNode(t), "function"); return this.next(), this.parseMetaProperty(t, e, "sent") } return this.parseFunction(t) } }, { key: "parseMetaProperty", value: function (t, e, s) { t.meta = e, "function" === e.name && "sent" === s && (this.isContextual(s) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected()); var i = this.state.containsEsc; return t.property = this.parseIdentifier(!0), (t.property.name !== s || i) && this.raise(t.property.start, Ct.UnsupportedMetaProperty, e.name, s), this.finishNode(t, "MetaProperty") } }, { key: "parseImportMetaProperty", value: function (t) { var e = this.createIdentifier(this.startNodeAtNode(t), "import"); return this.next(), this.isContextual("meta") && (this.inModule || this.raiseWithData(e.start, { code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, Ct.ImportMetaOutsideModule), this.sawUnambiguousESM = !0), this.parseMetaProperty(t, e, "meta") } }, { key: "parseLiteral", value: function (t, e, s, i) { s = s || this.state.start, i = i || this.state.startLoc; var a = this.startNodeAt(s, i); return this.addExtra(a, "rawValue", t), this.addExtra(a, "raw", this.input.slice(s, this.state.end)), a.value = t, this.next(), this.finishNode(a, e) } }, { key: "parseParenAndDistinguishExpression", value: function (t) { var e, s = this.state.start, i = this.state.startLoc; this.next(); var a = this.state.maybeInArrowParameters, r = this.state.yieldPos, n = this.state.awaitPos, o = this.state.inFSharpPipelineDirectBody; this.state.maybeInArrowParameters = !0, this.state.yieldPos = -1, this.state.awaitPos = -1, this.state.inFSharpPipelineDirectBody = !1; for (var h, l, p = this.state.start, c = this.state.startLoc, u = [], d = new Ye, m = { start: 0 }, f = !0; !this.match(N.parenR);) { if (f) f = !1; else if (this.expect(N.comma, m.start || null), this.match(N.parenR)) { l = this.state.start; break } if (this.match(N.ellipsis)) { var y = this.state.start, v = this.state.startLoc; h = this.state.start, u.push(this.parseParenItem(this.parseRestBinding(), y, v)), this.checkCommaAfterRest(41); break } u.push(this.parseMaybeAssignAllowIn(d, this.parseParenItem, m)) } var x = this.state.lastTokEnd, P = this.state.lastTokEndLoc; this.expect(N.parenR), this.state.maybeInArrowParameters = a, this.state.inFSharpPipelineDirectBody = o; var k = this.startNodeAt(s, i); if (t && this.shouldParseArrow() && (k = this.parseArrow(k))) { this.isAwaitAllowed() || this.state.maybeInAsyncArrowHead || (this.state.awaitPos = n), this.checkYieldAwaitInDefaultParams(), this.state.yieldPos = r, this.state.awaitPos = n; for (var g = 0; g < u.length; g++) { var b = u[g]; b.extra && b.extra.parenthesized && this.unexpected(b.extra.parenStart) } return this.parseArrowExpression(k, u, !1), k } if (-1 !== r && (this.state.yieldPos = r), -1 !== n && (this.state.awaitPos = n), u.length || this.unexpected(this.state.lastTokStart), l && this.unexpected(l), h && this.unexpected(h), this.checkExpressionErrors(d, !0), m.start && this.unexpected(m.start), this.toReferencedListDeep(u, !0), u.length > 1 ? ((e = this.startNodeAt(p, c)).expressions = u, this.finishNodeAt(e, "SequenceExpression", x, P)) : e = u[0], !this.options.createParenthesizedExpressions) return this.addExtra(e, "parenthesized", !0), this.addExtra(e, "parenStart", s), e; var T = this.startNodeAt(s, i); return T.expression = e, this.finishNode(T, "ParenthesizedExpression"), T } }, { key: "shouldParseArrow", value: function () { return !this.canInsertSemicolon() } }, { key: "parseArrow", value: function (t) { if (this.eat(N.arrow)) return t } }, { key: "parseParenItem", value: function (t, e, s) { return t } }, { key: "parseNewOrNewTarget", value: function () { var t = this.startNode(); if (this.next(), this.match(N.dot)) { var e = this.createIdentifier(this.startNodeAtNode(t), "new"); this.next(); var s = this.parseMetaProperty(t, e, "target"); if (!this.scope.inNonArrowFunction && !this.scope.inClass) { var i = Ct.UnexpectedNewTarget; this.hasPlugin("classProperties") && (i += " or class properties"), this.raise(s.start, i) } return s } return this.parseNew(t) } }, { key: "parseNew", value: function (t) { return t.callee = this.parseNoCallExpr(), "Import" === t.callee.type ? this.raise(t.callee.start, Ct.ImportCallNotNewExpression) : "OptionalMemberExpression" === t.callee.type || "OptionalCallExpression" === t.callee.type ? this.raise(this.state.lastTokEnd, Ct.OptionalChainingNoNew) : this.eat(N.questionDot) && this.raise(this.state.start, Ct.OptionalChainingNoNew), this.parseNewArguments(t), this.finishNode(t, "NewExpression") } }, { key: "parseNewArguments", value: function (t) { if (this.eat(N.parenL)) { var e = this.parseExprList(N.parenR); this.toReferencedList(e), t.arguments = e } else t.arguments = [] } }, { key: "parseTemplateElement", value: function (t) { var e = this.startNode(); return null === this.state.value && (t || this.raise(this.state.start + 1, Ct.InvalidEscapeSequenceTemplate)), e.value = { raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value }, this.next(), e.tail = this.match(N.backQuote), this.finishNode(e, "TemplateElement") } }, { key: "parseTemplate", value: function (t) { var e = this.startNode(); this.next(), e.expressions = []; var s = this.parseTemplateElement(t); for (e.quasis = [s]; !s.tail;)this.expect(N.dollarBraceL), e.expressions.push(this.parseTemplateSubstitution()), this.expect(N.braceR), e.quasis.push(s = this.parseTemplateElement(t)); return this.next(), this.finishNode(e, "TemplateLiteral") } }, { key: "parseTemplateSubstitution", value: function () { return this.parseExpression() } }, { key: "parseObjectLike", value: function (t, e, s, i) { s && this.expectPlugin("recordAndTuple"); var a = this.state.inFSharpPipelineDirectBody; this.state.inFSharpPipelineDirectBody = !1; var r = Object.create(null), n = !0, o = this.startNode(); for (o.properties = [], this.next(); !this.eat(t);) { if (n) n = !1; else if (this.expect(N.comma), this.match(t)) { this.addExtra(o, "trailingComma", this.state.lastTokStart), this.next(); break } var h = this.parsePropertyDefinition(e, i); e || this.checkProto(h, s, r, i), s && "ObjectProperty" !== h.type && "SpreadElement" !== h.type && this.raise(h.start, Ct.InvalidRecordProperty), h.shorthand && this.addExtra(h, "shorthand", !0), o.properties.push(h) } this.state.inFSharpPipelineDirectBody = a; var l = "ObjectExpression"; return e ? l = "ObjectPattern" : s && (l = "RecordExpression"), this.finishNode(o, l) } }, { key: "maybeAsyncOrAccessorProp", value: function (t) { return !t.computed && "Identifier" === t.key.type && (this.isLiteralPropertyName() || this.match(N.bracketL) || this.match(N.star)) } }, { key: "parsePropertyDefinition", value: function (t, e) { var s = []; if (this.match(N.at)) for (this.hasPlugin("decorators") && this.raise(this.state.start, Ct.UnsupportedPropertyDecorator); this.match(N.at);)s.push(this.parseDecorator()); var i, a, r = this.startNode(), n = !1, o = !1, h = !1; if (this.match(N.ellipsis)) return s.length && this.unexpected(), t ? (this.next(), r.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r, "RestElement")) : this.parseSpread(); s.length && (r.decorators = s, s = []), r.method = !1, (t || e) && (i = this.state.start, a = this.state.startLoc), t || (n = this.eat(N.star)); var l = this.state.containsEsc, p = this.parsePropertyName(r, !1); if (!t && !n && !l && this.maybeAsyncOrAccessorProp(r)) { var c = p.name; "async" !== c || this.hasPrecedingLineBreak() || (o = !0, n = this.eat(N.star), this.parsePropertyName(r, !1)), "get" !== c && "set" !== c || (h = !0, r.kind = c, this.match(N.star) && (n = !0, this.raise(this.state.pos, Ct.AccessorIsGenerator, c), this.next()), this.parsePropertyName(r, !1)) } return this.parseObjPropValue(r, i, a, n, o, t, h, e), r } }, { key: "getGetterSetterExpectedParamCount", value: function (t) { return "get" === t.kind ? 0 : 1 } }, { key: "getObjectOrClassMethodParams", value: function (t) { return t.params } }, { key: "checkGetterSetterParams", value: function (t) { var e, s = this.getGetterSetterExpectedParamCount(t), i = this.getObjectOrClassMethodParams(t), a = t.start; i.length !== s && ("get" === t.kind ? this.raise(a, Ct.BadGetterArity) : this.raise(a, Ct.BadSetterArity)), "set" === t.kind && "RestElement" === (null == (e = i[i.length - 1]) ? void 0 : e.type) && this.raise(a, Ct.BadSetterRestParameter) } }, { key: "parseObjectMethod", value: function (t, e, s, i, a) { return a ? (this.parseMethod(t, e, !1, !1, !1, "ObjectMethod"), this.checkGetterSetterParams(t), t) : s || e || this.match(N.parenL) ? (i && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, e, s, !1, !1, "ObjectMethod")) : void 0 } }, { key: "parseObjectProperty", value: function (t, e, s, i, a) { return t.shorthand = !1, this.eat(N.colon) ? (t.value = i ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(a), this.finishNode(t, "ObjectProperty")) : t.computed || "Identifier" !== t.key.type ? void 0 : (this.checkReservedWord(t.key.name, t.key.start, !0, !1), i ? t.value = this.parseMaybeDefault(e, s, t.key.__clone()) : this.match(N.eq) && a ? (-1 === a.shorthandAssign && (a.shorthandAssign = this.state.start), t.value = this.parseMaybeDefault(e, s, t.key.__clone())) : t.value = t.key.__clone(), t.shorthand = !0, this.finishNode(t, "ObjectProperty")) } }, { key: "parseObjPropValue", value: function (t, e, s, i, a, r, n, o) { var h = this.parseObjectMethod(t, i, a, r, n) || this.parseObjectProperty(t, e, s, r, o); return h || this.unexpected(), h } }, { key: "parsePropertyName", value: function (t, e) { if (this.eat(N.bracketL)) t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(N.bracketR); else { var s = this.state.inPropertyName; this.state.inPropertyName = !0, t.key = this.match(N.num) || this.match(N.string) || this.match(N.bigint) || this.match(N.decimal) ? this.parseExprAtom() : this.parseMaybePrivateName(e), "PrivateName" !== t.key.type && (t.computed = !1), this.state.inPropertyName = s } return t.key } }, { key: "initFunction", value: function (t, e) { t.id = null, t.generator = !1, t.async = !!e } }, { key: "parseMethod", value: function (t, e, s, i, a, r) { var n = arguments.length > 6 && void 0 !== arguments[6] && arguments[6], o = this.state.yieldPos, h = this.state.awaitPos; this.state.yieldPos = -1, this.state.awaitPos = -1, this.initFunction(t, s), t.generator = !!e; var l = i; return this.scope.enter(D | O | (n ? B : 0) | (a ? F : 0)), this.prodParam.enter(Ee(s, t.generator)), this.parseFunctionParams(t, l), this.parseFunctionBodyAndFinish(t, r, !0), this.prodParam.exit(), this.scope.exit(), this.state.yieldPos = o, this.state.awaitPos = h, t } }, { key: "parseArrayLike", value: function (t, e, s, i) { s && this.expectPlugin("recordAndTuple"); var a = this.state.inFSharpPipelineDirectBody; this.state.inFSharpPipelineDirectBody = !1; var r = this.startNode(); return this.next(), r.elements = this.parseExprList(t, !s, i, r), e && !this.state.maybeInArrowParameters && this.toReferencedList(r.elements), this.state.inFSharpPipelineDirectBody = a, this.finishNode(r, s ? "TupleExpression" : "ArrayExpression") } }, { key: "parseArrowExpression", value: function (t, e, s, i) { this.scope.enter(D | M); var a = Ee(s, !1); !this.match(N.bracketL) && this.prodParam.hasIn && (a |= we), this.prodParam.enter(a), this.initFunction(t, s); var r = this.state.maybeInArrowParameters, n = this.state.yieldPos, o = this.state.awaitPos; return e && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, e, i)), this.state.maybeInArrowParameters = !1, this.state.yieldPos = -1, this.state.awaitPos = -1, this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = r, this.state.yieldPos = n, this.state.awaitPos = o, this.finishNode(t, "ArrowFunctionExpression") } }, { key: "setArrowFunctionParameters", value: function (t, e, s) { t.params = this.toAssignableList(e, s) } }, { key: "parseFunctionBodyAndFinish", value: function (t, e) { var s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]; this.parseFunctionBody(t, !1, s), this.finishNode(t, e) } }, { key: "parseFunctionBody", value: function (t, e) { var s = this, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a = e && !this.match(N.braceL), r = this.state.inParameters; if (this.state.inParameters = !1, a) t.body = this.parseMaybeAssign(), this.checkParams(t, !1, e, !1); else { var n = this.state.strict, o = this.state.labels; this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Te), t.body = this.parseBlock(!0, !1, function (a) { var r = !s.isSimpleParamList(t.params); if (a && r) { var o = "method" !== t.kind && "constructor" !== t.kind || !t.key ? t.start : t.key.end; s.raise(o, Ct.IllegalLanguageModeDirective) } var h = !n && s.state.strict; s.checkParams(t, !(s.state.strict || e || i || r), e, h), s.state.strict && t.id && s.checkLVal(t.id, rt, void 0, "function name", void 0, h) }), this.prodParam.exit(), this.state.labels = o } this.state.inParameters = r } }, { key: "isSimpleParamList", value: function (t) { for (var e = 0, s = t.length; e < s; e++)if ("Identifier" !== t[e].type) return !1; return !0 } }, { key: "checkParams", value: function (t, e, s) { for (var i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], a = Object.create(null), r = 0; r < t.params.length; r++)this.checkLVal(t.params[r], $, e ? null : a, "function parameter list", void 0, i) } }, { key: "parseExprList", value: function (t, e, s, i) { for (var a = [], r = !0; !this.eat(t);) { if (r) r = !1; else if (this.expect(N.comma), this.match(t)) { i && this.addExtra(i, "trailingComma", this.state.lastTokStart), this.next(); break } a.push(this.parseExprListItem(e, s)) } return a } }, { key: "parseExprListItem", value: function (t, e, s, i) { var a; if (this.match(N.comma)) t || this.raise(this.state.pos, Ct.UnexpectedToken, ","), a = null; else if (this.match(N.ellipsis)) { var r = this.state.start, n = this.state.startLoc; a = this.parseParenItem(this.parseSpread(e, s), r, n) } else if (this.match(N.question)) { this.expectPlugin("partialApplication"), i || this.raise(this.state.start, Ct.UnexpectedArgumentPlaceholder); var o = this.startNode(); this.next(), a = this.finishNode(o, "ArgumentPlaceholder") } else a = this.parseMaybeAssignAllowIn(e, this.parseParenItem, s); return a } }, { key: "parseIdentifier", value: function (t) { var e = this.startNode(), s = this.parseIdentifierName(e.start, t); return this.createIdentifier(e, s) } }, { key: "createIdentifier", value: function (t, e) { return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier") } }, { key: "parseIdentifierName", value: function (t, e) { var s, { start: i, type: a } = this.state; if (a === N.name) s = this.state.value; else { if (!a.keyword) throw this.unexpected(); s = a.keyword; var r = this.curContext(); a !== N._class && a !== N._function || r !== Mt.functionStatement && r !== Mt.functionExpression || this.state.context.pop() } return e ? this.state.type = N.name : this.checkReservedWord(s, i, !!a.keyword, !1), this.next(), s } }, { key: "checkReservedWord", value: function (t, e, s, i) { if (this.prodParam.hasYield && "yield" === t) this.raise(e, Ct.YieldBindingIdentifier); else { if ("await" === t) { if (this.prodParam.hasAwait) return void this.raise(e, Ct.AwaitBindingIdentifier); -1 === this.state.awaitPos && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed()) && (this.state.awaitPos = this.state.start) } if (!this.scope.inClass || this.scope.inNonArrowFunction || "arguments" !== t) if (s && Yt(t)) this.raise(e, Ct.UnexpectedKeyword, t); else (this.state.strict ? i ? Qt : Xt : Jt)(t, this.inModule) && (this.prodParam.hasAwait || "await" !== t ? this.raise(e, Ct.UnexpectedReservedWord, t) : this.raise(e, Ct.AwaitNotInAsyncFunction)); else this.raise(e, Ct.ArgumentsInClass) } } }, { key: "isAwaitAllowed", value: function () { return this.scope.inFunction ? this.prodParam.hasAwait : !!this.options.allowAwaitOutsideFunction || !!this.hasPlugin("topLevelAwait") && (this.inModule && this.prodParam.hasAwait) } }, { key: "parseAwait", value: function () { var t = this.startNode(); return this.next(), this.state.inParameters ? this.raise(t.start, Ct.AwaitExpressionFormalParameter) : -1 === this.state.awaitPos && (this.state.awaitPos = t.start), this.eat(N.star) && this.raise(t.start, Ct.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.hasPrecedingLineBreak() || this.match(N.plusMin) || this.match(N.parenL) || this.match(N.bracketL) || this.match(N.backQuote) || this.match(N.regexp) || this.match(N.slash) || this.hasPlugin("v8intrinsic") && this.match(N.modulo) ? this.ambiguousScriptDifferentAst = !0 : this.sawUnambiguousESM = !0), this.state.soloAwait || (t.argument = this.parseMaybeUnary()), this.finishNode(t, "AwaitExpression") } }, { key: "parseYield", value: function () { var t = this.startNode(); return this.state.inParameters ? this.raise(t.start, Ct.YieldInParameter) : -1 === this.state.yieldPos && (this.state.yieldPos = t.start), this.next(), this.match(N.semi) || !this.match(N.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak() ? (t.delegate = !1, t.argument = null) : (t.delegate = this.eat(N.star), t.argument = this.parseMaybeAssign()), this.finishNode(t, "YieldExpression") } }, { key: "checkPipelineAtInfixOperator", value: function (t, e) { "smart" === this.getPluginOption("pipelineOperator", "proposal") && "SequenceExpression" === t.type && this.raise(e, Ct.PipelineHeadSequenceExpression) } }, { key: "parseSmartPipelineBody", value: function (t, e, s) { return this.checkSmartPipelineBodyEarlyErrors(t, e), this.parseSmartPipelineBodyInStyle(t, e, s) } }, { key: "checkSmartPipelineBodyEarlyErrors", value: function (t, e) { if (this.match(N.arrow)) throw this.raise(this.state.start, Ct.PipelineBodyNoArrow); "SequenceExpression" === t.type && this.raise(e, Ct.PipelineBodySequenceExpression) } }, { key: "parseSmartPipelineBodyInStyle", value: function (t, e, s) { var i = this.startNodeAt(e, s), a = this.isSimpleReference(t); return a ? i.callee = t : (this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(e, Ct.PipelineTopicUnused), i.expression = t), this.finishNode(i, a ? "PipelineBareFunction" : "PipelineTopicExpression") } }, { key: "isSimpleReference", value: function (t) { switch (t.type) { case "MemberExpression": return !t.computed && this.isSimpleReference(t.object); case "Identifier": return !0; default: return !1 } } }, { key: "withTopicPermittingContext", value: function (t) { var e = this.state.topicContext; this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null }; try { return t() } finally { this.state.topicContext = e } } }, { key: "withTopicForbiddingContext", value: function (t) { var e = this.state.topicContext; this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }; try { return t() } finally { this.state.topicContext = e } } }, { key: "withSoloAwaitPermittingContext", value: function (t) { var e = this.state.soloAwait; this.state.soloAwait = !0; try { return t() } finally { this.state.soloAwait = e } } }, { key: "allowInAnd", value: function (t) { var e = this.prodParam.currentFlags(); if (we & ~e) { this.prodParam.enter(e | we); try { return t() } finally { this.prodParam.exit() } } return t() } }, { key: "disallowInAnd", value: function (t) { var e = this.prodParam.currentFlags(); if (we & e) { this.prodParam.enter(e & ~we); try { return t() } finally { this.prodParam.exit() } } return t() } }, { key: "registerTopicReference", value: function () { this.state.topicContext.maxTopicIndex = 0 } }, { key: "primaryTopicReferenceIsAllowedInCurrentTopicContext", value: function () { return this.state.topicContext.maxNumOfResolvableTopics >= 1 } }, { key: "topicReferenceWasUsedInCurrentTopicContext", value: function () { return null != this.state.topicContext.maxTopicIndex && this.state.topicContext.maxTopicIndex >= 0 } }, { key: "parseFSharpPipelineBody", value: function (t) { var e = this.state.start, s = this.state.startLoc; this.state.potentialArrowAt = this.state.start; var i = this.state.inFSharpPipelineDirectBody; this.state.inFSharpPipelineDirectBody = !0; var a = this.parseExprOp(this.parseMaybeUnary(), e, s, t); return this.state.inFSharpPipelineDirectBody = i, a } }]), s }(), is = { kind: "loop" }, as = { kind: "switch" }, rs = 0, ns = 1, os = 2, hs = 4, ls = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, ps = function (e) { l(i, ss); var s = c(i); function i() { return x(this, i), s.apply(this, arguments) } return v(i, [{ key: "parseTopLevel", value: function (t, e) { if (e.sourceType = this.options.sourceType, e.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e, !0, !0, N.eof), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (var s = 0, i = Array.from(this.scope.undefinedExports); s < i.length; s++) { var [a] = i[s], r = this.scope.undefinedExports.get(a); this.raise(r, Ct.ModuleExportUndefined, a) } return t.program = this.finishNode(e, "Program"), t.comments = this.state.comments, this.options.tokens && (t.tokens = this.tokens), this.finishNode(t, "File") } }, { key: "stmtToDirective", value: function (t) { var e = t.expression, s = this.startNodeAt(e.start, e.loc.start), i = this.startNodeAt(t.start, t.loc.start), a = this.input.slice(e.start, e.end), r = s.value = a.slice(1, -1); return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", r), i.value = this.finishNodeAt(s, "DirectiveLiteral", e.end, e.loc.end), this.finishNodeAt(i, "Directive", t.end, t.loc.end) } }, { key: "parseInterpreterDirective", value: function () { if (!this.match(N.interpreterDirective)) return null; var t = this.startNode(); return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective") } }, { key: "isLet", value: function (t) { if (!this.isContextual("let")) return !1; var e = this.nextTokenStart(), s = this.input.charCodeAt(e); if (91 === s) return !0; if (t) return !1; if (123 === s) return !0; if (qt(s)) { for (var i = e + 1; Vt(this.input.charCodeAt(i));)++i; var a = this.input.slice(e, i); if (!$t.test(a)) return !0 } return !1 } }, { key: "parseStatement", value: function (t, e) { return this.match(N.at) && this.parseDecorators(!0), this.parseStatementContent(t, e) } }, { key: "parseStatementContent", value: function (t, e) { var s, i = this.state.type, a = this.startNode(); switch (this.isLet(t) && (i = N._var, s = "let"), i) { case N._break: case N._continue: return this.parseBreakContinueStatement(a, i.keyword); case N._debugger: return this.parseDebuggerStatement(a); case N._do: return this.parseDoStatement(a); case N._for: return this.parseForStatement(a); case N._function: if (46 === this.lookaheadCharCode()) break; return t && (this.state.strict ? this.raise(this.state.start, Ct.StrictFunction) : "if" !== t && "label" !== t && this.raise(this.state.start, Ct.SloppyFunction)), this.parseFunctionStatement(a, !1, !t); case N._class: return t && this.unexpected(), this.parseClass(a, !0); case N._if: return this.parseIfStatement(a); case N._return: return this.parseReturnStatement(a); case N._switch: return this.parseSwitchStatement(a); case N._throw: return this.parseThrowStatement(a); case N._try: return this.parseTryStatement(a); case N._const: case N._var: return s = s || this.state.value, t && "var" !== s && this.raise(this.state.start, Ct.UnexpectedLexicalDeclaration), this.parseVarStatement(a, s); case N._while: return this.parseWhileStatement(a); case N._with: return this.parseWithStatement(a); case N.braceL: return this.parseBlock(); case N.semi: return this.parseEmptyStatement(a); case N._import: var r = this.lookaheadCharCode(); if (40 === r || 46 === r) break; case N._export: var n; return this.options.allowImportExportEverywhere || e || this.raise(this.state.start, Ct.UnexpectedImportExport), this.next(), i === N._import ? "ImportDeclaration" !== (n = this.parseImport(a)).type || n.importKind && "value" !== n.importKind || (this.sawUnambiguousESM = !0) : ("ExportNamedDeclaration" !== (n = this.parseExport(a)).type || n.exportKind && "value" !== n.exportKind) && ("ExportAllDeclaration" !== n.type || n.exportKind && "value" !== n.exportKind) && "ExportDefaultDeclaration" !== n.type || (this.sawUnambiguousESM = !0), this.assertModuleNodeAllowed(a), n; default: if (this.isAsyncFunction()) return t && this.raise(this.state.start, Ct.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(a, !0, !t) }var o = this.state.value, h = this.parseExpression(); return i === N.name && "Identifier" === h.type && this.eat(N.colon) ? this.parseLabeledStatement(a, o, h, t) : this.parseExpressionStatement(a, h) } }, { key: "assertModuleNodeAllowed", value: function (t) { this.options.allowImportExportEverywhere || this.inModule || this.raiseWithData(t.start, { code: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }, Ct.ImportOutsideModule) } }, { key: "takeDecorators", value: function (t) { var e = this.state.decoratorStack[this.state.decoratorStack.length - 1]; e.length && (t.decorators = e, this.resetStartLocationFromNode(t, e[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []) } }, { key: "canHaveLeadingDecorator", value: function () { return this.match(N._class) } }, { key: "parseDecorators", value: function (t) { for (var e = this.state.decoratorStack[this.state.decoratorStack.length - 1]; this.match(N.at);) { var s = this.parseDecorator(); e.push(s) } if (this.match(N._export)) t || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Ct.DecoratorExportClass); else if (!this.canHaveLeadingDecorator()) throw this.raise(this.state.start, Ct.UnexpectedLeadingDecorator) } }, { key: "parseDecorator", value: function () { this.expectOnePlugin(["decorators-legacy", "decorators"]); var t = this.startNode(); if (this.next(), this.hasPlugin("decorators")) { this.state.decoratorStack.push([]); var e, s = this.state.start, i = this.state.startLoc; if (this.eat(N.parenL)) e = this.parseExpression(), this.expect(N.parenR); else for (e = this.parseIdentifier(!1); this.eat(N.dot);) { var a = this.startNodeAt(s, i); a.object = e, a.property = this.parseIdentifier(!0), a.computed = !1, e = this.finishNode(a, "MemberExpression") } t.expression = this.parseMaybeDecoratorArguments(e), this.state.decoratorStack.pop() } else t.expression = this.parseExprSubscripts(); return this.finishNode(t, "Decorator") } }, { key: "parseMaybeDecoratorArguments", value: function (t) { if (this.eat(N.parenL)) { var e = this.startNodeAtNode(t); return e.callee = t, e.arguments = this.parseCallExpressionArguments(N.parenR, !1), this.toReferencedList(e.arguments), this.finishNode(e, "CallExpression") } return t } }, { key: "parseBreakContinueStatement", value: function (t, e) { var s = "break" === e; return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, s ? "BreakStatement" : "ContinueStatement") } }, { key: "verifyBreakContinue", value: function (t, e) { var s, i = "break" === e; for (s = 0; s < this.state.labels.length; ++s) { var a = this.state.labels[s]; if (null == t.label || a.name === t.label.name) { if (null != a.kind && (i || "loop" === a.kind)) break; if (t.label && i) break } } s === this.state.labels.length && this.raise(t.start, Ct.IllegalBreakContinue, e) } }, { key: "parseDebuggerStatement", value: function (t) { return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement") } }, { key: "parseHeaderExpression", value: function () { this.expect(N.parenL); var t = this.parseExpression(); return this.expect(N.parenR), t } }, { key: "parseDoStatement", value: function (t) { var e = this; return this.next(), this.state.labels.push(is), t.body = this.withTopicForbiddingContext(function () { return e.parseStatement("do") }), this.state.labels.pop(), this.expect(N._while), t.test = this.parseHeaderExpression(), this.eat(N.semi), this.finishNode(t, "DoWhileStatement") } }, { key: "parseForStatement", value: function (t) { this.next(), this.state.labels.push(is); var e = -1; if (this.isAwaitAllowed() && this.eatContextual("await") && (e = this.state.lastTokStart), this.scope.enter(I), this.expect(N.parenL), this.match(N.semi)) return e > -1 && this.unexpected(e), this.parseFor(t, null); var s = this.isLet(); if (this.match(N._var) || this.match(N._const) || s) { var i = this.startNode(), a = s ? "let" : this.state.value; return this.next(), this.parseVar(i, !0, a), this.finishNode(i, "VariableDeclaration"), (this.match(N._in) || this.isContextual("of")) && 1 === i.declarations.length ? this.parseForIn(t, i, e) : (e > -1 && this.unexpected(e), this.parseFor(t, i)) } var r = new Ye, n = this.parseExpression(!0, r); if (this.match(N._in) || this.isContextual("of")) { this.toAssignable(n); var o = this.isContextual("of") ? "for-of statement" : "for-in statement"; return this.checkLVal(n, void 0, void 0, o), this.parseForIn(t, n, e) } return this.checkExpressionErrors(r, !0), e > -1 && this.unexpected(e), this.parseFor(t, n) } }, { key: "parseFunctionStatement", value: function (t, e, s) { return this.next(), this.parseFunction(t, ns | (s ? 0 : os), e) } }, { key: "parseIfStatement", value: function (t) { return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(N._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement") } }, { key: "parseReturnStatement", value: function (t) { return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Ct.IllegalReturn), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement") } }, { key: "parseSwitchStatement", value: function (t) { this.next(), t.discriminant = this.parseHeaderExpression(); var e, s, i = t.cases = []; for (this.expect(N.braceL), this.state.labels.push(as), this.scope.enter(I); !this.match(N.braceR);)if (this.match(N._case) || this.match(N._default)) { var a = this.match(N._case); e && this.finishNode(e, "SwitchCase"), i.push(e = this.startNode()), e.consequent = [], this.next(), a ? e.test = this.parseExpression() : (s && this.raise(this.state.lastTokStart, Ct.MultipleDefaultsInSwitch), s = !0, e.test = null), this.expect(N.colon) } else e ? e.consequent.push(this.parseStatement(null)) : this.unexpected(); return this.scope.exit(), e && this.finishNode(e, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement") } }, { key: "parseThrowStatement", value: function (t) { return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Ct.NewlineAfterThrow), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement") } }, { key: "parseCatchClauseParam", value: function () { var t = this.parseBindingAtom(), e = "Identifier" === t.type; return this.scope.enter(e ? R : 0), this.checkLVal(t, Y, null, "catch clause"), t } }, { key: "parseTryStatement", value: function (t) { var e = this; if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(N._catch)) { var s = this.startNode(); this.next(), this.match(N.parenL) ? (this.expect(N.parenL), s.param = this.parseCatchClauseParam(), this.expect(N.parenR)) : (s.param = null, this.scope.enter(I)), s.body = this.withTopicForbiddingContext(function () { return e.parseBlock(!1, !1) }), this.scope.exit(), t.handler = this.finishNode(s, "CatchClause") } return t.finalizer = this.eat(N._finally) ? this.parseBlock() : null, t.handler || t.finalizer || this.raise(t.start, Ct.NoCatchOrFinally), this.finishNode(t, "TryStatement") } }, { key: "parseVarStatement", value: function (t, e) { return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration") } }, { key: "parseWhileStatement", value: function (t) { var e = this; return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(is), t.body = this.withTopicForbiddingContext(function () { return e.parseStatement("while") }), this.state.labels.pop(), this.finishNode(t, "WhileStatement") } }, { key: "parseWithStatement", value: function (t) { var e = this; return this.state.strict && this.raise(this.state.start, Ct.StrictWith), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withTopicForbiddingContext(function () { return e.parseStatement("with") }), this.finishNode(t, "WithStatement") } }, { key: "parseEmptyStatement", value: function (t) { return this.next(), this.finishNode(t, "EmptyStatement") } }, { key: "parseLabeledStatement", value: function (t, e, s, i) { for (var a = 0, r = this.state.labels; a < r.length; a++) { r[a].name === e && this.raise(s.start, Ct.LabelRedeclaration, e) } for (var n = this.state.type.isLoop ? "loop" : this.match(N._switch) ? "switch" : null, o = this.state.labels.length - 1; o >= 0; o--) { var h = this.state.labels[o]; if (h.statementStart !== t.start) break; h.statementStart = this.state.start, h.kind = n } return this.state.labels.push({ name: e, kind: n, statementStart: this.state.start }), t.body = this.parseStatement(i ? -1 === i.indexOf("label") ? i + "label" : i : "label"), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement") } }, { key: "parseExpressionStatement", value: function (t, e) { return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement") } }, { key: "parseBlock", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], s = arguments.length > 2 ? arguments[2] : void 0, i = this.startNode(); return this.expect(N.braceL), e && this.scope.enter(I), this.parseBlockBody(i, t, !1, N.braceR, s), e && this.scope.exit(), this.finishNode(i, "BlockStatement") } }, { key: "isValidDirective", value: function (t) { return "ExpressionStatement" === t.type && "StringLiteral" === t.expression.type && !t.expression.extra.parenthesized } }, { key: "parseBlockBody", value: function (t, e, s, i, a) { var r = t.body = [], n = t.directives = []; this.parseBlockOrModuleBlockBody(r, e ? n : void 0, s, i, a) } }, { key: "parseBlockOrModuleBlockBody", value: function (e, s, i, a, r) { for (var n = [], o = this.state.strict, h = !1, l = !1; !this.match(a);) { !l && this.state.octalPositions.length && n.push.apply(n, t(this.state.octalPositions)); var p = this.parseStatement(null, i); if (s && !l && this.isValidDirective(p)) { var c = this.stmtToDirective(p); s.push(c), h || "use strict" !== c.value.value || (h = !0, this.setStrict(!0)) } else l = !0, e.push(p) } if (this.state.strict && n.length) for (var u = 0; u < n.length; u++) { var d = n[u]; this.raise(d, Ct.StrictOctalLiteral) } r && r.call(this, h), o || this.setStrict(!1), this.next() } }, { key: "parseFor", value: function (t, e) { var s = this; return t.init = e, this.expect(N.semi), t.test = this.match(N.semi) ? null : this.parseExpression(), this.expect(N.semi), t.update = this.match(N.parenR) ? null : this.parseExpression(), this.expect(N.parenR), t.body = this.withTopicForbiddingContext(function () { return s.parseStatement("for") }), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement") } }, { key: "parseForIn", value: function (t, e, s) { var i = this, a = this.match(N._in); return this.next(), a ? s > -1 && this.unexpected(s) : t.await = s > -1, "VariableDeclaration" !== e.type || null == e.declarations[0].init || a && !this.state.strict && "var" === e.kind && "Identifier" === e.declarations[0].id.type ? "AssignmentPattern" === e.type && this.raise(e.start, Ct.InvalidLhs, "for-loop") : this.raise(e.start, Ct.ForInOfLoopInitializer, a ? "for-in" : "for-of"), t.left = e, t.right = a ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(N.parenR), t.body = this.withTopicForbiddingContext(function () { return i.parseStatement("for") }), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, a ? "ForInStatement" : "ForOfStatement") } }, { key: "parseVar", value: function (t, e, s) { var i = t.declarations = [], a = this.hasPlugin("typescript"); for (t.kind = s; ;) { var r = this.startNode(); if (this.parseVarId(r, s), this.eat(N.eq) ? r.init = e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : ("const" !== s || this.match(N._in) || this.isContextual("of") ? "Identifier" === r.id.type || e && (this.match(N._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Ct.DeclarationMissingInitializer, "Complex binding patterns") : a || this.raise(this.state.lastTokEnd, Ct.DeclarationMissingInitializer, "Const declarations"), r.init = null), i.push(this.finishNode(r, "VariableDeclarator")), !this.eat(N.comma)) break } return t } }, { key: "parseVarId", value: function (t, e) { t.id = this.parseBindingAtom(), this.checkLVal(t.id, "var" === e ? $ : Y, void 0, "variable declaration", "var" !== e) } }, { key: "parseFunction", value: function (t) { var e = this, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : rs, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a = s & ns, r = s & os, n = !(!a || s & hs); this.initFunction(t, i), this.match(N.star) && r && this.raise(this.state.start, Ct.GeneratorInSingleStatementContext), t.generator = this.eat(N.star), a && (t.id = this.parseFunctionId(n)); var o = this.state.maybeInArrowParameters, h = this.state.yieldPos, l = this.state.awaitPos; return this.state.maybeInArrowParameters = !1, this.state.yieldPos = -1, this.state.awaitPos = -1, this.scope.enter(D), this.prodParam.enter(Ee(i, t.generator)), a || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, !1), this.withTopicForbiddingContext(function () { e.parseFunctionBodyAndFinish(t, a ? "FunctionDeclaration" : "FunctionExpression") }), this.prodParam.exit(), this.scope.exit(), a && !r && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, this.state.yieldPos = h, this.state.awaitPos = l, t } }, { key: "parseFunctionId", value: function (t) { return t || this.match(N.name) ? this.parseIdentifier() : null } }, { key: "parseFunctionParams", value: function (t, e) { var s = this.state.inParameters; this.state.inParameters = !0, this.expect(N.parenL), t.params = this.parseBindingList(N.parenR, 41, !1, e), this.state.inParameters = s, this.checkYieldAwaitInDefaultParams() } }, { key: "registerFunctionStatementId", value: function (t) { t.id && this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? $ : Y : Z, t.id.start) } }, { key: "parseClass", value: function (t, e, s) { this.next(), this.takeDecorators(t); var i = this.state.strict; return this.state.strict = !0, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression") } }, { key: "isClassProperty", value: function () { return this.match(N.eq) || this.match(N.semi) || this.match(N.braceR) } }, { key: "isClassMethod", value: function () { return this.match(N.parenL) } }, { key: "isNonstaticConstructor", value: function (t) { return !(t.computed || t.static || "constructor" !== t.key.name && "constructor" !== t.key.value) } }, { key: "parseClassBody", value: function (t, e) { var s = this; this.classScope.enter(); var i = { constructorAllowsSuper: t, hadConstructor: !1, hadStaticBlock: !1 }, a = [], r = this.startNode(); if (r.body = [], this.expect(N.braceL), this.withTopicForbiddingContext(function () { for (; !s.match(N.braceR);)if (s.eat(N.semi)) { if (a.length > 0) throw s.raise(s.state.lastTokEnd, Ct.DecoratorSemicolon) } else if (s.match(N.at)) a.push(s.parseDecorator()); else { var t = s.startNode(); a.length && (t.decorators = a, s.resetStartLocationFromNode(t, a[0]), a = []), s.parseClassMember(r, t, i), "constructor" === t.kind && t.decorators && t.decorators.length > 0 && s.raise(t.start, Ct.DecoratorConstructor) } }), this.state.strict = e, this.next(), a.length) throw this.raise(this.state.start, Ct.TrailingDecorator); return this.classScope.exit(), this.finishNode(r, "ClassBody") } }, { key: "parseClassMemberFromModifier", value: function (t, e) { var s = this.parseIdentifier(!0); if (this.isClassMethod()) { var i = e; return i.kind = "method", i.computed = !1, i.key = s, i.static = !1, this.pushClassMethod(t, i, !1, !1, !1, !1), !0 } if (this.isClassProperty()) { var a = e; return a.computed = !1, a.key = s, a.static = !1, t.body.push(this.parseClassProperty(a)), !0 } return !1 } }, { key: "parseClassMember", value: function (t, e, s) { var i = this.isContextual("static"); if (i) { if (this.parseClassMemberFromModifier(t, e)) return; if (this.eat(N.braceL)) return void this.parseClassStaticBlock(t, e, s) } this.parseClassMemberWithIsStatic(t, e, s, i) } }, { key: "parseClassMemberWithIsStatic", value: function (t, e, s, i) { var a = e, r = e, n = e, o = e, h = a, l = a; if (e.static = i, this.eat(N.star)) return h.kind = "method", this.parseClassElementName(h), "PrivateName" === h.key.type ? void this.pushClassPrivateMethod(t, r, !0, !1) : (this.isNonstaticConstructor(a) && this.raise(a.key.start, Ct.ConstructorIsGenerator), void this.pushClassMethod(t, a, !0, !1, !1, !1)); var p = this.state.containsEsc, c = this.parseClassElementName(e), u = "PrivateName" === c.type, d = "Identifier" === c.type, m = this.state.start; if (this.parsePostMemberNameModifiers(l), this.isClassMethod()) { if (h.kind = "method", u) return void this.pushClassPrivateMethod(t, r, !1, !1); var f = this.isNonstaticConstructor(a), y = !1; f && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(c.start, Ct.DuplicateConstructor), s.hadConstructor = !0, y = s.constructorAllowsSuper), this.pushClassMethod(t, a, !1, !1, f, y) } else if (this.isClassProperty()) u ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n); else if (!d || "async" !== c.name || p || this.isLineTerminator()) !d || "get" !== c.name && "set" !== c.name || p || this.match(N.star) && this.isLineTerminator() ? this.isLineTerminator() ? u ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected() : (h.kind = c.name, this.parseClassElementName(a), "PrivateName" === h.key.type ? this.pushClassPrivateMethod(t, r, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(a.key.start, Ct.ConstructorIsAccessor), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a)); else { var v = this.eat(N.star); l.optional && this.unexpected(m), h.kind = "method", this.parseClassElementName(h), this.parsePostMemberNameModifiers(l), "PrivateName" === h.key.type ? this.pushClassPrivateMethod(t, r, v, !0) : (this.isNonstaticConstructor(a) && this.raise(a.key.start, Ct.ConstructorIsAsync), this.pushClassMethod(t, a, v, !0, !1, !1)) } } }, { key: "parseClassElementName", value: function (t) { var e = this.parsePropertyName(t, !0); return t.computed || !t.static || "prototype" !== e.name && "prototype" !== e.value || this.raise(e.start, Ct.StaticPrototype), "PrivateName" === e.type && "constructor" === e.id.name && this.raise(e.start, Ct.ConstructorClassPrivateField), e } }, { key: "parseClassStaticBlock", value: function (t, e, s) { var i; this.expectPlugin("classStaticBlock", e.start), this.scope.enter(B | O); var a = this.state.labels; this.state.labels = [], this.prodParam.enter(ke); var r = e.body = []; this.parseBlockOrModuleBlockBody(r, void 0, !1, N.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = a, t.body.push(this.finishNode(e, "StaticBlock")), s.hadStaticBlock && this.raise(e.start, Ct.DuplicateStaticBlock), (null == (i = e.decorators) ? void 0 : i.length) && this.raise(e.start, Ct.DecoratorStaticBlock), s.hadStaticBlock = !0 } }, { key: "pushClassProperty", value: function (t, e) { e.computed || "constructor" !== e.key.name && "constructor" !== e.key.value || this.raise(e.key.start, Ct.ConstructorClassField), t.body.push(this.parseClassProperty(e)) } }, { key: "pushClassPrivateProperty", value: function (t, e) { this.expectPlugin("classPrivateProperties", e.key.start); var s = this.parseClassPrivateProperty(e); t.body.push(s), this.classScope.declarePrivateName(s.key.id.name, yt, s.key.start) } }, { key: "pushClassMethod", value: function (t, e, s, i, a, r) { t.body.push(this.parseMethod(e, s, i, a, r, "ClassMethod", !0)) } }, { key: "pushClassPrivateMethod", value: function (t, e, s, i) { this.expectPlugin("classPrivateMethods", e.key.start); var a = this.parseMethod(e, s, i, !1, !1, "ClassPrivateMethod", !0); t.body.push(a); var r = "get" === a.kind ? a.static ? ut : mt : "set" === a.kind ? a.static ? dt : ft : yt; this.classScope.declarePrivateName(a.key.id.name, r, a.key.start) } }, { key: "parsePostMemberNameModifiers", value: function (t) { } }, { key: "parseClassPrivateProperty", value: function (t) { return this.scope.enter(B | O), this.prodParam.enter(ke), t.value = this.eat(N.eq) ? this.parseMaybeAssignAllowIn() : null, this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(t, "ClassPrivateProperty") } }, { key: "parseClassProperty", value: function (t) { return t.typeAnnotation || this.expectPlugin("classProperties"), this.scope.enter(B | O), this.prodParam.enter(ke), this.match(N.eq) ? (this.expectPlugin("classProperties"), this.next(), t.value = this.parseMaybeAssignAllowIn()) : t.value = null, this.semicolon(), this.prodParam.exit(), this.scope.exit(), this.finishNode(t, "ClassProperty") } }, { key: "parseClassId", value: function (t, e, s) { var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Q; this.match(N.name) ? (t.id = this.parseIdentifier(), e && this.checkLVal(t.id, i, void 0, "class name")) : s || !e ? t.id = null : this.unexpected(null, Ct.MissingClassName) } }, { key: "parseClassSuper", value: function (t) { t.superClass = this.eat(N._extends) ? this.parseExprSubscripts() : null } }, { key: "parseExport", value: function (t) { var e = this.maybeParseExportDefaultSpecifier(t), s = !e || this.eat(N.comma), i = s && this.eatExportStar(t), a = i && this.maybeParseExportNamespaceSpecifier(t), r = s && (!a || this.eat(N.comma)), n = e || i; if (i && !a) return e && this.unexpected(), this.parseExportFrom(t, !0), this.finishNode(t, "ExportAllDeclaration"); var o, h = this.maybeParseExportNamedSpecifiers(t); if (e && s && !i && !h || a && r && !h) throw this.unexpected(null, N.braceL); if (n || h ? (o = !1, this.parseExportFrom(t, n)) : o = this.maybeParseExportDeclaration(t), n || h || o) return this.checkExport(t, !0, !1, !!t.source), this.finishNode(t, "ExportNamedDeclaration"); if (this.eat(N._default)) return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, !0, !0), this.finishNode(t, "ExportDefaultDeclaration"); throw this.unexpected(null, N.braceL) } }, { key: "eatExportStar", value: function (t) { return this.eat(N.star) } }, { key: "maybeParseExportDefaultSpecifier", value: function (t) { if (this.isExportDefaultSpecifier()) { this.expectPlugin("exportDefaultFrom"); var e = this.startNode(); return e.exported = this.parseIdentifier(!0), t.specifiers = [this.finishNode(e, "ExportDefaultSpecifier")], !0 } return !1 } }, { key: "maybeParseExportNamespaceSpecifier", value: function (t) { if (this.isContextual("as")) { t.specifiers || (t.specifiers = []); var e = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc); return this.next(), e.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e, "ExportNamespaceSpecifier")), !0 } return !1 } }, { key: "maybeParseExportNamedSpecifiers", value: function (e) { var s; return !!this.match(N.braceL) && (e.specifiers || (e.specifiers = []), (s = e.specifiers).push.apply(s, t(this.parseExportSpecifiers())), e.source = null, e.declaration = null, !0) } }, { key: "maybeParseExportDeclaration", value: function (t) { return !!this.shouldParseExportDeclaration() && (t.specifiers = [], t.source = null, t.declaration = this.parseExportDeclaration(t), !0) } }, { key: "isAsyncFunction", value: function () { if (!this.isContextual("async")) return !1; var t = this.nextTokenStart(); return !vt.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function") } }, { key: "parseExportDefaultExpression", value: function () { var t = this.startNode(), e = this.isAsyncFunction(); if (this.match(N._function) || e) return this.next(), e && this.next(), this.parseFunction(t, ns | hs, e); if (this.match(N._class)) return this.parseClass(t, !0, !0); if (this.match(N.at)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Ct.DecoratorBeforeExport), this.parseDecorators(!1), this.parseClass(t, !0, !0); if (this.match(N._const) || this.match(N._var) || this.isLet()) throw this.raise(this.state.start, Ct.UnsupportedDefaultExport); var s = this.parseMaybeAssignAllowIn(); return this.semicolon(), s } }, { key: "parseExportDeclaration", value: function (t) { return this.parseStatement(null) } }, { key: "isExportDefaultSpecifier", value: function () { if (this.match(N.name)) { var t = this.state.value; if ("async" === t && !this.state.containsEsc || "let" === t) return !1; if (("type" === t || "interface" === t) && !this.state.containsEsc) { var e = this.lookahead(); if (e.type === N.name && "from" !== e.value || e.type === N.braceL) return this.expectOnePlugin(["flow", "typescript"]), !1 } } else if (!this.match(N._default)) return !1; var s = this.nextTokenStart(), i = this.isUnparsedContextual(s, "from"); if (44 === this.input.charCodeAt(s) || this.match(N.name) && i) return !0; if (this.match(N._default) && i) { var a = this.input.charCodeAt(this.nextTokenStartSince(s + 4)); return 34 === a || 39 === a } return !1 } }, { key: "parseExportFrom", value: function (t, e) { this.eatContextual("from") ? (t.source = this.parseImportSource(), this.checkExport(t)) : e ? this.unexpected() : t.source = null, this.semicolon() } }, { key: "shouldParseExportDeclaration", value: function () { if (this.match(N.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) { if (!this.getPluginOption("decorators", "decoratorsBeforeExport")) return !0; this.unexpected(this.state.start, Ct.DecoratorBeforeExport) } return "var" === this.state.type.keyword || "const" === this.state.type.keyword || "function" === this.state.type.keyword || "class" === this.state.type.keyword || this.isLet() || this.isAsyncFunction() } }, { key: "checkExport", value: function (t, e, s, i) { if (e) if (s) { if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) { var a, r = t.declaration; "Identifier" !== r.type || "from" !== r.name || r.end - r.start != 4 || (null == (a = r.extra) ? void 0 : a.parenthesized) || this.raise(r.start, Ct.ExportDefaultFromAsIdentifier) } } else if (t.specifiers && t.specifiers.length) for (var n = 0, o = t.specifiers; n < o.length; n++) { var h = o[n], { exported: l } = h, p = "Identifier" === l.type ? l.name : l.value; if (this.checkDuplicateExports(h, p), !i && h.local) { var { local: c } = h; "StringLiteral" === c.type ? this.raise(h.start, Ct.ExportBindingIsString, c.extra.raw, p) : (this.checkReservedWord(c.name, c.start, !0, !1), this.scope.checkLocalExport(c)) } } else if (t.declaration) if ("FunctionDeclaration" === t.declaration.type || "ClassDeclaration" === t.declaration.type) { var u = t.declaration.id; if (!u) throw new Error("Assertion failure"); this.checkDuplicateExports(t, u.name) } else if ("VariableDeclaration" === t.declaration.type) for (var d = 0, m = t.declaration.declarations; d < m.length; d++) { var f = m[d]; this.checkDeclaration(f.id) } if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length) throw this.raise(t.start, Ct.UnsupportedDecoratorExport) } }, { key: "checkDeclaration", value: function (t) { if ("Identifier" === t.type) this.checkDuplicateExports(t, t.name); else if ("ObjectPattern" === t.type) for (var e = 0, s = t.properties; e < s.length; e++) { var i = s[e]; this.checkDeclaration(i) } else if ("ArrayPattern" === t.type) for (var a = 0, r = t.elements; a < r.length; a++) { var n = r[a]; n && this.checkDeclaration(n) } else "ObjectProperty" === t.type ? this.checkDeclaration(t.value) : "RestElement" === t.type ? this.checkDeclaration(t.argument) : "AssignmentPattern" === t.type && this.checkDeclaration(t.left) } }, { key: "checkDuplicateExports", value: function (t, e) { this.state.exportedIdentifiers.indexOf(e) > -1 && this.raise(t.start, "default" === e ? Ct.DuplicateDefaultExport : Ct.DuplicateExport, e), this.state.exportedIdentifiers.push(e) } }, { key: "parseExportSpecifiers", value: function () { var t = [], e = !0; for (this.expect(N.braceL); !this.eat(N.braceR);) { if (e) e = !1; else if (this.expect(N.comma), this.eat(N.braceR)) break; var s = this.startNode(); s.local = this.parseModuleExportName(), s.exported = this.eatContextual("as") ? this.parseModuleExportName() : s.local.__clone(), t.push(this.finishNode(s, "ExportSpecifier")) } return t } }, { key: "parseModuleExportName", value: function () { if (this.match(N.string)) { this.expectPlugin("moduleStringNames"); var t = this.parseLiteral(this.state.value, "StringLiteral"), e = t.value.match(ls); return e && this.raise(t.start, Ct.ModuleExportNameHasLoneSurrogate, e[0].charCodeAt(0).toString(16)), t } return this.parseIdentifier(!0) } }, { key: "parseImport", value: function (t) { if (t.specifiers = [], !this.match(N.string)) { var e = !this.maybeParseDefaultImportSpecifier(t) || this.eat(N.comma), s = e && this.maybeParseStarImportSpecifier(t); e && !s && this.parseNamedImportSpecifiers(t), this.expectContextual("from") } t.source = this.parseImportSource(); var i = this.maybeParseImportAssertions(); if (i) t.assertions = i; else { var a = this.maybeParseModuleAttributes(); a && (t.attributes = a) } return this.semicolon(), this.finishNode(t, "ImportDeclaration") } }, { key: "parseImportSource", value: function () { return this.match(N.string) || this.unexpected(), this.parseExprAtom() } }, { key: "shouldParseDefaultImport", value: function (t) { return this.match(N.name) } }, { key: "parseImportSpecifierLocal", value: function (t, e, s, i) { e.local = this.parseIdentifier(), this.checkLVal(e.local, Y, void 0, i), t.specifiers.push(this.finishNode(e, s)) } }, { key: "parseAssertEntries", value: function () { this.expectPlugin("importAssertions"); var t = [], e = new Set; do { if (this.match(N.braceR)) break; var s = this.startNode(), i = void 0; if (i = this.match(N.string) ? this.parseLiteral(this.state.value, "StringLiteral") : this.parseIdentifier(!0), this.next(), s.key = i, "type" !== s.key.name && this.raise(s.key.start, Ct.ModuleAttributeDifferentFromType, s.key.name), e.has(s.key.name) && this.raise(s.key.start, Ct.ModuleAttributesWithDuplicateKeys, s.key.name), e.add(s.key.name), !this.match(N.string)) throw this.unexpected(this.state.start, Ct.ModuleAttributeInvalidValue); s.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s, "ImportAttribute"), t.push(s) } while (this.eat(N.comma)); return t } }, { key: "maybeParseModuleAttributes", value: function () { if (!this.match(N._with) || this.hasPrecedingLineBreak()) return this.hasPlugin("moduleAttributes") ? [] : null; this.expectPlugin("moduleAttributes"), this.next(); var t = [], e = new Set; do { var s = this.startNode(); if (s.key = this.parseIdentifier(!0), "type" !== s.key.name && this.raise(s.key.start, Ct.ModuleAttributeDifferentFromType, s.key.name), e.has(s.key.name) && this.raise(s.key.start, Ct.ModuleAttributesWithDuplicateKeys, s.key.name), e.add(s.key.name), this.expect(N.colon), !this.match(N.string)) throw this.unexpected(this.state.start, Ct.ModuleAttributeInvalidValue); s.value = this.parseLiteral(this.state.value, "StringLiteral"), this.finishNode(s, "ImportAttribute"), t.push(s) } while (this.eat(N.comma)); return t } }, { key: "maybeParseImportAssertions", value: function () { if (!this.match(N.name) || "assert" !== this.state.value || this.hasPrecedingLineBreak()) return this.hasPlugin("importAssertions") ? [] : null; this.expectPlugin("importAssertions"), this.next(), this.eat(N.braceL); var t = this.parseAssertEntries(); return this.eat(N.braceR), t } }, { key: "maybeParseDefaultImportSpecifier", value: function (t) { return !!this.shouldParseDefaultImport(t) && (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), !0) } }, { key: "maybeParseStarImportSpecifier", value: function (t) { if (this.match(N.star)) { var e = this.startNode(); return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier", "import namespace specifier"), !0 } return !1 } }, { key: "parseNamedImportSpecifiers", value: function (t) { var e = !0; for (this.expect(N.braceL); !this.eat(N.braceR);) { if (e) e = !1; else { if (this.eat(N.colon)) throw this.raise(this.state.start, Ct.DestructureNamedImport); if (this.expect(N.comma), this.eat(N.braceR)) break } this.parseImportSpecifier(t) } } }, { key: "parseImportSpecifier", value: function (t) { var e = this.startNode(); if (e.imported = this.parseModuleExportName(), this.eatContextual("as")) e.local = this.parseIdentifier(); else { var { imported: s } = e; if ("StringLiteral" === s.type) throw this.raise(e.start, Ct.ImportBindingIsString, s.value); this.checkReservedWord(s.name, e.start, !0, !0), e.local = s.__clone() } this.checkLVal(e.local, Y, void 0, "import specifier"), t.specifiers.push(this.finishNode(e, "ImportSpecifier")) } }]), i }(), cs = function t() { x(this, t), this.privateNames = new Set, this.loneAccessors = new Map, this.undefinedPrivateNames = new Map }, us = function () { function t(e) { x(this, t), this.stack = [], this.raise = void 0, this.undefinedPrivateNames = new Map, this.raise = e } return v(t, [{ key: "current", value: function () { return this.stack[this.stack.length - 1] } }, { key: "enter", value: function () { this.stack.push(new cs) } }, { key: "exit", value: function () { for (var t = this.stack.pop(), e = this.current(), s = 0, i = Array.from(t.undefinedPrivateNames); s < i.length; s++) { var [a, r] = i[s]; e ? e.undefinedPrivateNames.has(a) || e.undefinedPrivateNames.set(a, r) : this.raise(r, Ct.InvalidPrivateFieldResolution, a) } } }, { key: "declarePrivateName", value: function (t, e, s) { var i = this.current(), a = i.privateNames.has(t); if (e & ct) { var r = a && i.loneAccessors.get(t); if (r) (a = (r & ct) === (e & ct) || (r & ht) !== (e & ht)) || i.loneAccessors.delete(t); else a || i.loneAccessors.set(t, e) } a && this.raise(s, Ct.PrivateNameRedeclaration, t), i.privateNames.add(t), i.undefinedPrivateNames.delete(t) } }, { key: "usePrivateName", value: function (t, e) { for (var s, i = 0, a = this.stack; i < a.length; i++)if ((s = a[i]).privateNames.has(t)) return; s ? s.undefinedPrivateNames.set(t, e) : this.raise(e, Ct.InvalidPrivateFieldResolution, t) } }]), t }(), ds = function (t) { l(s, ps); var e = c(s); function s(t, i) { var a; x(this, s), t = Ve(t); var r = (a = e.call(this, t, i)).getScopeHandler(); return a.options = t, a.inModule = "module" === a.options.sourceType, a.scope = new r(a.raise.bind(d(a)), a.inModule), a.prodParam = new Ae, a.classScope = new us(a.raise.bind(d(a))), a.plugins = ms(a.options.plugins), a.filename = t.sourceFilename, a } return v(s, [{ key: "getScopeHandler", value: function () { return ve } }, { key: "parse", value: function () { var t = ke; this.hasPlugin("topLevelAwait") && this.inModule && (t |= be), this.scope.enter(L), this.prodParam.enter(t); var e = this.startNode(), s = this.startNode(); return this.nextToken(), e.errors = null, this.parseTopLevel(e, s), e.errors = this.state.errors, e } }]), s }(); function ms(t) { for (var e = new Map, s = 0; s < t.length; s++) { var i = t[s], [a, r] = Array.isArray(i) ? i : [i, {}]; e.has(a) || e.set(a, r || {}) } return e } function fs(t, e) { var s; if ("unambiguous" !== (null == (s = e) ? void 0 : s.sourceType)) return vs(e, t).parse(); e = Object.assign({}, e); try { e.sourceType = "module"; var i = vs(e, t), a = i.parse(); if (i.sawUnambiguousESM) return a; if (i.ambiguousScriptDifferentAst) try { return e.sourceType = "script", vs(e, t).parse() } catch (r) { } else a.program.sourceType = "script"; return a } catch (n) { try { return e.sourceType = "script", vs(e, t).parse() } catch (o) { } throw n } } function ys(t, e) { var s = vs(e, t); return s.options.strictMode && (s.state.strict = !0), s.getExpression() } function vs(t, e) { var s = ds; return (null == t ? void 0 : t.plugins) && (_e(t.plugins), s = Ps(t.plugins)), new s(t, e) } var xs = {}; function Ps(t) { var e = Ue.filter(function (e) { return Re(t, e) }), s = e.join("/"), i = xs[s]; if (!i) { i = ds; for (var a = 0; a < e.length; a++) { var r = e[a]; i = je[r](i) } xs[s] = i } return i } exports.parse = fs, exports.parseExpression = ys, exports.tokTypes = N;
    }, {}], "q7b5": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.walk = i, exports.asyncWalk = l; class e { constructor() { e.prototype.__init.call(this), e.prototype.__init2.call(this), e.prototype.__init3.call(this), e.prototype.__init4.call(this) } __init() { this.should_skip = !1 } __init2() { this.should_remove = !1 } __init3() { this.replacement = null } __init4() { this.context = { skip: () => this.should_skip = !0, remove: () => this.should_remove = !0, replace: e => this.replacement = e } } replace(e, t, s, i) { e && (null !== s ? e[t][s] = i : e[t] = i) } remove(e, t, s) { e && (null !== s ? e[t].splice(s, 1) : delete e[t]) } } class t extends e { constructor(e) { super(), this.enter = e.enter, this.leave = e.leave } visit(e, t, s, i, l, r) { if (e) { if (s) { const i = this.should_skip, h = this.should_remove, o = this.replacement; this.should_skip = !1, this.should_remove = !1, this.replacement = null, s.call(this.context, e, t, l, r), this.replacement && (e = this.replacement, this.replace(t, l, r, e)), this.should_remove && this.remove(t, l, r); const n = this.should_skip, c = this.should_remove; if (this.should_skip = i, this.should_remove = h, this.replacement = o, n) return e; if (c) return null } for (const t in e) { const l = e[t]; if ("object" == typeof l) if (Array.isArray(l)) for (let r = 0; r < l.length; r += 1)null !== l[r] && "string" == typeof l[r].type && (this.visit(l[r], e, s, i, t, r) || r--); else null !== l && "string" == typeof l.type && this.visit(l, e, s, i, t, null) } if (i) { const s = this.replacement, h = this.should_remove; this.replacement = null, this.should_remove = !1, i.call(this.context, e, t, l, r), this.replacement && (e = this.replacement, this.replace(t, l, r, e)), this.should_remove && this.remove(t, l, r); const o = this.should_remove; if (this.replacement = s, this.should_remove = h, o) return null } } return e } } class s extends e { constructor(e) { super(), this.enter = e.enter, this.leave = e.leave } async visit(e, t, s, i, l, r) { if (e) { if (s) { const i = this.should_skip, h = this.should_remove, o = this.replacement; this.should_skip = !1, this.should_remove = !1, this.replacement = null, await s.call(this.context, e, t, l, r), this.replacement && (e = this.replacement, this.replace(t, l, r, e)), this.should_remove && this.remove(t, l, r); const n = this.should_skip, c = this.should_remove; if (this.should_skip = i, this.should_remove = h, this.replacement = o, n) return e; if (c) return null } for (const t in e) { const l = e[t]; if ("object" == typeof l) if (Array.isArray(l)) for (let r = 0; r < l.length; r += 1)null !== l[r] && "string" == typeof l[r].type && (await this.visit(l[r], e, s, i, t, r) || r--); else null !== l && "string" == typeof l.type && await this.visit(l, e, s, i, t, null) } if (i) { const s = this.replacement, h = this.should_remove; this.replacement = null, this.should_remove = !1, await i.call(this.context, e, t, l, r), this.replacement && (e = this.replacement, this.replace(t, l, r, e)), this.should_remove && this.remove(t, l, r); const o = this.should_remove; if (this.replacement = s, this.should_remove = h, o) return null } } return e } } function i(e, s) { return new t(s).visit(e, null, s.enter, s.leave) } async function l(e, t) { const i = new s(t); return await i.visit(e, null, t.enter, t.leave) }
    }, {}], "saIb": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.advancePositionWithClone = ae, exports.advancePositionWithMutation = ue, exports.assert = de, exports.baseCompile = Mn, exports.baseParse = Ce, exports.buildProps = vn, exports.buildSlots = fn, exports.createArrayExpression = F, exports.createAssignmentExpression = Q, exports.createBlockStatement = Y, exports.createCacheExpression = J, exports.createCallExpression = G, exports.createCompilerError = s, exports.createCompoundExpression = W, exports.createConditionalExpression = z, exports.createForLoopParams = ln, exports.createFunctionExpression = q, exports.createIfStatement = X, exports.createInterpolation = K, exports.createObjectExpression = U, exports.createObjectProperty = H, exports.createReturnStatement = te, exports.createRoot = D, exports.createSequenceExpression = ee, exports.createSimpleExpression = j, exports.createStructuralDirectiveTransform = ut, exports.createTemplateLiteral = Z, exports.createTransformContext = it, exports.createVNodeCall = B, exports.findDir = fe, exports.findProp = he, exports.generate = ht, exports.getBaseTransformPreset = An, exports.getInnerRange = pe, exports.hasDynamicKeyVBind = ge, exports.hasScopeRef = Ne, exports.injectProp = Ee, exports.isBindKey = me, exports.isCoreComponent = se, exports.isSlotOutlet = Se, exports.isTemplateNode = ve, exports.isText = xe, exports.isVSlot = ye, exports.processExpression = Ut, exports.processFor = tn, exports.processIf = zt, exports.processSlotOutlet = In, exports.registerRuntimeHelpers = L, exports.resolveComponentType = yn, exports.toValidAssetId = be, exports.transform = ct, exports.traverseNode = at, Object.defineProperty(exports, "generateCodeFrame", { enumerable: !0, get: function () { return e.generateCodeFrame } }), exports.transformOn = exports.transformModel = exports.transformExpression = exports.transformElement = exports.transformBind = exports.trackVForSlotScopes = exports.trackSlotScopes = exports.noopDirectiveTransform = exports.locStub = exports.isStaticExp = exports.isSimpleIdentifier = exports.isMemberExpression = exports.isBuiltInType = exports.helperNameMap = exports.WITH_SCOPE_ID = exports.WITH_DIRECTIVES = exports.WITH_CTX = exports.TO_HANDLER_KEY = exports.TO_HANDLERS = exports.TO_DISPLAY_STRING = exports.TELEPORT = exports.SUSPENSE = exports.SET_BLOCK_TRACKING = exports.RESOLVE_DYNAMIC_COMPONENT = exports.RESOLVE_DIRECTIVE = exports.RESOLVE_COMPONENT = exports.RENDER_SLOT = exports.RENDER_LIST = exports.PUSH_SCOPE_ID = exports.POP_SCOPE_ID = exports.OPEN_BLOCK = exports.MERGE_PROPS = exports.KEEP_ALIVE = exports.FRAGMENT = exports.CREATE_VNODE = exports.CREATE_TEXT = exports.CREATE_STATIC = exports.CREATE_SLOTS = exports.CREATE_COMMENT = exports.CREATE_BLOCK = exports.CAPITALIZE = exports.CAMELIZE = exports.BASE_TRANSITION = void 0; var e = require("@vue/shared"), t = require("@babel/parser"), n = require("estree-walker"); function o(e) { throw e } function s(e, t, n, o) { const s = new SyntaxError(String(e)); return s.code = e, s.loc = t, s } const r = { 0: "Illegal comment.", 1: "CDATA section is allowed only in XML context.", 2: "Duplicate attribute.", 3: "End tag cannot have attributes.", 4: "Illegal '/' in tags.", 5: "Unexpected EOF in tag.", 6: "Unexpected EOF in CDATA section.", 7: "Unexpected EOF in comment.", 8: "Unexpected EOF in script.", 9: "Unexpected EOF in tag.", 10: "Incorrectly closed comment.", 11: "Incorrectly opened comment.", 12: "Illegal tag name. Use '&lt;' to print '<'.", 13: "Attribute value was expected.", 14: "End tag name was expected.", 15: "Whitespace was expected.", 16: "Unexpected '\x3c!--' in comment.", 17: "Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).", 18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).", 19: "Attribute name cannot start with '='.", 21: "'<?' is allowed only in XML context.", 22: "Illegal '/' in tags.", 23: "Invalid end tag.", 24: "Element is missing end tag.", 25: "Interpolation end sign was not found.", 26: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.", 27: "v-if/v-else-if is missing expression.", 28: "v-if/else branches must use unique keys.", 29: "v-else/v-else-if has no adjacent v-if.", 30: "v-for is missing expression.", 31: "v-for has invalid expression.", 32: "<template v-for> key should be placed on the <template> tag.", 33: "v-bind is missing expression.", 34: "v-on is missing expression.", 35: "Unexpected custom directive on <slot> outlet.", 36: "Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.", 37: "Duplicate slot names found. ", 38: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.", 39: "v-slot can only be used on components or <template> tags.", 40: "v-model is missing expression.", 41: "v-model value must be a valid JavaScript member expression.", 42: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.", 43: "Error parsing JavaScript expression: ", 44: "<KeepAlive> expects exactly one child component.", 45: '"prefixIdentifiers" option is not supported in this build of compiler.', 46: "ES module mode is not supported in this build of compiler.", 47: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.', 48: '"scopeId" option is only supported in module mode.' }, i = Symbol(""); exports.FRAGMENT = i; const c = Symbol(""); exports.TELEPORT = c; const l = Symbol(""); exports.SUSPENSE = l; const p = Symbol(""); exports.KEEP_ALIVE = p; const a = Symbol(""); exports.BASE_TRANSITION = a; const u = Symbol(""); exports.OPEN_BLOCK = u; const d = Symbol(""); exports.CREATE_BLOCK = d; const f = Symbol(""); exports.CREATE_VNODE = f; const h = Symbol(""); exports.CREATE_COMMENT = h; const m = Symbol(""); exports.CREATE_TEXT = m; const g = Symbol(""); exports.CREATE_STATIC = g; const x = Symbol(""); exports.RESOLVE_COMPONENT = x; const y = Symbol(""); exports.RESOLVE_DYNAMIC_COMPONENT = y; const v = Symbol(""); exports.RESOLVE_DIRECTIVE = v; const S = Symbol(""); exports.WITH_DIRECTIVES = S; const E = Symbol(""); exports.RENDER_LIST = E; const b = Symbol(""); exports.RENDER_SLOT = b; const N = Symbol(""); exports.CREATE_SLOTS = N; const T = Symbol(""); exports.TO_DISPLAY_STRING = T; const I = Symbol(""); exports.MERGE_PROPS = I; const O = Symbol(""); exports.TO_HANDLERS = O; const C = Symbol(""); exports.CAMELIZE = C; const _ = Symbol(""); exports.CAPITALIZE = _; const P = Symbol(""); exports.TO_HANDLER_KEY = P; const $ = Symbol(""); exports.SET_BLOCK_TRACKING = $; const k = Symbol(""); exports.PUSH_SCOPE_ID = k; const w = Symbol(""); exports.POP_SCOPE_ID = w; const R = Symbol(""); exports.WITH_SCOPE_ID = R; const A = Symbol(""); exports.WITH_CTX = A; const M = { [i]: "Fragment", [c]: "Teleport", [l]: "Suspense", [p]: "KeepAlive", [a]: "BaseTransition", [u]: "openBlock", [d]: "createBlock", [f]: "createVNode", [h]: "createCommentVNode", [m]: "createTextVNode", [g]: "createStaticVNode", [x]: "resolveComponent", [y]: "resolveDynamicComponent", [v]: "resolveDirective", [S]: "withDirectives", [E]: "renderList", [b]: "renderSlot", [N]: "createSlots", [T]: "toDisplayString", [I]: "mergeProps", [O]: "toHandlers", [C]: "camelize", [_]: "capitalize", [P]: "toHandlerKey", [$]: "setBlockTracking", [k]: "pushScopeId", [w]: "popScopeId", [R]: "withScopeId", [A]: "withCtx" }; function L(e) { Object.getOwnPropertySymbols(e).forEach(t => { M[t] = e[t] }) } exports.helperNameMap = M; const V = { source: "", start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } }; function D(e, t = V) { return { type: 0, children: e, helpers: [], components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: void 0, loc: t } } function B(e, t, n, o, s, r, i, c = !1, l = !1, p = V) { return e && (c ? (e.helper(u), e.helper(d)) : e.helper(f), i && e.helper(S)), { type: 13, tag: t, props: n, children: o, patchFlag: s, dynamicProps: r, directives: i, isBlock: c, disableTracking: l, loc: p } } function F(e, t = V) { return { type: 17, loc: t, elements: e } } function U(e, t = V) { return { type: 15, loc: t, properties: e } } function H(t, n) { return { type: 16, loc: V, key: (0, e.isString)(t) ? j(t, !0) : t, value: n } } function j(e, t, n = V, o = !1) { return { type: 4, loc: n, isConstant: o, content: e, isStatic: t } } function K(t, n) { return { type: 5, loc: n, content: (0, e.isString)(t) ? j(t, !1, n) : t } } function W(e, t = V) { return { type: 8, loc: t, children: e } } function G(e, t = [], n = V) { return { type: 14, loc: n, callee: e, arguments: t } } function q(e, t, n = !1, o = !1, s = V) { return { type: 18, params: e, returns: t, newline: n, isSlot: o, loc: s } } function z(e, t, n, o = !0) { return { type: 19, test: e, consequent: t, alternate: n, newline: o, loc: V } } function J(e, t, n = !1) { return { type: 20, index: e, value: t, isVNode: n, loc: V } } function Y(e) { return { type: 21, body: e, loc: V } } function Z(e) { return { type: 22, elements: e, loc: V } } function X(e, t, n) { return { type: 23, test: e, consequent: t, alternate: n, loc: V } } function Q(e, t) { return { type: 24, left: e, right: t, loc: V } } function ee(e) { return { type: 25, expressions: e, loc: V } } function te(e) { return { type: 26, returns: e, loc: V } } exports.locStub = V; const ne = e => 4 === e.type && e.isStatic; exports.isStaticExp = ne; const oe = (t, n) => t === n || t === (0, e.hyphenate)(n); function se(e) { return oe(e, "Teleport") ? c : oe(e, "Suspense") ? l : oe(e, "KeepAlive") ? p : oe(e, "BaseTransition") ? a : void 0 } exports.isBuiltInType = oe; const re = /^\d|[^\$\w]/, ie = e => !re.test(e); exports.isSimpleIdentifier = ie; const ce = /^[A-Za-z_$][\w$]*(?:\s*\.\s*[A-Za-z_$][\w$]*|\[[^\]]+\])*$/, le = e => !!e && ce.test(e.trim()); function pe(e, t, n) { const o = { source: e.source.substr(t, n), start: ae(e.start, e.source, t), end: e.end }; return null != n && (o.end = ae(e.start, e.source, t + n)), o } function ae(t, n, o = n.length) { return ue((0, e.extend)({}, t), n, o) } function ue(e, t, n = t.length) { let o = 0, s = -1; for (let r = 0; r < n; r++)10 === t.charCodeAt(r) && (o++, s = r); return e.offset += n, e.line += o, e.column = -1 === s ? e.column + n : n - s, e } function de(e, t) { if (!e) throw new Error(t || "unexpected compiler condition") } function fe(t, n, o = !1) { for (let s = 0; s < t.props.length; s++) { const r = t.props[s]; if (7 === r.type && (o || r.exp) && ((0, e.isString)(n) ? r.name === n : n.test(r.name))) return r } } function he(e, t, n = !1, o = !1) { for (let s = 0; s < e.props.length; s++) { const r = e.props[s]; if (6 === r.type) { if (n) continue; if (r.name === t && (r.value || o)) return r } else if ("bind" === r.name && (r.exp || o) && me(r.arg, t)) return r } } function me(e, t) { return !(!e || !ne(e) || e.content !== t) } function ge(e) { return e.props.some(e => !(7 !== e.type || "bind" !== e.name || e.arg && 4 === e.arg.type && e.arg.isStatic)) } function xe(e) { return 5 === e.type || 2 === e.type } function ye(e) { return 7 === e.type && "slot" === e.name } function ve(e) { return 1 === e.type && 3 === e.tagType } function Se(e) { return 1 === e.type && 2 === e.tagType } function Ee(t, n, o) { let s; const r = 13 === t.type ? t.props : t.arguments[2]; if (null == r || (0, e.isString)(r)) s = U([n]); else if (14 === r.type) { const t = r.arguments[0]; (0, e.isString)(t) || 15 !== t.type ? r.callee === O ? s = G(o.helper(I), [U([n]), r]) : r.arguments.unshift(U([n])) : t.properties.unshift(n), !s && (s = r) } else if (15 === r.type) { let e = !1; if (4 === n.key.type) { const t = n.key.content; e = r.properties.some(e => 4 === e.key.type && e.key.content === t) } e || r.properties.unshift(n), s = r } else s = G(o.helper(I), [U([n]), r]); 13 === t.type ? t.props = s : t.arguments[2] = s } function be(e, t) { return `_${t}_${e.replace(/[^\w]/g, "_")}` } function Ne(t, n) { if (!t || 0 === Object.keys(n).length) return !1; switch (t.type) { case 1: for (let e = 0; e < t.props.length; e++) { const o = t.props[e]; if (7 === o.type && (Ne(o.arg, n) || Ne(o.exp, n))) return !0 } return t.children.some(e => Ne(e, n)); case 11: return !!Ne(t.source, n) || t.children.some(e => Ne(e, n)); case 9: return t.branches.some(e => Ne(e, n)); case 10: return !!Ne(t.condition, n) || t.children.some(e => Ne(e, n)); case 4: return !t.isStatic && ie(t.content) && !!n[t.content]; case 8: return t.children.some(t => (0, e.isObject)(t) && Ne(t, n)); case 5: case 12: return Ne(t.content, n); case 2: case 3: default: return !1 } } exports.isMemberExpression = le; const Te = /&(gt|lt|amp|apos|quot);/g, Ie = { gt: ">", lt: "<", amp: "&", apos: "'", quot: '"' }, Oe = { delimiters: ["{{", "}}"], getNamespace: () => 0, getTextMode: () => 0, isVoidTag: e.NO, isPreTag: e.NO, isCustomElement: e.NO, decodeEntities: e => e.replace(Te, (e, t) => Ie[t]), onError: o, comments: !1 }; function Ce(e, t = {}) { const n = _e(e, t), o = je(n); return D(Pe(n, 0, []), Ke(n, o)) } function _e(t, n) { const o = (0, e.extend)({}, Oe); for (const e in n) o[e] = n[e] || Oe[e]; return { options: o, column: 1, line: 1, offset: 0, originalSource: t, source: t, inPre: !1, inVPre: !1 } } function Pe(t, n, o) { const s = We(o), r = s ? s.ns : 0, i = []; for (; !Ze(t, n, o);) { const c = t.source; let l = void 0; if (0 === n || 1 === n) if (!t.inVPre && Ge(c, t.options.delimiters[0])) l = Fe(t, n); else if (0 === n && "<" === c[0]) if (1 === c.length) Ye(t, 5, 1); else if ("!" === c[1]) Ge(c, "\x3c!--") ? l = we(t) : Ge(c, "<!DOCTYPE") ? l = Re(t) : Ge(c, "<![CDATA[") ? 0 !== r ? l = ke(t, o) : (Ye(t, 1), l = Re(t)) : (Ye(t, 11), l = Re(t)); else if ("/" === c[1]) if (2 === c.length) Ye(t, 5, 2); else { if (">" === c[2]) { Ye(t, 14, 2), qe(t, 3); continue } if (/[a-z]/i.test(c[2])) { Ye(t, 23), Le(t, 1, s); continue } Ye(t, 12, 2), l = Re(t) } else /[a-z]/i.test(c[1]) ? l = Ae(t, o) : "?" === c[1] ? (Ye(t, 21, 1), l = Re(t)) : Ye(t, 12, 1); if (l || (l = Ue(t, n)), (0, e.isArray)(l)) for (let e = 0; e < l.length; e++)$e(i, l[e]); else $e(i, l) } let c = !1; if (2 !== n) { for (let e = 0; e < i.length; e++) { const n = i[e]; if (!t.inPre && 2 === n.type) if (/[^\t\r\n\f ]/.test(n.content)) n.content = n.content.replace(/[\t\r\n\f ]+/g, " "); else { const t = i[e - 1], o = i[e + 1]; !t || !o || 3 === t.type || 3 === o.type || 1 === t.type && 1 === o.type && /[\r\n]/.test(n.content) ? (c = !0, i[e] = null) : n.content = " " } 3 !== n.type || t.options.comments || (c = !0, i[e] = null) } if (t.inPre && s && t.options.isPreTag(s.tag)) { const e = i[0]; e && 2 === e.type && (e.content = e.content.replace(/^\r?\n/, "")) } } return c ? i.filter(Boolean) : i } function $e(e, t) { if (2 === t.type) { const n = We(e); if (n && 2 === n.type && n.loc.end.offset === t.loc.start.offset) return n.content += t.content, n.loc.end = t.loc.end, void (n.loc.source += t.loc.source) } e.push(t) } function ke(e, t) { qe(e, 9); const n = Pe(e, 3, t); return 0 === e.source.length ? Ye(e, 6) : qe(e, 3), n } function we(e) { const t = je(e); let n; const o = /--(\!)?>/.exec(e.source); if (o) { o.index <= 3 && Ye(e, 0), o[1] && Ye(e, 10), n = e.source.slice(4, o.index); const t = e.source.slice(0, o.index); let s = 1, r = 0; for (; -1 !== (r = t.indexOf("\x3c!--", s));)qe(e, r - s + 1), r + 4 < t.length && Ye(e, 16), s = r + 1; qe(e, o.index + o[0].length - s + 1) } else n = e.source.slice(4), qe(e, e.source.length), Ye(e, 7); return { type: 3, content: n, loc: Ke(e, t) } } function Re(e) { const t = je(e), n = "?" === e.source[1] ? 1 : 2; let o; const s = e.source.indexOf(">"); return -1 === s ? (o = e.source.slice(n), qe(e, e.source.length)) : (o = e.source.slice(n, s), qe(e, s + 1)), { type: 3, content: o, loc: Ke(e, t) } } function Ae(e, t) { const n = e.inPre, o = e.inVPre, s = We(t), r = Le(e, 0, s), i = e.inPre && !n, c = e.inVPre && !o; if (r.isSelfClosing || e.options.isVoidTag(r.tag)) return r; t.push(r); const l = e.options.getTextMode(r, s), p = Pe(e, l, t); if (t.pop(), r.children = p, Xe(e.source, r.tag)) Le(e, 1, s); else if (Ye(e, 24, 0, r.loc.start), 0 === e.source.length && "script" === r.tag.toLowerCase()) { const t = p[0]; t && Ge(t.loc.source, "\x3c!--") && Ye(e, 8) } return r.loc = Ke(e, r.loc.start), i && (e.inPre = !1), c && (e.inVPre = !1), r } const Me = (0, e.makeMap)("if,else,else-if,for,slot"); function Le(t, n, o) { const s = je(t), r = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(t.source), i = r[1], c = t.options.getNamespace(i, o); qe(t, r[0].length), ze(t); const l = je(t), p = t.source; let a = Ve(t, n); t.options.isPreTag(i) && (t.inPre = !0), !t.inVPre && a.some(e => 7 === e.type && "pre" === e.name) && (t.inVPre = !0, (0, e.extend)(t, l), t.source = p, a = Ve(t, n).filter(e => "v-pre" !== e.name)); let u = !1; 0 === t.source.length ? Ye(t, 9) : (u = Ge(t.source, "/>"), 1 === n && u && Ye(t, 4), qe(t, u ? 2 : 1)); let d = 0; const f = t.options; if (!t.inVPre && !f.isCustomElement(i)) { const e = a.some(e => 7 === e.type && "is" === e.name); f.isNativeTag && !e ? f.isNativeTag(i) || (d = 1) : (e || se(i) || f.isBuiltInComponent && f.isBuiltInComponent(i) || /^[A-Z]/.test(i) || "component" === i) && (d = 1), "slot" === i ? d = 2 : "template" === i && a.some(e => 7 === e.type && Me(e.name)) && (d = 3) } return { type: 1, ns: c, tag: i, tagType: d, props: a, isSelfClosing: u, children: [], loc: Ke(t, s), codegenNode: void 0 } } function Ve(e, t) { const n = [], o = new Set; for (; e.source.length > 0 && !Ge(e.source, ">") && !Ge(e.source, "/>");) { if (Ge(e.source, "/")) { Ye(e, 22), qe(e, 1), ze(e); continue } 1 === t && Ye(e, 3); const s = De(e, o); 0 === t && n.push(s), /^[^\t\r\n\f />]/.test(e.source) && Ye(e, 15), ze(e) } return n } function De(e, t) { const n = je(e), o = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(e.source)[0]; t.has(o) && Ye(e, 2), t.add(o), "=" === o[0] && Ye(e, 19); { const t = /["'<]/g; let n; for (; n = t.exec(o);)Ye(e, 17, n.index) } qe(e, o.length); let s = void 0; /^[\t\r\n\f ]*=/.test(e.source) && (ze(e), qe(e, 1), ze(e), (s = Be(e)) || Ye(e, 13)); const r = Ke(e, n); if (!e.inVPre && /^(v-|:|@|#)/.test(o)) { const t = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(o), i = t[1] || (Ge(o, ":") ? "bind" : Ge(o, "@") ? "on" : "slot"); let c; if (t[2]) { const s = "slot" === i, r = o.indexOf(t[2]), l = Ke(e, Je(e, n, r), Je(e, n, r + t[2].length + (s && t[3] || "").length)); let p = t[2], a = !0; p.startsWith("[") ? (a = !1, p.endsWith("]") || Ye(e, 26), p = p.substr(1, p.length - 2)) : s && (p += t[3] || ""), c = { type: 4, content: p, isStatic: a, isConstant: a, loc: l } } if (s && s.isQuoted) { const e = s.loc; e.start.offset++, e.start.column++, e.end = ae(e.start, s.content), e.source = e.source.slice(1, -1) } return { type: 7, name: i, exp: s && { type: 4, content: s.content, isStatic: !1, isConstant: !1, loc: s.loc }, arg: c, modifiers: t[3] ? t[3].substr(1).split(".") : [], loc: r } } return { type: 6, name: o, value: s && { type: 2, content: s.content, loc: s.loc }, loc: r } } function Be(e) { const t = je(e); let n; const o = e.source[0], s = '"' === o || "'" === o; if (s) { qe(e, 1); const t = e.source.indexOf(o); -1 === t ? n = He(e, e.source.length, 4) : (n = He(e, t, 4), qe(e, 1)) } else { const t = /^[^\t\r\n\f >]+/.exec(e.source); if (!t) return; const o = /["'<=`]/g; let s; for (; s = o.exec(t[0]);)Ye(e, 18, s.index); n = He(e, t[0].length, 4) } return { content: n, isQuoted: s, loc: Ke(e, t) } } function Fe(e, t) { const [n, o] = e.options.delimiters, s = e.source.indexOf(o, n.length); if (-1 === s) return void Ye(e, 25); const r = je(e); qe(e, n.length); const i = je(e), c = je(e), l = s - n.length, p = e.source.slice(0, l), a = He(e, l, t), u = a.trim(), d = a.indexOf(u); return d > 0 && ue(i, p, d), ue(c, p, l - (a.length - u.length - d)), qe(e, o.length), { type: 5, content: { type: 4, isStatic: !1, isConstant: !1, content: u, loc: Ke(e, i, c) }, loc: Ke(e, r) } } function Ue(e, t) { const n = ["<", e.options.delimiters[0]]; 3 === t && n.push("]]>"); let o = e.source.length; for (let r = 0; r < n.length; r++) { const t = e.source.indexOf(n[r], 1); -1 !== t && o > t && (o = t) } const s = je(e); return { type: 2, content: He(e, o, t), loc: Ke(e, s) } } function He(e, t, n) { const o = e.source.slice(0, t); return qe(e, t), 2 === n || 3 === n || -1 === o.indexOf("&") ? o : e.options.decodeEntities(o, 4 === n) } function je(e) { const { column: t, line: n, offset: o } = e; return { column: t, line: n, offset: o } } function Ke(e, t, n) { return { start: t, end: n = n || je(e), source: e.originalSource.slice(t.offset, n.offset) } } function We(e) { return e[e.length - 1] } function Ge(e, t) { return e.startsWith(t) } function qe(e, t) { const { source: n } = e; ue(e, n, t), e.source = n.slice(t) } function ze(e) { const t = /^[\t\r\n\f ]+/.exec(e.source); t && qe(e, t[0].length) } function Je(e, t, n) { return ae(t, e.originalSource.slice(t.offset, n), n) } function Ye(e, t, n, o = je(e)) { n && (o.offset += n, o.column += n), e.options.onError(s(t, { start: o, end: o, source: "" })) } function Ze(e, t, n) { const o = e.source; switch (t) { case 0: if (Ge(o, "</")) for (let e = n.length - 1; e >= 0; --e)if (Xe(o, n[e].tag)) return !0; break; case 1: case 2: { const e = We(n); if (e && Xe(o, e.tag)) return !0; break } case 3: if (Ge(o, "]]>")) return !0 }return !o } function Xe(e, t) { return Ge(e, "</") && e.substr(2, t.length).toLowerCase() === t.toLowerCase() && /[\t\r\n\f />]/.test(e[2 + t.length] || ">") } function Qe(e, t) { tt(e, t, new Map, et(e, e.children[0])) } function et(e, t) { const { children: n } = e; return 1 === n.length && 1 === t.type && !Se(t) } function tt(e, t, n, o = !1) { let s = !1, r = !1; const { children: i } = e; for (let c = 0; c < i.length; c++) { const e = i[c]; if (1 === e.type && 0 === e.tagType) { let i; if (!o && (i = nt(e, n)) > 0) { 2 === i && (r = !0), e.codegenNode.patchFlag = "-1", e.codegenNode = t.hoist(e.codegenNode), s = !0; continue } { const n = e.codegenNode; if (13 === n.type) { const o = rt(n); if (!(o && 512 !== o && 1 !== o || ot(e))) { const o = st(e); o && (n.props = t.hoist(o)) } } } } else if (12 === e.type) { const o = nt(e.content, n); o > 0 && (2 === o && (r = !0), e.codegenNode = t.hoist(e.codegenNode), s = !0) } if (1 === e.type) tt(e, t, n); else if (11 === e.type) tt(e, t, n, 1 === e.children.length); else if (9 === e.type) for (let o = 0; o < e.branches.length; o++)tt(e.branches[o], t, n, 1 === e.branches[o].children.length) } !r && s && t.transformHoist && t.transformHoist(i, t, e) } function nt(t, n = new Map) { switch (t.type) { case 1: if (0 !== t.tagType) return 0; const o = n.get(t); if (void 0 !== o) return o; const s = t.codegenNode; if (13 !== s.type) return 0; if (rt(s) || ot(t)) return n.set(t, 0), 0; { let e = 1; for (let o = 0; o < t.children.length; o++) { const s = nt(t.children[o], n); if (0 === s) return n.set(t, 0), 0; 2 === s && (e = 2) } if (2 !== e) for (let n = 0; n < t.props.length; n++) { const o = t.props[n]; 7 === o.type && "bind" === o.name && o.exp && (8 === o.exp.type || o.exp.isRuntimeConstant) && (e = 2) } return s.isBlock && (s.isBlock = !1), n.set(t, e), e } case 2: case 3: return 1; case 9: case 11: case 10: return 0; case 5: case 12: return nt(t.content, n); case 4: return t.isConstant ? t.isRuntimeConstant ? 2 : 1 : 0; case 8: let r = 1; for (let i = 0; i < t.children.length; i++) { const o = t.children[i]; if ((0, e.isString)(o) || (0, e.isSymbol)(o)) continue; const s = nt(o, n); if (0 === s) return 0; 2 === s && (r = 2) } return r; default: return 0 } } function ot(e) { const t = st(e); if (t && 15 === t.type) { const { properties: e } = t; for (let t = 0; t < e.length; t++) { const { key: n, value: o } = e[t]; if (4 !== n.type || !n.isStatic || 4 !== o.type || !o.isStatic && !o.isConstant) return !0 } } return !1 } function st(e) { const t = e.codegenNode; if (13 === t.type) return t.props } function rt(e) { const t = e.patchFlag; return t ? parseInt(t, 10) : void 0 } function it(t, { prefixIdentifiers: n = !1, hoistStatic: s = !1, cacheHandlers: r = !1, nodeTransforms: i = [], directiveTransforms: c = {}, transformHoist: l = null, isBuiltInComponent: p = e.NOOP, isCustomElement: a = e.NOOP, expressionPlugins: u = [], scopeId: d = null, ssr: f = !1, ssrCssVars: h = "", bindingMetadata: m = {}, onError: g = o }) { const x = { prefixIdentifiers: n, hoistStatic: s, cacheHandlers: r, nodeTransforms: i, directiveTransforms: c, transformHoist: l, isBuiltInComponent: p, isCustomElement: a, expressionPlugins: u, scopeId: d, ssr: f, ssrCssVars: h, bindingMetadata: m, onError: g, root: t, helpers: new Set, components: new Set, directives: new Set, hoists: [], imports: new Set, temps: 0, cached: 0, identifiers: Object.create(null), scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 }, parent: null, currentNode: t, childIndex: 0, helper: e => (x.helpers.add(e), e), helperString: e => `_${M[x.helper(e)]}`, replaceNode(e) { x.parent.children[x.childIndex] = x.currentNode = e }, removeNode(e) { const t = x.parent.children, n = e ? t.indexOf(e) : x.currentNode ? x.childIndex : -1; e && e !== x.currentNode ? x.childIndex > n && (x.childIndex--, x.onNodeRemoved()) : (x.currentNode = null, x.onNodeRemoved()), x.parent.children.splice(n, 1) }, onNodeRemoved: () => { }, addIdentifiers(e) { }, removeIdentifiers(e) { }, hoist(e) { x.hoists.push(e); const t = j(`_hoisted_${x.hoists.length}`, !1, e.loc, !0); return t.hoisted = e, t }, cache: (e, t = !1) => J(++x.cached, e, t) }; return x } function ct(e, t) { const n = it(e, t); at(e, n), t.hoistStatic && Qe(e, n), t.ssr || lt(e, n), e.helpers = [...n.helpers], e.components = [...n.components], e.directives = [...n.directives], e.imports = [...n.imports], e.hoists = n.hoists, e.temps = n.temps, e.cached = n.cached } function lt(t, n) { const { helper: o } = n, { children: s } = t; if (1 === s.length) { const e = s[0]; if (et(t, e) && e.codegenNode) { const n = e.codegenNode; 13 === n.type && (n.isBlock = !0, o(u), o(d)), t.codegenNode = n } else t.codegenNode = e } else s.length > 1 && (t.codegenNode = B(n, o(i), void 0, t.children, `64 /* ${e.PatchFlagNames[64]} */`, void 0, void 0, !0)) } function pt(t, n) { let o = 0; const s = () => { o-- }; for (; o < t.children.length; o++) { const r = t.children[o]; (0, e.isString)(r) || (n.parent = t, n.childIndex = o, n.onNodeRemoved = s, at(r, n)) } } function at(t, n) { n.currentNode = t; const { nodeTransforms: o } = n, s = []; for (let i = 0; i < o.length; i++) { const r = o[i](t, n); if (r && ((0, e.isArray)(r) ? s.push(...r) : s.push(r)), !n.currentNode) return; t = n.currentNode } switch (t.type) { case 3: n.ssr || n.helper(h); break; case 5: n.ssr || n.helper(T); break; case 9: for (let e = 0; e < t.branches.length; e++)at(t.branches[e], n); break; case 10: case 11: case 1: case 0: pt(t, n) }n.currentNode = t; let r = s.length; for (; r--;)s[r]() } function ut(t, n) { const o = (0, e.isString)(t) ? e => e === t : e => t.test(e); return (e, t) => { if (1 === e.type) { const { props: s } = e; if (3 === e.tagType && s.some(ye)) return; const r = []; for (let i = 0; i < s.length; i++) { const c = s[i]; if (7 === c.type && o(c.name)) { s.splice(i, 1), i--; const o = n(e, c, t); o && r.push(o) } } return r } } } const dt = "/*#__PURE__*/"; function ft(e, { mode: t = "function", prefixIdentifiers: n = "module" === t, sourceMap: o = !1, filename: s = "template.vue.html", scopeId: r = null, optimizeImports: i = !1, runtimeGlobalName: c = "Vue", runtimeModuleName: l = "vue", ssr: p = !1 }) { const a = { mode: t, prefixIdentifiers: n, sourceMap: o, filename: s, scopeId: r, optimizeImports: i, runtimeGlobalName: c, runtimeModuleName: l, ssr: p, source: e.loc.source, code: "", column: 1, line: 1, offset: 0, indentLevel: 0, pure: !1, map: void 0, helper: e => `_${M[e]}`, push(e, t) { a.code += e }, indent() { u(++a.indentLevel) }, deindent(e = !1) { e ? --a.indentLevel : u(--a.indentLevel) }, newline() { u(a.indentLevel) } }; function u(e) { a.push("\n" + "  ".repeat(e)) } return a } function ht(e, t = {}) { const n = ft(e, t); t.onContextCreated && t.onContextCreated(n); const { mode: o, push: s, prefixIdentifiers: r, indent: i, deindent: c, newline: l, scopeId: p, ssr: a } = n, u = e.helpers.length > 0, d = !r && "module" !== o; mt(e, n); const f = t.bindingMetadata ? ", $props, $setup, $data, $options" : ""; if (s(a ? `function ssrRender(_ctx, _push, _parent, _attrs${f}) {` : `function render(_ctx, _cache${f}) {`), i(), d && (s("with (_ctx) {"), i(), u && (s(`const { ${e.helpers.map(e => `${M[e]}: _${M[e]}`).join(", ")} } = _Vue`), s("\n"), l())), e.components.length && (gt(e.components, "component", n), (e.directives.length || e.temps > 0) && l()), e.directives.length && (gt(e.directives, "directive", n), e.temps > 0 && l()), e.temps > 0) { s("let "); for (let t = 0; t < e.temps; t++)s(`${t > 0 ? ", " : ""}_temp${t}`) } return (e.components.length || e.directives.length || e.temps) && (s("\n"), l()), a || s("return "), e.codegenNode ? Et(e.codegenNode, n) : s("null"), d && (c(), s("}")), c(), s("}"), { ast: e, code: n.code, map: n.map ? n.map.toJSON() : void 0 } } function mt(e, t) { const { ssr: n, prefixIdentifiers: o, push: s, newline: r, runtimeModuleName: i, runtimeGlobalName: c } = t, l = c, p = e => `${M[e]}: _${M[e]}`; if (e.helpers.length > 0 && (s(`const _Vue = ${l}\n`), e.hoists.length)) { s(`const { ${[f, h, m, g].filter(t => e.helpers.includes(t)).map(p).join(", ")} } = _Vue\n`) } xt(e.hoists, t), r(), s("return ") } function gt(e, t, { helper: n, push: o, newline: s }) { const r = n("component" === t ? x : v); for (let i = 0; i < e.length; i++) { const n = e[i]; o(`const ${be(n, t)} = ${r}(${JSON.stringify(n)})`), i < e.length - 1 && s() } } function xt(e, t) { if (!e.length) return; t.pure = !0; const { push: n, newline: o, helper: s, scopeId: r, mode: i } = t; o(), e.forEach((e, s) => { e && (n(`const _hoisted_${s + 1} = `), Et(e, t), o()) }), t.pure = !1 } function yt(t) { return (0, e.isString)(t) || 4 === t.type || 2 === t.type || 5 === t.type || 8 === t.type } function vt(e, t) { const n = e.length > 3 || !1; t.push("["), n && t.indent(), St(e, t, n), n && t.deindent(), t.push("]") } function St(t, n, o = !1, s = !0) { const { push: r, newline: i } = n; for (let c = 0; c < t.length; c++) { const l = t[c]; (0, e.isString)(l) ? r(l) : (0, e.isArray)(l) ? vt(l, n) : Et(l, n), c < t.length - 1 && (o ? (s && r(","), i()) : s && r(", ")) } } function Et(t, n) { if ((0, e.isString)(t)) n.push(t); else if ((0, e.isSymbol)(t)) n.push(n.helper(t)); else switch (t.type) { case 1: case 9: case 11: Et(t.codegenNode, n); break; case 2: bt(t, n); break; case 4: Nt(t, n); break; case 5: Tt(t, n); break; case 12: Et(t.codegenNode, n); break; case 8: It(t, n); break; case 3: Ct(t, n); break; case 13: _t(t, n); break; case 14: $t(t, n); break; case 15: kt(t, n); break; case 17: wt(t, n); break; case 18: Rt(t, n); break; case 19: At(t, n); break; case 20: Mt(t, n); break; case 21: case 22: case 23: case 24: case 25: case 26: case 10: break; default: 0 } } function bt(e, t) { t.push(JSON.stringify(e.content), e) } function Nt(e, t) { const { content: n, isStatic: o } = e; t.push(o ? JSON.stringify(n) : n, e) } function Tt(e, t) { const { push: n, helper: o, pure: s } = t; s && n(dt), n(`${o(T)}(`), Et(e.content, t), n(")") } function It(t, n) { for (let o = 0; o < t.children.length; o++) { const s = t.children[o]; (0, e.isString)(s) ? n.push(s) : Et(s, n) } } function Ot(e, t) { const { push: n } = t; if (8 === e.type) n("["), It(e, t), n("]"); else if (e.isStatic) { n(ie(e.content) ? e.content : JSON.stringify(e.content), e) } else n(`[${e.content}]`, e) } function Ct(e, t) { 0 } function _t(e, t) { const { push: n, helper: o, pure: s } = t, { tag: r, props: i, children: c, patchFlag: l, dynamicProps: p, directives: a, isBlock: h, disableTracking: m } = e; a && n(o(S) + "("), h && n(`(${o(u)}(${m ? "true" : ""}), `), s && n(dt), n(o(h ? d : f) + "(", e), St(Pt([r, i, c, l, p]), t), n(")"), h && n(")"), a && (n(", "), Et(a, t), n(")")) } function Pt(e) { let t = e.length; for (; t-- && null == e[t];); return e.slice(0, t + 1).map(e => e || "null") } function $t(t, n) { const { push: o, helper: s, pure: r } = n, i = (0, e.isString)(t.callee) ? t.callee : s(t.callee); r && o(dt), o(i + "(", t), St(t.arguments, n), o(")") } function kt(e, t) { const { push: n, indent: o, deindent: s, newline: r } = t, { properties: i } = e; if (!i.length) return void n("{}", e); const c = i.length > 1 || !1; n(c ? "{" : "{ "), c && o(); for (let l = 0; l < i.length; l++) { const { key: e, value: o } = i[l]; Ot(e, t), n(": "), Et(o, t), l < i.length - 1 && (n(","), r()) } c && s(), n(c ? "}" : " }") } function wt(e, t) { vt(e.elements, t) } function Rt(t, n) { const { push: o, indent: s, deindent: r, scopeId: i, mode: c } = n, { params: l, returns: p, body: a, newline: u, isSlot: d } = t; d && o(`_${M[A]}(`), o("(", t), (0, e.isArray)(l) ? St(l, n) : l && Et(l, n), o(") => "), (u || a) && (o("{"), s()), p ? (u && o("return "), (0, e.isArray)(p) ? vt(p, n) : Et(p, n)) : a && Et(a, n), (u || a) && (r(), o("}")), d && o(")") } function At(e, t) { const { test: n, consequent: o, alternate: s, newline: r } = e, { push: i, indent: c, deindent: l, newline: p } = t; if (4 === n.type) { const e = !ie(n.content); e && i("("), Nt(n, t), e && i(")") } else i("("), Et(n, t), i(")"); r && c(), t.indentLevel++, r || i(" "), i("? "), Et(o, t), t.indentLevel--, r && p(), r || i(" "), i(": "); const a = 19 === s.type; a || t.indentLevel++, Et(s, t), a || t.indentLevel--, r && l(!0) } function Mt(e, t) { const { push: n, helper: o, indent: s, deindent: r, newline: i } = t; n(`_cache[${e.index}] || (`), e.isVNode && (s(), n(`${o($)}(-1),`), i()), n(`_cache[${e.index}] = `), Et(e.value, t), e.isVNode && (n(","), i(), n(`${o($)}(1),`), i(), n(`_cache[${e.index}]`), r()), n(")") } const Lt = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b"), Vt = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g; function Dt(e, t, n = !1, o = !1) { const r = e.content; if (r.trim()) try { new Function(o ? ` ${r} ` : `return ${n ? `(${r}) => {}` : `(${r})`}`) } catch (i) { let n = i.message; const o = r.replace(Vt, "").match(Lt); o && (n = `avoid using JavaScript keyword as property name: "${o[0]}"`), t.onError(s(43, e.loc, void 0, n)) } } const Bt = (0, e.makeMap)("true,false,null,this"), Ft = (e, t) => { if (5 === e.type) e.content = Ut(e.content, t); else if (1 === e.type) for (let n = 0; n < e.props.length; n++) { const o = e.props[n]; if (7 === o.type && "for" !== o.name) { const e = o.exp, n = o.arg; !e || 4 !== e.type || "on" === o.name && n || (o.exp = Ut(e, t, "slot" === o.name)), n && 4 === n.type && !n.isStatic && (o.arg = Ut(n, t)) } } }; function Ut(o, r, i = !1, c = !1) { if (!r.prefixIdentifiers || !o.content.trim()) return o; const { bindingMetadata: l } = r, p = t => { return `${(0, e.hasOwn)(l, t) ? "$" + l[t] : "_ctx"}.${t}` }, a = o.content, u = a.indexOf("(") > -1; if (ie(a)) return i || r.identifiers[a] || (0, e.isGloballyWhitelisted)(a) || Bt(a) ? r.identifiers[a] || u || (o.isConstant = !0) : o.content = p(a), o; let d; const f = c ? ` ${a} ` : `(${a})${i ? "=>{}" : ""}`; try { d = (0, t.parse)(f, { plugins: [...r.expressionPlugins, ...e.babelParserDefaultPlugins] }).program } catch (y) { return r.onError(s(43, o.loc, void 0, y.message)), o } const h = [], m = Object.create(r.identifiers); (0, n.walk)(d, { enter(e, t) { if ("Identifier" === e.type) { if (!(e => h.some(t => t.start === e.start))(e)) { const n = Gt(e, t); !m[e.name] && n ? (Kt(e, t) && (e.prefix = `${e.name}: `), e.name = p(e.name), h.push(e)) : Wt(e, t) || (n && m[e.name] || u || (e.isConstant = !0), h.push(e)) } } else Ht(e) && e.params.forEach(t => (0, n.walk)(t, { enter(t, n) { if (!("Identifier" !== t.type || Wt(t, n) || n && "AssignmentPattern" === n.type && n.right === t)) { const { name: n } = t; if (e.scopeIds && e.scopeIds.has(n)) return; n in m ? m[n]++ : m[n] = 1, (e.scopeIds || (e.scopeIds = new Set)).add(n) } } })) }, leave(e) { e !== d.body[0].expression && e.scopeIds && e.scopeIds.forEach(e => { m[e]--, 0 === m[e] && delete m[e] }) } }); const g = []; let x; return h.sort((e, t) => e.start - t.start), h.forEach((e, t) => { const n = e.start - 1, s = e.end - 1, r = h[t - 1], i = a.slice(r ? r.end - 1 : 0, n); (i.length || e.prefix) && g.push(i + (e.prefix || "")); const c = a.slice(n, s); g.push(j(e.name, !1, { source: c, start: ae(o.loc.start, c, n), end: ae(o.loc.start, c, s) }, e.isConstant)), t === h.length - 1 && s < a.length && g.push(a.slice(s)) }), g.length ? x = W(g, o.loc) : (x = o).isConstant = !u, x.identifiers = Object.keys(m), x } exports.transformExpression = Ft; const Ht = e => /Function(?:Expression|Declaration)$|Method$/.test(e.type), jt = e => e && ("ObjectProperty" === e.type || "ObjectMethod" === e.type) && !e.computed, Kt = (e, t) => jt(t) && t.value === e && "Identifier" === t.key.type && t.key.name === e.name && t.key.start === e.start, Wt = (e, t) => jt(t) && t.key === e; function Gt(t, n) { if ((!Ht(n) || n.id !== t && !n.params.includes(t)) && !Wt(t, n) && ("MemberExpression" !== n.type && "OptionalMemberExpression" !== n.type || n.property !== t || n.computed) && "ArrayPattern" !== n.type && !(0, e.isGloballyWhitelisted)(t.name) && "require" !== t.name && "arguments" !== t.name) return !0 } const qt = ut(/^(if|else|else-if)$/, (e, t, n) => zt(e, t, n, (e, t, o) => { const s = n.parent.children; let r = s.indexOf(e), i = 0; for (; r-- >= 0;) { const e = s[r]; e && 9 === e.type && (i += e.branches.length) } return () => { if (o) e.codegenNode = Yt(t, i, n); else { Qt(e.codegenNode).alternate = Yt(t, i + e.branches.length - 1, n) } } })); function zt(e, t, n, o) { if (!("else" === t.name || t.exp && t.exp.content.trim())) { const o = t.exp ? t.exp.loc : e.loc; n.onError(s(27, t.loc)), t.exp = j("true", !1, o) } if ("if" === t.name) { const s = Jt(e, t), r = { type: 9, loc: e.loc, branches: [s] }; if (n.replaceNode(r), o) return o(r, s, !0) } else { const r = n.parent.children; let i = r.indexOf(e); for (; i-- >= -1;) { const c = r[i]; if (!c || 2 !== c.type || c.content.trim().length) { if (c && 9 === c.type) { n.removeNode(); const s = Jt(e, t); 0, c.branches.push(s); const r = o && o(c, s, !1); at(s, n), r && r(), n.currentNode = null } else n.onError(s(29, e.loc)); break } n.removeNode(c) } } } function Jt(e, t) { return { type: 10, loc: e.loc, condition: "else" === t.name ? void 0 : t.exp, children: 3 !== e.tagType || fe(e, "for") ? [e] : e.children, userKey: he(e, "key") } } function Yt(e, t, n) { return e.condition ? z(e.condition, Zt(e, t, n), G(n.helper(h), ['""', "true"])) : Zt(e, t, n) } function Zt(t, n, o) { const { helper: s } = o, r = H("key", j(`${n}`, !1, V, !0)), { children: c } = t, l = c[0]; if (1 !== c.length || 1 !== l.type) { if (1 === c.length && 11 === l.type) { const e = l.codegenNode; return Ee(e, r, o), e } return B(o, s(i), U([r]), c, `64 /* ${e.PatchFlagNames[64]} */`, void 0, void 0, !0, !1, t.loc) } { const e = l.codegenNode; return 13 === e.type && (e.isBlock = !0, s(u), s(d)), Ee(e, r, o), e } } function Xt(e, t) { if (!e || e.type !== t.type) return !1; if (6 === e.type) { if (e.value.content !== t.value.content) return !1 } else { const n = e.exp, o = t.exp; if (n.type !== o.type) return !1; if (4 !== n.type || n.isStatic !== o.isStatic || n.content !== o.content) return !1 } return !0 } function Qt(e) { for (; ;)if (19 === e.type) { if (19 !== e.alternate.type) return e; e = e.alternate } else 20 === e.type && (e = e.value) } const en = ut("for", (t, n, o) => { const { helper: s } = o; return tn(t, n, o, n => { const r = G(s(E), [n.source]), c = he(t, "key"), l = c ? H("key", 6 === c.type ? j(c.value.content, !0) : c.exp) : null, p = 4 === n.source.type && n.source.isConstant, a = p ? 64 : c ? 128 : 256; return n.codegenNode = B(o, s(i), void 0, r, `${a} /* ${e.PatchFlagNames[a]} */`, void 0, void 0, !0, !p, t.loc), () => { let c; const a = ve(t), { children: f } = n; const h = 1 !== f.length || 1 !== f[0].type, m = Se(t) ? t : a && 1 === t.children.length && Se(t.children[0]) ? t.children[0] : null; m ? (c = m.codegenNode, a && l && Ee(c, l, o)) : h ? c = B(o, s(i), l ? U([l]) : void 0, t.children, `64 /* ${e.PatchFlagNames[64]} */`, void 0, void 0, !0) : (c = f[0].codegenNode, a && l && Ee(c, l, o), c.isBlock = !p, c.isBlock && (s(u), s(d))), r.arguments.push(q(ln(n.parseResult), c, !0)) } }) }); function tn(e, t, n, o) { if (!t.exp) return void n.onError(s(30, t.loc)); const r = rn(t.exp, n); if (!r) return void n.onError(s(31, t.loc)); const { addIdentifiers: i, removeIdentifiers: c, scopes: l } = n, { source: p, value: a, key: u, index: d } = r, f = { type: 11, loc: t.loc, source: p, valueAlias: a, keyAlias: u, objectIndexAlias: d, parseResult: r, children: ve(e) ? e.children : [e] }; n.replaceNode(f), l.vFor++; const h = o && o(f); return () => { l.vFor--, h && h() } } const nn = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, on = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, sn = /^\(|\)$/g; function rn(e, t) { const n = e.loc, o = e.content, s = o.match(nn); if (!s) return; const [, r, i] = s, c = { source: cn(n, i.trim(), o.indexOf(i, r.length)), value: void 0, key: void 0, index: void 0 }; let l = r.trim().replace(sn, "").trim(); const p = r.indexOf(l), a = l.match(on); if (a) { l = l.replace(on, "").trim(); const e = a[1].trim(); let t; if (e && (t = o.indexOf(e, p + l.length), c.key = cn(n, e, t)), a[2]) { const s = a[2].trim(); s && (c.index = cn(n, s, o.indexOf(s, c.key ? t + e.length : p + l.length))) } } return l && (c.value = cn(n, l, p)), c } function cn(e, t, n) { return j(t, !1, pe(e, n, t.length)) } function ln({ value: e, key: t, index: n }) { const o = []; return e && o.push(e), t && (e || o.push(j("_", !1)), o.push(t)), n && (t || (e || o.push(j("_", !1)), o.push(j("__", !1))), o.push(n)), o } const pn = j("undefined", !1), an = (e, t) => { if (1 === e.type && (1 === e.tagType || 3 === e.tagType)) { const n = fe(e, "slot"); if (n) { n.exp; return t.scopes.vSlot++, () => { t.scopes.vSlot-- } } } }; exports.trackSlotScopes = an; const un = (e, t) => { let n; if (ve(e) && e.props.some(ye) && (n = fe(e, "for"))) { const e = n.parseResult = rn(n.exp, t); if (e) { const { value: n, key: o, index: s } = e, { addIdentifiers: r, removeIdentifiers: i } = t; return n && r(n), o && r(o), s && r(s), () => { n && i(n), o && i(o), s && i(s) } } } }; exports.trackVForSlotScopes = un; const dn = (e, t, n) => q(e, t, !1, !0, t.length ? t[0].loc : n); function fn(e, t, n = dn) { t.helper(A); const { children: o, loc: r } = e, i = [], c = [], l = (e, t) => H("default", n(e, t, r)); let p = t.scopes.vSlot > 0 || t.scopes.vFor > 0; const a = fe(e, "slot", !0); if (a) { const { arg: e, exp: t } = a; e && !ne(e) && (p = !0), i.push(H(e || j("default", !0), n(t, o, r))) } let u = !1, d = !1; const f = [], h = new Set; for (let x = 0; x < o.length; x++) { const e = o[x]; let r; if (!ve(e) || !(r = fe(e, "slot", !0))) { 3 !== e.type && f.push(e); continue } if (a) { t.onError(s(36, r.loc)); break } u = !0; const { children: l, loc: m } = e, { arg: g = j("default", !0), exp: y, loc: v } = r; let S; ne(g) ? S = g ? g.content : "default" : p = !0; const b = n(y, l, m); let N, T, I; if (N = fe(e, "if")) p = !0, c.push(z(N.exp, hn(g, b), pn)); else if (T = fe(e, /^else(-if)?$/, !0)) { let e, n = x; for (; n-- && 3 === (e = o[n]).type;); if (e && ve(e) && fe(e, "if")) { o.splice(x, 1), x--; let e = c[c.length - 1]; for (; 19 === e.alternate.type;)e = e.alternate; e.alternate = T.exp ? z(T.exp, hn(g, b), pn) : hn(g, b) } else t.onError(s(29, T.loc)) } else if (I = fe(e, "for")) { p = !0; const e = I.parseResult || rn(I.exp, t); e ? c.push(G(t.helper(E), [e.source, q(ln(e), hn(g, b), !0)])) : t.onError(s(31, I.loc)) } else { if (S) { if (h.has(S)) { t.onError(s(37, v)); continue } h.add(S), "default" === S && (d = !0) } i.push(H(g, b)) } } a || (u ? f.length && (d ? t.onError(s(38, f[0].loc)) : i.push(l(void 0, f))) : i.push(l(void 0, o))); const m = p ? 2 : mn(e.children) ? 3 : 1; let g = U(i.concat(H("_", j("" + m, !1))), r); return c.length && (g = G(t.helper(N), [g, F(c)])), { slots: g, hasDynamicSlots: p } } function hn(e, t) { return U([H("name", e), H("fn", t)]) } function mn(e) { for (let t = 0; t < e.length; t++) { const n = e[t]; if (1 === n.type && (2 === n.tagType || 0 === n.tagType && mn(n.children))) return !0 } return !1 } const gn = new WeakMap, xn = (t, n) => { if (1 === t.type && (0 === t.tagType || 1 === t.tagType)) return function () { const { tag: o, props: s } = t, r = 1 === t.tagType, i = r ? yn(t, n) : `"${o}"`, a = (0, e.isObject)(i) && i.callee === y; let u, d, f, h, m, g, x = 0, v = a || i === c || i === l || !r && ("svg" === o || "foreignObject" === o || he(t, "key", !0)); if (s.length > 0) { const e = vn(t, n); u = e.props, x = e.patchFlag, m = e.dynamicPropNames; const o = e.directives; g = o && o.length ? F(o.map(e => bn(e, n))) : void 0 } if (t.children.length > 0) { if (i === p && (v = !0, x |= 1024), r && i !== c && i !== p) { const { slots: e, hasDynamicSlots: o } = fn(t, n); d = e, o && (x |= 1024) } else if (1 === t.children.length && i !== c) { const e = t.children[0], n = e.type, o = 5 === n || 8 === n; o && !nt(e) && (x |= 1), d = o || 2 === n ? e : t.children } else d = t.children } 0 !== x && (f = String(x), m && m.length && (h = Nn(m))), t.codegenNode = B(n, i, u, d, f, h, g, !!v, !1, t.loc) } }; function yn(e, t, n = !1) { const { tag: o } = e, s = "component" === e.tag ? he(e, "is") : fe(e, "is"); if (s) { const e = 6 === s.type ? s.value && j(s.value.content, !0) : s.exp; if (e) return G(t.helper(y), [e]) } const r = se(o) || t.isBuiltInComponent(o); return r ? (n || t.helper(r), r) : "setup" === t.bindingMetadata[o] ? `$setup[${JSON.stringify(o)}]` : (t.helper(x), t.components.add(o), be(o, "component")) } function vn(t, n, o = t.props, r = !1) { const { tag: i, loc: c } = t, l = 1 === t.tagType; let p = []; const a = [], u = []; let d = 0, f = !1, h = !1, m = !1, g = !1, x = !1, y = !1; const v = [], S = ({ key: t, value: n }) => { if (ne(t)) { const o = t.content, s = (0, e.isOn)(o); if (l || !s || "onclick" === o.toLowerCase() || "onUpdate:modelValue" === o || (0, e.isReservedProp)(o) || (g = !0), s && (0, e.isReservedProp)(o) && (y = !0), 20 === n.type || (4 === n.type || 8 === n.type) && nt(n) > 0) return; "ref" === o ? f = !0 : "class" !== o || l ? "style" !== o || l ? "key" === o || v.includes(o) || v.push(o) : m = !0 : h = !0 } else x = !0 }; for (let b = 0; b < o.length; b++) { const d = o[b]; if (6 === d.type) { const { loc: e, name: t, value: n } = d; if ("ref" === t && (f = !0), "is" === t && "component" === i) continue; p.push(H(j(t, !0, pe(e, 0, t.length)), j(n ? n.content : "", !0, n ? n.loc : e))) } else { const { name: o, arg: f, exp: h, loc: m } = d, g = "bind" === o, y = "on" === o; if ("slot" === o) { l || n.onError(s(39, m)); continue } if ("once" === o) continue; if ("is" === o || g && "component" === i && me(f, "is")) continue; if (y && r) continue; if (!f && (g || y)) { x = !0, h ? (p.length && (a.push(U(Sn(p), c)), p = []), g ? a.push(h) : a.push({ type: 14, loc: m, callee: n.helper(O), arguments: [h] })) : n.onError(s(g ? 33 : 34, m)); continue } const v = n.directiveTransforms[o]; if (v) { const { props: o, needRuntime: s } = v(d, t, n); !r && o.forEach(S), p.push(...o), s && (u.push(d), (0, e.isSymbol)(s) && gn.set(d, s)) } else u.push(d) } } let E = void 0; return a.length ? (p.length && a.push(U(Sn(p), c)), E = a.length > 1 ? G(n.helper(I), a, c) : a[0]) : p.length && (E = U(Sn(p), c)), x ? d |= 16 : (h && (d |= 2), m && (d |= 4), v.length && (d |= 8), g && (d |= 32)), 0 !== d && 32 !== d || !(f || y || u.length > 0) || (d |= 512), { props: E, directives: u, patchFlag: d, dynamicPropNames: v } } function Sn(e) { const t = new Map, n = []; for (let o = 0; o < e.length; o++) { const s = e[o]; if (8 === s.key.type || !s.key.isStatic) { n.push(s); continue } const r = s.key.content, i = t.get(r); i ? ("style" === r || "class" === r || r.startsWith("on")) && En(i, s) : (t.set(r, s), n.push(s)) } return n } function En(e, t) { 17 === e.value.type ? e.value.elements.push(t.value) : e.value = F([e.value, t.value], e.loc) } function bn(e, t) { const n = [], o = gn.get(e); o ? n.push(t.helperString(o)) : (t.helper(v), t.directives.add(e.name), n.push(be(e.name, "directive"))); const { loc: s } = e; if (e.exp && n.push(e.exp), e.arg && (e.exp || n.push("void 0"), n.push(e.arg)), Object.keys(e.modifiers).length) { e.arg || (e.exp || n.push("void 0"), n.push("void 0")); const t = j("true", !1, s); n.push(U(e.modifiers.map(e => H(e, t)), s)) } return F(n, e.loc) } function Nn(e) { let t = "["; for (let n = 0, o = e.length; n < o; n++)t += JSON.stringify(e[n]), n < o - 1 && (t += ", "); return t + "]" } exports.transformElement = xn; const Tn = (e, t) => { if (Se(e)) { const { children: n, loc: o } = e, { slotName: s, slotProps: r } = In(e, t), i = [t.prefixIdentifiers ? "_ctx.$slots" : "$slots", s]; r && i.push(r), n.length && (r || i.push("{}"), i.push(q([], n, !1, !1, o))), e.codegenNode = G(t.helper(b), i, o) } }; function In(e, t) { let n = '"default"', o = void 0; const r = he(e, "name"); r && (6 === r.type && r.value ? n = JSON.stringify(r.value.content) : 7 === r.type && r.exp && (n = r.exp)); const i = r ? e.props.filter(e => e !== r) : e.props; if (i.length > 0) { const { props: n, directives: r } = vn(e, t, i); o = n, r.length && t.onError(s(35, r[0].loc)) } return { slotName: n, slotProps: o } } const On = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/, Cn = (t, n, o, r) => { const { loc: i, modifiers: c, arg: l } = t; let p; if (t.exp || c.length || o.onError(s(34, i)), 4 === l.type) if (l.isStatic) { const t = l.content; p = j((0, e.toHandlerKey)((0, e.camelize)(t)), !0, l.loc) } else p = W([`${o.helperString(P)}(`, l, ")"]); else (p = l).children.unshift(`${o.helperString(P)}(`), p.children.push(")"); let a = t.exp; a && !a.content.trim() && (a = void 0); let u = o.cacheHandlers && !a; if (a) { const e = le(a.content), t = !(e || On.test(a.content)), n = a.content.includes(";"); 0, (t || u && e) && (a = W([`${t ? "$event" : "(...args)"} => ${n ? "{" : "("}`, a, n ? "}" : ")"])) } let d = { props: [H(p, a || j("() => {}", !1, i))] }; return r && (d = r(d)), u && (d.props[0].value = o.cache(d.props[0].value)), d }; exports.transformOn = Cn; const _n = (t, n, o) => { const { exp: r, modifiers: i, loc: c } = t, l = t.arg; return 4 !== l.type ? (l.children.unshift("("), l.children.push(') || ""')) : l.isStatic || (l.content = `${l.content} || ""`), i.includes("camel") && (4 === l.type ? l.isStatic ? l.content = (0, e.camelize)(l.content) : l.content = `${o.helperString(C)}(${l.content})` : (l.children.unshift(`${o.helperString(C)}(`), l.children.push(")"))), !r || 4 === r.type && !r.content.trim() ? (o.onError(s(33, c)), { props: [H(l, j("", !0, c))] }) : { props: [H(l, r)] } }; exports.transformBind = _n; const Pn = (t, n) => { if (0 === t.type || 1 === t.type || 11 === t.type || 10 === t.type) return () => { const o = t.children; let s = void 0, r = !1; for (let e = 0; e < o.length; e++) { const t = o[e]; if (xe(t)) { r = !0; for (let n = e + 1; n < o.length; n++) { const r = o[n]; if (!xe(r)) { s = void 0; break } s || (s = o[e] = { type: 8, loc: t.loc, children: [t] }), s.children.push(" + ", r), o.splice(n, 1), n-- } } } if (r && (1 !== o.length || 0 !== t.type && (1 !== t.type || 0 !== t.tagType))) for (let t = 0; t < o.length; t++) { const s = o[t]; if (xe(s) || 8 === s.type) { const r = []; 2 === s.type && " " === s.content || r.push(s), n.ssr || 2 === s.type || r.push(`1 /* ${e.PatchFlagNames[1]} */`), o[t] = { type: 12, content: s, loc: s.loc, codegenNode: G(n.helper(m), r) } } } } }, $n = new WeakSet, kn = (e, t) => { if (1 === e.type && fe(e, "once", !0)) { if ($n.has(e)) return; return $n.add(e), t.helper($), () => { const e = t.currentNode; e.codegenNode && (e.codegenNode = t.cache(e.codegenNode, !0)) } } }, wn = (e, t, n) => { const { exp: o, arg: r } = e; if (!o) return n.onError(s(40, e.loc)), Rn(); const i = 4 === o.type ? o.content : o.loc.source; if (!le(i)) return n.onError(s(41, o.loc)), Rn(); const c = r || j("modelValue", !0), l = r ? ne(r) ? `onUpdate:${r.content}` : W(['"onUpdate:" + ', r]) : "onUpdate:modelValue", p = [H(c, e.exp), H(l, W(["$event => (", o, " = $event)"]))]; if (e.modifiers.length && 1 === t.tagType) { const t = e.modifiers.map(e => (ie(e) ? e : JSON.stringify(e)) + ": true").join(", "), n = r ? ne(r) ? `${r.content}Modifiers` : W([r, ' + "Modifiers"']) : "modelModifiers"; p.push(H(n, j(`{ ${t} }`, !1, e.loc, !0))) } return Rn(p) }; function Rn(e = []) { return { props: e } } function An(e) { return [[kn, qt, en, Tn, xn, an, Pn], { on: Cn, bind: _n, model: wn }] } function Mn(t, n = {}) { const r = n.onError || o, i = "module" === n.mode; !0 === n.prefixIdentifiers ? r(s(45)) : i && r(s(46)); n.cacheHandlers && r(s(47)), n.scopeId && !i && r(s(48)); const c = (0, e.isString)(t) ? Ce(t, n) : t, [l, p] = An(); return ct(c, (0, e.extend)({}, n, { prefixIdentifiers: !1, nodeTransforms: [...l, ...n.nodeTransforms || []], directiveTransforms: (0, e.extend)({}, p, n.directiveTransforms || {}) })), ht(c, (0, e.extend)({}, n, { prefixIdentifiers: !1 })) } exports.transformModel = wn; const Ln = () => ({ props: [] }); exports.noopDirectiveTransform = Ln;
    }, { "@vue/shared": "tWCa", "@babel/parser": "J4YF", "estree-walker": "q7b5" }], "nO49": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); var e = { DOMDirectiveTransforms: !0, DOMNodeTransforms: !0, TRANSITION: !0, TRANSITION_GROUP: !0, V_MODEL_CHECKBOX: !0, V_MODEL_DYNAMIC: !0, V_MODEL_RADIO: !0, V_MODEL_SELECT: !0, V_MODEL_TEXT: !0, V_ON_WITH_KEYS: !0, V_ON_WITH_MODIFIERS: !0, V_SHOW: !0, compile: !0, createDOMCompilerError: !0, parse: !0, parserOptions: !0, transformStyle: !0 }; exports.compile = A, exports.createDOMCompilerError = h, exports.parse = P, exports.transformStyle = exports.parserOptions = exports.V_SHOW = exports.V_ON_WITH_MODIFIERS = exports.V_ON_WITH_KEYS = exports.V_MODEL_TEXT = exports.V_MODEL_SELECT = exports.V_MODEL_RADIO = exports.V_MODEL_DYNAMIC = exports.V_MODEL_CHECKBOX = exports.TRANSITION_GROUP = exports.TRANSITION = exports.DOMNodeTransforms = exports.DOMDirectiveTransforms = void 0; var t = require("@vue/compiler-core"); Object.keys(t).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || r in exports && exports[r] === t[r] || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return t[r] } })) }); var r = require("@vue/shared"); const o = Symbol(""); exports.V_MODEL_RADIO = o; const n = Symbol(""); exports.V_MODEL_CHECKBOX = n; const s = Symbol(""); exports.V_MODEL_TEXT = s; const i = Symbol(""); exports.V_MODEL_SELECT = i; const p = Symbol(""); exports.V_MODEL_DYNAMIC = p; const l = Symbol(""); exports.V_ON_WITH_MODIFIERS = l; const a = Symbol(""); exports.V_ON_WITH_KEYS = a; const c = Symbol(""); exports.V_SHOW = c; const m = Symbol(""); exports.TRANSITION = m; const d = Symbol(""); let u; function x(e) { return (u || (u = document.createElement("div"))).innerHTML = e, u.textContent } exports.TRANSITION_GROUP = d, (0, t.registerRuntimeHelpers)({ [o]: "vModelRadio", [n]: "vModelCheckbox", [s]: "vModelText", [i]: "vModelSelect", [p]: "vModelDynamic", [l]: "withModifiers", [a]: "withKeys", [c]: "vShow", [m]: "Transition", [d]: "TransitionGroup" }); const f = (0, r.makeMap)("style,iframe,script,noscript", !0), O = { isVoidTag: r.isVoidTag, isNativeTag: e => (0, r.isHTMLTag)(e) || (0, r.isSVGTag)(e), isPreTag: e => "pre" === e, decodeEntities: x, isBuiltInComponent: e => (0, t.isBuiltInType)(e, "Transition") ? m : (0, t.isBuiltInType)(e, "TransitionGroup") ? d : void 0, getNamespace(e, t) { let r = t ? t.ns : 0; if (t && 2 === r) if ("annotation-xml" === t.tag) { if ("svg" === e) return 1; t.props.some(e => 6 === e.type && "encoding" === e.name && null != e.value && ("text/html" === e.value.content || "application/xhtml+xml" === e.value.content)) && (r = 0) } else /^m(?:[ions]|text)$/.test(t.tag) && "mglyph" !== e && "malignmark" !== e && (r = 0); else t && 1 === r && ("foreignObject" !== t.tag && "desc" !== t.tag && "title" !== t.tag || (r = 0)); if (0 === r) { if ("svg" === e) return 1; if ("math" === e) return 2 } return r }, getTextMode({ tag: e, ns: t }) { if (0 === t) { if ("textarea" === e || "title" === e) return 1; if (f(e)) return 2 } return 0 } }; exports.parserOptions = O; const y = e => { 1 === e.type && e.props.forEach((r, o) => { 6 === r.type && "style" === r.name && r.value && (e.props[o] = { type: 7, name: "bind", arg: (0, t.createSimpleExpression)("style", !0, r.loc), exp: E(r.value.content, r.loc), modifiers: [], loc: r.loc }) }) }; exports.transformStyle = y; const E = (e, o) => { const n = (0, r.parseStringStyle)(e); return (0, t.createSimpleExpression)(JSON.stringify(n), !1, o, !0) }; function h(e, r) { return (0, t.createCompilerError)(e, r, void 0) } const T = { 49: "v-html is missing expression.", 50: "v-html will override element children.", 51: "v-text is missing expression.", 52: "v-text will override element children.", 53: "v-model can only be used on <input>, <textarea> and <select> elements.", 54: "v-model argument is not supported on plain elements.", 55: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.", 56: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.", 57: "v-show is missing expression.", 58: "<Transition> expects exactly one child element or component.", 59: "Tags with side effect (<script> and <style>) are ignored in client component templates." }, g = (e, r, o) => { const { exp: n, loc: s } = e; return n || o.onError(h(49, s)), r.children.length && (o.onError(h(50, s)), r.children.length = 0), { props: [(0, t.createObjectProperty)((0, t.createSimpleExpression)("innerHTML", !0, s), n || (0, t.createSimpleExpression)("", !0))] } }, _ = (e, r, o) => { const { exp: n, loc: s } = e; return n || o.onError(h(51, s)), r.children.length && (o.onError(h(52, s)), r.children.length = 0), { props: [(0, t.createObjectProperty)((0, t.createSimpleExpression)("textContent", !0), n ? (0, t.createCallExpression)(o.helperString(t.TO_DISPLAY_STRING), [n], s) : (0, t.createSimpleExpression)("", !0))] } }, M = (e, r, l) => { const a = (0, t.transformModel)(e, r, l); if (!a.props.length || 1 === r.tagType) return a; e.arg && l.onError(h(54, e.arg.loc)); const { tag: c } = r, m = l.isCustomElement(c); if ("input" === c || "textarea" === c || "select" === c || m) { let d = s, u = !1; if ("input" === c || m) { const s = (0, t.findProp)(r, "type"); if (s) { if (7 === s.type) d = p; else if (s.value) switch (s.value.content) { case "radio": d = o; break; case "checkbox": d = n; break; case "file": u = !0, l.onError(h(55, e.loc)) } } else (0, t.hasDynamicKeyVBind)(r) && (d = p) } else "select" === c && (d = i); u || (a.needRuntime = l.helper(d)) } else l.onError(h(53, e.loc)); return a.props = a.props.filter(e => !(4 === e.key.type && "modelValue" === e.key.content)), a }, S = (0, r.makeMap)("passive,once,capture"), v = (0, r.makeMap)("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"), D = (0, r.makeMap)("left,right"), I = (0, r.makeMap)("onkeyup,onkeydown,onkeypress", !0), b = (e, r) => { const o = [], n = [], s = []; for (let i = 0; i < r.length; i++) { const p = r[i]; S(p) ? s.push(p) : D(p) ? (0, t.isStaticExp)(e) ? I(e.content) ? o.push(p) : n.push(p) : (o.push(p), n.push(p)) : v(p) ? n.push(p) : o.push(p) } return { keyModifiers: o, nonKeyModifiers: n, eventOptionModifiers: s } }, N = (e, r) => { return (0, t.isStaticExp)(e) && "onclick" === e.content.toLowerCase() ? (0, t.createSimpleExpression)(r, !0) : 4 !== e.type ? (0, t.createCompoundExpression)(["(", e, `) === "onClick" ? "${r}" : (`, e, ")"]) : e }, C = (e, o, n) => (0, t.transformOn)(e, o, n, o => { const { modifiers: s } = e; if (!s.length) return o; let { key: i, value: p } = o.props[0]; const { keyModifiers: c, nonKeyModifiers: m, eventOptionModifiers: d } = b(i, s); if (m.includes("right") && (i = N(i, "onContextmenu")), m.includes("middle") && (i = N(i, "onMouseup")), m.length && (p = (0, t.createCallExpression)(n.helper(l), [p, JSON.stringify(m)])), !c.length || (0, t.isStaticExp)(i) && !I(i.content) || (p = (0, t.createCallExpression)(n.helper(a), [p, JSON.stringify(c)])), d.length) { const e = d.map(r.capitalize).join(""); i = (0, t.isStaticExp)(i) ? (0, t.createSimpleExpression)(`${i.content}${e}`, !0) : (0, t.createCompoundExpression)(["(", i, `) + "${e}"`]) } return { props: [(0, t.createObjectProperty)(i, p)] } }), V = (e, t, r) => { const { exp: o, loc: n } = e; return o || r.onError(h(57, n)), { props: [], needRuntime: r.helper(c) } }, L = (e, t) => { if (1 === e.type && 1 === e.tagType) { if (t.isBuiltInComponent(e.tag) === m) return () => { e.children.length && k(e) && t.onError(h(58, { start: e.children[0].loc.start, end: e.children[e.children.length - 1].loc.end, source: "" })) } } }; function k(e) { const t = e.children = e.children.filter(e => 3 !== e.type), r = t[0]; return 1 !== t.length || 11 === r.type || 9 === r.type && r.branches.some(k) } const R = (e, t) => { 1 !== e.type || 0 !== e.tagType || "script" !== e.tag && "style" !== e.tag || (t.onError(h(59, e.loc)), t.removeNode()) }, H = [y]; exports.DOMNodeTransforms = H; const w = { cloak: t.noopDirectiveTransform, html: g, text: _, model: M, on: C, show: V }; function A(e, o = {}) { return (0, t.baseCompile)(e, (0, r.extend)({}, O, o, { nodeTransforms: [R, ...H, ...o.nodeTransforms || []], directiveTransforms: (0, r.extend)({}, w, o.directiveTransforms || {}), transformHoist: null })) } function P(e, o = {}) { return (0, t.baseParse)(e, (0, r.extend)({}, O, o)) } exports.DOMDirectiveTransforms = w;
    }, { "@vue/compiler-core": "saIb", "@vue/shared": "tWCa" }], "x0sI": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }); var e = { compile: !0 }; exports.compile = p; var t = i(require("@vue/runtime-dom")); Object.keys(t).forEach(function (r) { "default" !== r && "__esModule" !== r && (Object.prototype.hasOwnProperty.call(e, r) || r in exports && exports[r] === t[r] || Object.defineProperty(exports, r, { enumerable: !0, get: function () { return t[r] } })) }); var r = require("@vue/shared"), o = require("@vue/compiler-dom"); function n() { if ("function" != typeof WeakMap) return null; var e = new WeakMap; return n = function () { return e }, e } function i(e) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = n(); if (t && t.has(e)) return t.get(e); var r = {}, o = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var i in e) if (Object.prototype.hasOwnProperty.call(e, i)) { var u = o ? Object.getOwnPropertyDescriptor(e, i) : null; u && (u.get || u.set) ? Object.defineProperty(r, i, u) : r[i] = e[i] } return r.default = e, t && t.set(e, r), r } function u() { const e = (0, r.getGlobalThis)(); e.__VUE__ = !0, (0, t.setDevtoolsHook)(e.__VUE_DEVTOOLS_GLOBAL_HOOK__), console.info("You are running a development build of Vue.\nMake sure to use the production build (*.prod.js) when deploying for production."), (0, t.initCustomFormatter)() } const c = Object.create(null); function p(e, n) { if (!(0, r.isString)(e)) { if (!e.nodeType) return r.NOOP; e = e.innerHTML } const i = e, u = c[i]; if (u) return u; if ("#" === e[0]) { const t = document.querySelector(e); 0, e = t ? t.innerHTML : "" } const { code: p } = (0, o.compile)(e, (0, r.extend)({ hoistStatic: !0, onError(e) { throw e } }, n)), s = new Function("Vue", p)(t); return s._rc = !0, c[i] = s } (0, t.registerRuntimeCompiler)(p);
    }, { "@vue/runtime-dom": "KZzx", "@vue/shared": "tWCa", "@vue/compiler-dom": "nO49" }], "QNx4": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var a = [{ iso3: "abw", name: "Aruba", lat: 12.5, lon: -69.96666666 }, { iso3: "afg", name: "Afeganisto", lat: 33, lon: 65 }, { iso3: "ago", name: "Angola", lat: -12.5, lon: 18.5 }, { iso3: "aia", name: "Anguilla", lat: 18.25, lon: -63.16666666 }, { iso3: "ala", name: "Alndia", lat: 60.116667, lon: 19.9 }, { iso3: "alb", name: "Albnia", lat: 41, lon: 20 }, { iso3: "are", name: "Emirados rabes Unidos", lat: 24, lon: 54 }, { iso3: "arg", name: "Argentina", lat: -34, lon: -64 }, { iso3: "arm", name: "Armnia", lat: 40, lon: 45 }, { iso3: "and", name: "Andorra", lat: 42.5, lon: 1.5 }, { iso3: "asm", name: "Samoa Americana", lat: -14.33333333, lon: -170 }, { iso3: "atf", name: "Terras Austrais e Antrticas Francesas", lat: -49.25, lon: 69.167 }, { iso3: "atg", name: "Antgua e Barbuda", lat: 17.05, lon: -61.8 }, { iso3: "aus", name: "Austrlia", lat: -27, lon: 133 }, { iso3: "aut", name: "ustria", lat: 47.33333333, lon: 13.33333333 }, { iso3: "aze", name: "Azerbeijo", lat: 40.5, lon: 47.5 }, { iso3: "bdi", name: "Burundi", lat: -3.5, lon: 30 }, { iso3: "bel", name: "Blgica", lat: 50.83333333, lon: 4 }, { iso3: "ben", name: "Benin", lat: 9.5, lon: 2.25 }, { iso3: "bfa", name: "Burkina Faso", lat: 13, lon: -2 }, { iso3: "bgd", name: "Bangladesh", lat: 24, lon: 90 }, { iso3: "bgr", name: "Bulgria", lat: 43, lon: 25 }, { iso3: "ata", name: "Antrtida", lat: -90, lon: 0 }, { iso3: "bhs", name: "Bahamas", lat: 24.25, lon: -76 }, { iso3: "bih", name: "Bsnia e Herzegovina", lat: 44, lon: 18 }, { iso3: "blm", name: "So Bartolomeu", lat: 18.5, lon: -63.41666666 }, { iso3: "bhr", name: "Bahrein", lat: 26, lon: 50.55 }, { iso3: "blz", name: "Belize", lat: 17.25, lon: -88.75 }, { iso3: "bmu", name: "Bermudas", lat: 32.33333333, lon: -64.75 }, { iso3: "bol", name: "Bolvia", lat: -17, lon: -65 }, { iso3: "blr", name: "Bielorssia", lat: 53, lon: 28 }, { iso3: "brb", name: "Barbados", lat: 13.16666666, lon: -59.53333333 }, { iso3: "bra", name: "Brasil", lat: -10, lon: -55 }, { iso3: "btn", name: "Buto", lat: 27.5, lon: 90.5 }, { iso3: "bvt", name: "Ilha Bouvet", lat: -54.43333333, lon: 3.4 }, { iso3: "caf", name: "Repblica Centro-Africana", lat: 7, lon: 21 }, { iso3: "can", name: "Canad", lat: 60, lon: -95 }, { iso3: "bwa", name: "Botswana", lat: -22, lon: 24 }, { iso3: "chn", name: "China", lat: 35, lon: 105 }, { iso3: "civ", name: "Costa do Marfim", lat: 8, lon: -5 }, { iso3: "cmr", name: "Camares", lat: 6, lon: 12 }, { iso3: "cod", name: "Repblica Democrtica do Congo", lat: 0, lon: 25 }, { iso3: "cog", name: "Congo", lat: -1, lon: 15 }, { iso3: "cok", name: "Ilhas Cook", lat: -21.23333333, lon: -159.76666666 }, { iso3: "col", name: "Colmbia", lat: 4, lon: -72 }, { iso3: "com", name: "Comores", lat: -12.16666666, lon: 44.25 }, { iso3: "cpv", name: "Cabo Verde", lat: 16, lon: -24 }, { iso3: "brn", name: "Brunei", lat: 4.5, lon: 114.66666666 }, { iso3: "cub", name: "Cuba", lat: 21.5, lon: -80 }, { iso3: "cuw", name: "ilha da Curao", lat: 12.116667, lon: -68.933333 }, { iso3: "cxr", name: "Ilha do Natal", lat: -10.5, lon: 105.66666666 }, { iso3: "cym", name: "Ilhas Caimo", lat: 19.5, lon: -80.5 }, { iso3: "cyp", name: "Chipre", lat: 35, lon: 33 }, { iso3: "cze", name: "Chquia", lat: 49.75, lon: 15.5 }, { iso3: "che", name: "Sua", lat: 47, lon: 8 }, { iso3: "deu", name: "Alemanha", lat: 51, lon: 9 }, { iso3: "dma", name: "Dominica", lat: 15.41666666, lon: -61.33333333 }, { iso3: "chl", name: "Chile", lat: -30, lon: -71 }, { iso3: "cri", name: "Costa Rica", lat: 10, lon: -84 }, { iso3: "cck", name: "Ilhas Cocos (Keeling)", lat: -12.5, lon: 96.83333333 }, { iso3: "dom", name: "Repblica Dominicana", lat: 19, lon: -70.66666666 }, { iso3: "dji", name: "Djibouti", lat: 11.5, lon: 43 }, { iso3: "dza", name: "Arglia", lat: 28, lon: 3 }, { iso3: "dnk", name: "Dinamarca", lat: 56, lon: 10 }, { iso3: "ecu", name: "Equador", lat: -2, lon: -77.5 }, { iso3: "esh", name: "Saara Ocidental", lat: 24.5, lon: -13 }, { iso3: "eri", name: "Eritreia", lat: 15, lon: 39 }, { iso3: "est", name: "Estnia", lat: 59, lon: 26 }, { iso3: "egy", name: "Egito", lat: 27, lon: 30 }, { iso3: "fji", name: "Fiji", lat: -18, lon: 175 }, { iso3: "flk", name: "Ilhas Malvinas", lat: -51.75, lon: -59 }, { iso3: "eth", name: "Etipia", lat: 8, lon: 38 }, { iso3: "fra", name: "Frana", lat: 46, lon: 2 }, { iso3: "fro", name: "Ilhas Faro", lat: 62, lon: -7 }, { iso3: "gab", name: "Gabo", lat: -1, lon: 11.75 }, { iso3: "fin", name: "Finlndia", lat: 64, lon: 26 }, { iso3: "fsm", name: "Micronsia", lat: 6.91666666, lon: 158.25 }, { iso3: "ggy", name: "Guernsey", lat: 49.46666666, lon: -2.58333333 }, { iso3: "gha", name: "Gana", lat: 8, lon: -2 }, { iso3: "gin", name: "Guin", lat: 11, lon: -10 }, { iso3: "geo", name: "Gergia", lat: 42, lon: 43.5 }, { iso3: "glp", name: "Guadalupe", lat: 16.25, lon: -61.583333 }, { iso3: "gmb", name: "Gmbia", lat: 13.46666666, lon: -16.56666666 }, { iso3: "gbr", name: "Reino Unido", lat: 54, lon: -2 }, { iso3: "gnb", name: "Guin-Bissau", lat: 12, lon: -15 }, { iso3: "grd", name: "Granada", lat: 12.11666666, lon: -61.66666666 }, { iso3: "gib", name: "Gibraltar", lat: 36.13333333, lon: -5.35 }, { iso3: "gnq", name: "Guin Equatorial", lat: 2, lon: 10 }, { iso3: "grl", name: "Gronelndia", lat: 72, lon: -40 }, { iso3: "gtm", name: "Guatemala", lat: 15.5, lon: -90.25 }, { iso3: "gum", name: "Guam", lat: 13.46666666, lon: 144.78333333 }, { iso3: "guy", name: "Guiana", lat: 5, lon: -59 }, { iso3: "hmd", name: "Ilha Heard e Ilhas McDonald", lat: -53.1, lon: 72.51666666 }, { iso3: "hkg", name: "Hong Kong", lat: 22.267, lon: 114.188 }, { iso3: "hnd", name: "Honduras", lat: 15, lon: -86.5 }, { iso3: "hrv", name: "Crocia", lat: 45.16666666, lon: 15.5 }, { iso3: "hun", name: "Hungria", lat: 47, lon: 20 }, { iso3: "idn", name: "Indonsia", lat: -5, lon: 120 }, { iso3: "imn", name: "Ilha de Man", lat: 54.25, lon: -4.5 }, { iso3: "ind", name: "ndia", lat: 20, lon: 77 }, { iso3: "iot", name: "Territrio Britnico do Oceano ndico", lat: -6, lon: 71.5 }, { iso3: "irl", name: "Irlanda", lat: 53, lon: -8 }, { iso3: "irn", name: "Iro", lat: 32, lon: 53 }, { iso3: "esp", name: "Espanha", lat: 40, lon: -4 }, { iso3: "isl", name: "Islndia", lat: 65, lon: -18 }, { iso3: "isr", name: "Israel", lat: 31.47, lon: 35.13 }, { iso3: "ita", name: "Itlia", lat: 42.83333333, lon: 12.83333333 }, { iso3: "irq", name: "Iraque", lat: 33, lon: 44 }, { iso3: "jey", name: "Jersey", lat: 49.25, lon: -2.16666666 }, { iso3: "jor", name: "Jordnia", lat: 31, lon: 36 }, { iso3: "jam", name: "Jamaica", lat: 18.25, lon: -77.5 }, { iso3: "kaz", name: "Cazaquisto", lat: 48, lon: 68 }, { iso3: "ken", name: "Qunia", lat: 1, lon: 38 }, { iso3: "jpn", name: "Japo", lat: 36, lon: 138 }, { iso3: "kgz", name: "Quirguisto", lat: 41, lon: 75 }, { iso3: "kir", name: "Kiribati", lat: 1.41666666, lon: 173 }, { iso3: "kna", name: "So Cristvo e Nevis", lat: 17.33333333, lon: -62.75 }, { iso3: "kor", name: "Coreia do Sul", lat: 37, lon: 127.5 }, { iso3: "unk", name: "Kosovo", lat: 42.666667, lon: 21.166667 }, { iso3: "kwt", name: "Kuwait", lat: 29.5, lon: 45.75 }, { iso3: "lao", name: "Laos", lat: 18, lon: 105 }, { iso3: "lbn", name: "Lbano", lat: 33.83333333, lon: 35.83333333 }, { iso3: "lbr", name: "Libria", lat: 6.5, lon: -9.5 }, { iso3: "lby", name: "Lbia", lat: 25, lon: 17 }, { iso3: "khm", name: "Camboja", lat: 13, lon: 105 }, { iso3: "lca", name: "Santa Lcia", lat: 13.88333333, lon: -60.96666666 }, { iso3: "lka", name: "Sri Lanka", lat: 7, lon: 81 }, { iso3: "lie", name: "Liechtenstein", lat: 47.26666666, lon: 9.53333333 }, { iso3: "lso", name: "Lesoto", lat: -29.5, lon: 28.5 }, { iso3: "lux", name: "Luxemburgo", lat: 49.75, lon: 6.16666666 }, { iso3: "lva", name: "Letnia", lat: 57, lon: 25 }, { iso3: "mac", name: "Macau", lat: 22.16666666, lon: 113.55 }, { iso3: "maf", name: "So Martinho", lat: 18.08333333, lon: -63.95 }, { iso3: "mar", name: "Marrocos", lat: 32, lon: -5 }, { iso3: "ltu", name: "Litunia", lat: 56, lon: 24 }, { iso3: "mco", name: "Mnaco", lat: 43.73333333, lon: 7.4 }, { iso3: "mdg", name: "Madagscar", lat: -20, lon: 47 }, { iso3: "mdv", name: "Maldivas", lat: 3.25, lon: 73 }, { iso3: "mex", name: "Mxico", lat: 23, lon: -102 }, { iso3: "mhl", name: "Ilhas Marshall", lat: 9, lon: 168 }, { iso3: "mkd", name: "Macednia", lat: 41.83333333, lon: 22 }, { iso3: "mli", name: "Mali", lat: 17, lon: -4 }, { iso3: "mlt", name: "Malta", lat: 35.83333333, lon: 14.58333333 }, { iso3: "mmr", name: "Myanmar", lat: 22, lon: 98 }, { iso3: "mne", name: "Montenegro", lat: 42.5, lon: 19.3 }, { iso3: "mng", name: "Monglia", lat: 46, lon: 105 }, { iso3: "mnp", name: "Marianas Setentrionais", lat: 15.2, lon: 145.75 }, { iso3: "moz", name: "Moambique", lat: -18.25, lon: 35 }, { iso3: "mrt", name: "Mauritnia", lat: 20, lon: -12 }, { iso3: "msr", name: "Montserrat", lat: 16.75, lon: -62.2 }, { iso3: "mtq", name: "Martinica", lat: 14.666667, lon: -61 }, { iso3: "mus", name: "Maurcio", lat: -20.28333333, lon: 57.55 }, { iso3: "mwi", name: "Malawi", lat: -13.5, lon: 34 }, { iso3: "mys", name: "Malsia", lat: 2.5, lon: 112.5 }, { iso3: "myt", name: "Mayotte", lat: -12.83333333, lon: 45.16666666 }, { iso3: "nam", name: "Nambia", lat: -22, lon: 17 }, { iso3: "ncl", name: "Nova Calednia", lat: -21.5, lon: 165.5 }, { iso3: "ner", name: "Nger", lat: 16, lon: 8 }, { iso3: "nfk", name: "Ilha Norfolk", lat: -29.03333333, lon: 167.95 }, { iso3: "nga", name: "Nigria", lat: 10, lon: 8 }, { iso3: "nic", name: "Nicargua", lat: 13, lon: -85 }, { iso3: "niu", name: "Niue", lat: -19.03333333, lon: -169.86666666 }, { iso3: "nld", name: "Holanda", lat: 52.5, lon: 5.75 }, { iso3: "nor", name: "Noruega", lat: 62, lon: 10 }, { iso3: "mda", name: "Moldvia", lat: 47, lon: 29 }, { iso3: "nru", name: "Nauru", lat: -.53333333, lon: 166.91666666 }, { iso3: "nzl", name: "Nova Zelndia", lat: -41, lon: 174 }, { iso3: "omn", name: "Om", lat: 21, lon: 57 }, { iso3: "pak", name: "Paquisto", lat: 30, lon: 70 }, { iso3: "pan", name: "Panam", lat: 9, lon: -80 }, { iso3: "pcn", name: "Ilhas Pitcairn", lat: -25.06666666, lon: -130.1 }, { iso3: "per", name: "Per", lat: -10, lon: -76 }, { iso3: "phl", name: "Filipinas", lat: 13, lon: 122 }, { iso3: "hti", name: "Haiti", lat: 19, lon: -72.41666666 }, { iso3: "png", name: "Papua Nova Guin", lat: -6, lon: 147 }, { iso3: "pol", name: "Polnia", lat: 52, lon: 20 }, { iso3: "pri", name: "Porto Rico", lat: 18.25, lon: -66.5 }, { iso3: "prk", name: "Coreia do Norte", lat: 40, lon: 127 }, { iso3: "prt", name: "Portugal", lat: 39.5, lon: -8 }, { iso3: "pry", name: "Paraguai", lat: -23, lon: -58 }, { iso3: "pse", name: "Palestina", lat: 31.9, lon: 35.2 }, { iso3: "pyf", name: "Polinsia Francesa", lat: -15, lon: -140 }, { iso3: "plw", name: "Palau", lat: 7.5, lon: 134.5 }, { iso3: "grc", name: "Grcia", lat: 39, lon: 22 }, { iso3: "guf", name: "Guiana Francesa", lat: 4, lon: -53 }, { iso3: "qat", name: "Catar", lat: 25.5, lon: 51.25 }, { iso3: "reu", name: "Reunio", lat: -21.15, lon: 55.5 }, { iso3: "rwa", name: "Ruanda", lat: -2, lon: 30 }, { iso3: "sdn", name: "Sudo", lat: 15, lon: 30 }, { iso3: "rou", name: "Romnia", lat: 46, lon: 25 }, { iso3: "sau", name: "Arbia Saudita", lat: 25, lon: 45 }, { iso3: "rus", name: "Rssia", lat: 60, lon: 100 }, { iso3: "sjm", name: "Ilhas Svalbard e Jan Mayen", lat: 78, lon: 20 }, { iso3: "sgs", name: "Ilhas Gergia do Sul e Sandwich do Sul", lat: -54.5, lon: -37 }, { iso3: "sgp", name: "Singapura", lat: 1.36666666, lon: 103.8 }, { iso3: "sen", name: "Senegal", lat: 14, lon: -14 }, { iso3: "slb", name: "Ilhas Salomo", lat: -8, lon: 159 }, { iso3: "sle", name: "Serra Leoa", lat: 8.5, lon: -11.5 }, { iso3: "smr", name: "San Marino", lat: 43.76666666, lon: 12.41666666 }, { iso3: "spm", name: "Saint-Pierre e Miquelat", lat: 46.83333333, lon: -56.33333333 }, { iso3: "slv", name: "El Salvador", lat: 13.83333333, lon: -88.91666666 }, { iso3: "srb", name: "Srvia", lat: 44, lon: 21 }, { iso3: "sur", name: "Suriname", lat: 4, lon: -56 }, { iso3: "ssd", name: "Sudo do Sul", lat: 7, lon: 30 }, { iso3: "svk", name: "Eslovquia", lat: 48.66666666, lon: 19.5 }, { iso3: "svn", name: "Eslovnia", lat: 46.11666666, lon: 14.81666666 }, { iso3: "swe", name: "Sucia", lat: 62, lon: 15 }, { iso3: "swz", name: "Suazilndia", lat: -26.5, lon: 31.5 }, { iso3: "som", name: "Somlia", lat: 10, lon: 49 }, { iso3: "stp", name: "So Tom e Prncipe", lat: 1, lon: 7 }, { iso3: "syr", name: "Sria", lat: 35, lon: 38 }, { iso3: "sxm", name: "So Martinho", lat: 18.033333, lon: -63.05 }, { iso3: "syc", name: "Seicheles", lat: -4.58333333, lon: 55.66666666 }, { iso3: "tcd", name: "Chade", lat: 15, lon: 19 }, { iso3: "tca", name: "Ilhas Turks e Caicos", lat: 21.75, lon: -71.58333333 }, { iso3: "tgo", name: "Togo", lat: 8, lon: 1.16666666 }, { iso3: "tha", name: "Tailndia", lat: 15, lon: 100 }, { iso3: "tjk", name: "Tajiquisto", lat: 39, lon: 71 }, { iso3: "tkl", name: "Tokelau", lat: -9, lon: -172 }, { iso3: "tkm", name: "Turquemenisto", lat: 40, lon: 60 }, { iso3: "tls", name: "Timor-Leste", lat: -8.83333333, lon: 125.91666666 }, { iso3: "ton", name: "Tonga", lat: -20, lon: -175 }, { iso3: "tuv", name: "Tuvalu", lat: -8, lon: 178 }, { iso3: "tur", name: "Turquia", lat: 39, lon: 35 }, { iso3: "twn", name: "Ilha Formosa", lat: 23.5, lon: 121 }, { iso3: "tza", name: "Tanznia", lat: -6, lon: 35 }, { iso3: "tto", name: "Trinidade e Tobago", lat: 11, lon: -61 }, { iso3: "tun", name: "Tunsia", lat: 34, lon: 9 }, { iso3: "umi", name: "Ilhas Menores Distantes dos Estados Unidos", lat: void 0, lon: void 0 }, { iso3: "ury", name: "Uruguai", lat: -33, lon: -56 }, { iso3: "usa", name: "Estados Unidos", lat: 38, lon: -97 }, { iso3: "uzb", name: "Uzbequisto", lat: 41, lon: 64 }, { iso3: "ukr", name: "Ucrnia", lat: 49, lon: 32 }, { iso3: "vct", name: "So Vincente e Granadinas", lat: 13.25, lon: -61.2 }, { iso3: "ven", name: "Venezuela", lat: 8, lon: -66 }, { iso3: "vgb", name: "Ilhas Virgens", lat: 18.431383, lon: -64.62305 }, { iso3: "vir", name: "Ilhas Virgens dos Estados Unidos", lat: 18.35, lon: -64.933333 }, { iso3: "uga", name: "Uganda", lat: 1, lon: 32 }, { iso3: "vat", name: "Cidade do Vaticano", lat: 41.9, lon: 12.45 }, { iso3: "wlf", name: "Wallis e Futuna", lat: -13.3, lon: -176.2 }, { iso3: "wsm", name: "Samoa", lat: -13.58333333, lon: -172.33333333 }, { iso3: "yem", name: "Imen", lat: 15, lon: 48 }, { iso3: "vut", name: "Vanuatu", lat: -16, lon: 167 }, { iso3: "zmb", name: "Zmbia", lat: -15, lon: 30 }, { iso3: "zwe", name: "Zimbabwe", lat: -20, lon: 30 }, { iso3: "npl", name: "Nepal", lat: 28, lon: 84 }, { iso3: "vnm", name: "Vietname", lat: 16.16666666, lon: 107.83333333 }, { iso3: "zaf", name: "frica do Sul", lat: -29, lon: 24 }], n = a; exports.default = n;
    }, {}], "Wr69": [function (require, module, exports) {
        function t(t) { if (t) return e(t) } function e(e) { for (var s in t.prototype) e[s] = t.prototype[s]; return e } "undefined" != typeof module && (module.exports = t), t.prototype.on = t.prototype.addEventListener = function (t, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this }, t.prototype.once = function (t, e) { function s() { this.off(t, s), e.apply(this, arguments) } return s.fn = e, this.on(t, s), this }, t.prototype.off = t.prototype.removeListener = t.prototype.removeAllListeners = t.prototype.removeEventListener = function (t, e) { if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this; var s, r = this._callbacks["$" + t]; if (!r) return this; if (1 == arguments.length) return delete this._callbacks["$" + t], this; for (var i = 0; i < r.length; i++)if ((s = r[i]) === e || s.fn === e) { r.splice(i, 1); break } return 0 === r.length && delete this._callbacks["$" + t], this }, t.prototype.emit = function (t) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), s = this._callbacks["$" + t], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (s) { r = 0; for (var i = (s = s.slice(0)).length; r < i; ++r)s[r].apply(this, e) } return this }, t.prototype.listeners = function (t) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [] }, t.prototype.hasListeners = function (t) { return !!this.listeners(t).length };
    }, {}], "SQZr": [function (require, module, exports) {
        module.exports = t, t.default = t, t.stable = o, t.stableStringify = o; var r = [], e = []; function t(t, i, o) { var f; for (n(t, "", [], void 0), f = 0 === e.length ? JSON.stringify(t, i, o) : JSON.stringify(t, u(i), o); 0 !== r.length;) { var l = r.pop(); 4 === l.length ? Object.defineProperty(l[0], l[1], l[3]) : l[0][l[1]] = l[2] } return f } function n(t, i, o, f) { var u; if ("object" == typeof t && null !== t) { for (u = 0; u < o.length; u++)if (o[u] === t) { var l = Object.getOwnPropertyDescriptor(f, i); return void (void 0 !== l.get ? l.configurable ? (Object.defineProperty(f, i, { value: "[Circular]" }), r.push([f, i, t, l])) : e.push([t, i]) : (f[i] = "[Circular]", r.push([f, i, t]))) } if (o.push(t), Array.isArray(t)) for (u = 0; u < t.length; u++)n(t[u], u, o, t); else { var a = Object.keys(t); for (u = 0; u < a.length; u++) { var c = a[u]; n(t[c], c, o, t) } } o.pop() } } function i(r, e) { return r < e ? -1 : r > e ? 1 : 0 } function o(t, n, i) { var o, l = f(t, "", [], void 0) || t; for (o = 0 === e.length ? JSON.stringify(l, n, i) : JSON.stringify(l, u(n), i); 0 !== r.length;) { var a = r.pop(); 4 === a.length ? Object.defineProperty(a[0], a[1], a[3]) : a[0][a[1]] = a[2] } return o } function f(t, n, o, u) { var l; if ("object" == typeof t && null !== t) { for (l = 0; l < o.length; l++)if (o[l] === t) { var a = Object.getOwnPropertyDescriptor(u, n); return void (void 0 !== a.get ? a.configurable ? (Object.defineProperty(u, n, { value: "[Circular]" }), r.push([u, n, t, a])) : e.push([t, n]) : (u[n] = "[Circular]", r.push([u, n, t]))) } if ("function" == typeof t.toJSON) return; if (o.push(t), Array.isArray(t)) for (l = 0; l < t.length; l++)f(t[l], l, o, t); else { var c = {}, p = Object.keys(t).sort(i); for (l = 0; l < p.length; l++) { var s = p[l]; f(t[s], s, o, t), c[s] = t[s] } if (void 0 === u) return c; r.push([u, n, t]), u[n] = c } o.pop() } } function u(r) { return r = void 0 !== r ? r : function (r, e) { return e }, function (t, n) { if (e.length > 0) for (var i = 0; i < e.length; i++) { var o = e[i]; if (o[1] === t && o[0] === n) { n = "[Circular]", e.splice(i, 1); break } } return r.call(this, t, n) } }
    }, {}], "pPhZ": [function (require, module, exports) {
        "use strict"; var r = Object.prototype.hasOwnProperty, t = Array.isArray, e = function () { for (var r = [], t = 0; t < 256; ++t)r.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase()); return r }(), o = function (r) { for (; r.length > 1;) { var e = r.pop(), o = e.obj[e.prop]; if (t(o)) { for (var n = [], c = 0; c < o.length; ++c)void 0 !== o[c] && n.push(o[c]); e.obj[e.prop] = n } } }, n = function (r, t) { for (var e = t && t.plainObjects ? Object.create(null) : {}, o = 0; o < r.length; ++o)void 0 !== r[o] && (e[o] = r[o]); return e }, c = function e(o, c, u) { if (!c) return o; if ("object" != typeof c) { if (t(o)) o.push(c); else { if (!o || "object" != typeof o) return [o, c]; (u && (u.plainObjects || u.allowPrototypes) || !r.call(Object.prototype, c)) && (o[c] = !0) } return o } if (!o || "object" != typeof o) return [o].concat(c); var f = o; return t(o) && !t(c) && (f = n(o, u)), t(o) && t(c) ? (c.forEach(function (t, n) { if (r.call(o, n)) { var c = o[n]; c && "object" == typeof c && t && "object" == typeof t ? o[n] = e(c, t, u) : o.push(t) } else o[n] = t }), o) : Object.keys(c).reduce(function (t, o) { var n = c[o]; return r.call(t, o) ? t[o] = e(t[o], n, u) : t[o] = n, t }, f) }, u = function (r, t) { return Object.keys(t).reduce(function (r, e) { return r[e] = t[e], r }, r) }, f = function (r, t, e) { var o = r.replace(/\+/g, " "); if ("iso-8859-1" === e) return o.replace(/%[0-9a-f]{2}/gi, unescape); try { return decodeURIComponent(o) } catch (n) { return o } }, p = function (r, t, o) { if (0 === r.length) return r; var n = r; if ("symbol" == typeof r ? n = Symbol.prototype.toString.call(r) : "string" != typeof r && (n = String(r)), "iso-8859-1" === o) return escape(n).replace(/%u[0-9a-f]{4}/gi, function (r) { return "%26%23" + parseInt(r.slice(2), 16) + "%3B" }); for (var c = "", u = 0; u < n.length; ++u) { var f = n.charCodeAt(u); 45 === f || 46 === f || 95 === f || 126 === f || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 ? c += n.charAt(u) : f < 128 ? c += e[f] : f < 2048 ? c += e[192 | f >> 6] + e[128 | 63 & f] : f < 55296 || f >= 57344 ? c += e[224 | f >> 12] + e[128 | f >> 6 & 63] + e[128 | 63 & f] : (u += 1, f = 65536 + ((1023 & f) << 10 | 1023 & n.charCodeAt(u)), c += e[240 | f >> 18] + e[128 | f >> 12 & 63] + e[128 | f >> 6 & 63] + e[128 | 63 & f]) } return c }, a = function (r) { for (var t = [{ obj: { o: r }, prop: "o" }], e = [], n = 0; n < t.length; ++n)for (var c = t[n], u = c.obj[c.prop], f = Object.keys(u), p = 0; p < f.length; ++p) { var a = f[p], i = u[a]; "object" == typeof i && null !== i && -1 === e.indexOf(i) && (t.push({ obj: u, prop: a }), e.push(i)) } return o(t), r }, i = function (r) { return "[object RegExp]" === Object.prototype.toString.call(r) }, s = function (r) { return !(!r || "object" != typeof r) && !!(r.constructor && r.constructor.isBuffer && r.constructor.isBuffer(r)) }, l = function (r, t) { return [].concat(r, t) }, b = function (r, e) { if (t(r)) { for (var o = [], n = 0; n < r.length; n += 1)o.push(e(r[n])); return o } return e(r) }; module.exports = { arrayToObject: n, assign: u, combine: l, compact: a, decode: f, encode: p, isBuffer: s, isRegExp: i, maybeMap: b, merge: c };
    }, {}], "VWmG": [function (require, module, exports) {
        "use strict"; var r = String.prototype.replace, t = /%20/g, e = require("./utils"), n = { RFC1738: "RFC1738", RFC3986: "RFC3986" }; module.exports = e.assign({ default: n.RFC3986, formatters: { RFC1738: function (e) { return r.call(e, t, "+") }, RFC3986: function (r) { return String(r) } } }, n);
    }, { "./utils": "pPhZ" }], "OqWE": [function (require, module, exports) {
        "use strict"; var e = require("./utils"), t = require("./formats"), r = Object.prototype.hasOwnProperty, o = { brackets: function (e) { return e + "[]" }, comma: "comma", indices: function (e, t) { return e + "[" + t + "]" }, repeat: function (e) { return e } }, n = Array.isArray, i = Array.prototype.push, l = function (e, t) { i.apply(e, n(t) ? t : [t]) }, a = Date.prototype.toISOString, f = t.default, s = { addQueryPrefix: !1, allowDots: !1, charset: "utf-8", charsetSentinel: !1, delimiter: "&", encode: !0, encoder: e.encode, encodeValuesOnly: !1, format: f, formatter: t.formatters[f], indices: !1, serializeDate: function (e) { return a.call(e) }, skipNulls: !1, strictNullHandling: !1 }, c = function (e) { return "string" == typeof e || "number" == typeof e || "boolean" == typeof e || "symbol" == typeof e || "bigint" == typeof e }, u = function t(r, o, i, a, f, u, d, y, p, m, h, v, b) { var D = r; if ("function" == typeof d ? D = d(o, D) : D instanceof Date ? D = m(D) : "comma" === i && n(D) && (D = e.maybeMap(D, function (e) { return e instanceof Date ? m(e) : e }).join(",")), null === D) { if (a) return u && !v ? u(o, s.encoder, b, "key") : o; D = "" } if (c(D) || e.isBuffer(D)) return u ? [h(v ? o : u(o, s.encoder, b, "key")) + "=" + h(u(D, s.encoder, b, "value"))] : [h(o) + "=" + h(String(D))]; var w, g = []; if (void 0 === D) return g; if (n(d)) w = d; else { var k = Object.keys(D); w = y ? k.sort(y) : k } for (var N = 0; N < w.length; ++N) { var O = w[N], S = D[O]; if (!f || null !== S) { var x = n(D) ? "function" == typeof i ? i(o, O) : o : o + (p ? "." + O : "[" + O + "]"); l(g, t(S, x, i, a, f, u, d, y, p, m, h, v, b)) } } return g }, d = function (e) { if (!e) return s; if (null !== e.encoder && void 0 !== e.encoder && "function" != typeof e.encoder) throw new TypeError("Encoder has to be a function."); var o = e.charset || s.charset; if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined"); var i = t.default; if (void 0 !== e.format) { if (!r.call(t.formatters, e.format)) throw new TypeError("Unknown format option provided."); i = e.format } var l = t.formatters[i], a = s.filter; return ("function" == typeof e.filter || n(e.filter)) && (a = e.filter), { addQueryPrefix: "boolean" == typeof e.addQueryPrefix ? e.addQueryPrefix : s.addQueryPrefix, allowDots: void 0 === e.allowDots ? s.allowDots : !!e.allowDots, charset: o, charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : s.charsetSentinel, delimiter: void 0 === e.delimiter ? s.delimiter : e.delimiter, encode: "boolean" == typeof e.encode ? e.encode : s.encode, encoder: "function" == typeof e.encoder ? e.encoder : s.encoder, encodeValuesOnly: "boolean" == typeof e.encodeValuesOnly ? e.encodeValuesOnly : s.encodeValuesOnly, filter: a, formatter: l, serializeDate: "function" == typeof e.serializeDate ? e.serializeDate : s.serializeDate, skipNulls: "boolean" == typeof e.skipNulls ? e.skipNulls : s.skipNulls, sort: "function" == typeof e.sort ? e.sort : null, strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : s.strictNullHandling } }; module.exports = function (e, t) { var r, i = e, a = d(t); "function" == typeof a.filter ? i = (0, a.filter)("", i) : n(a.filter) && (r = a.filter); var f, s = []; if ("object" != typeof i || null === i) return ""; f = t && t.arrayFormat in o ? t.arrayFormat : t && "indices" in t ? t.indices ? "indices" : "repeat" : "indices"; var c = o[f]; r || (r = Object.keys(i)), a.sort && r.sort(a.sort); for (var y = 0; y < r.length; ++y) { var p = r[y]; a.skipNulls && null === i[p] || l(s, u(i[p], p, c, a.strictNullHandling, a.skipNulls, a.encode ? a.encoder : null, a.filter, a.sort, a.allowDots, a.serializeDate, a.formatter, a.encodeValuesOnly, a.charset)) } var m = s.join(a.delimiter), h = !0 === a.addQueryPrefix ? "?" : ""; return a.charsetSentinel && ("iso-8859-1" === a.charset ? h += "utf8=%26%2310003%3B&" : h += "utf8=%E2%9C%93&"), m.length > 0 ? h + m : "" };
    }, { "./utils": "pPhZ", "./formats": "VWmG" }], "Q782": [function (require, module, exports) {
        "use strict"; var e = require("./utils"), t = Object.prototype.hasOwnProperty, r = Array.isArray, i = { allowDots: !1, allowPrototypes: !1, arrayLimit: 20, charset: "utf-8", charsetSentinel: !1, comma: !1, decoder: e.decode, delimiter: "&", depth: 5, ignoreQueryPrefix: !1, interpretNumericEntities: !1, parameterLimit: 1e3, parseArrays: !0, plainObjects: !1, strictNullHandling: !1 }, o = function (e) { return e.replace(/&#(\d+);/g, function (e, t) { return String.fromCharCode(parseInt(t, 10)) }) }, a = function (e, t) { return e && "string" == typeof e && t.comma && e.indexOf(",") > -1 ? e.split(",") : e }, n = "utf8=%26%2310003%3B", l = "utf8=%E2%9C%93", c = function (c, s) { var p, d = {}, u = s.ignoreQueryPrefix ? c.replace(/^\?/, "") : c, f = s.parameterLimit === 1 / 0 ? void 0 : s.parameterLimit, m = u.split(s.delimiter, f), y = -1, h = s.charset; if (s.charsetSentinel) for (p = 0; p < m.length; ++p)0 === m[p].indexOf("utf8=") && (m[p] === l ? h = "utf-8" : m[p] === n && (h = "iso-8859-1"), y = p, p = m.length); for (p = 0; p < m.length; ++p)if (p !== y) { var b, g, O = m[p], v = O.indexOf("]="), w = -1 === v ? O.indexOf("=") : v + 1; -1 === w ? (b = s.decoder(O, i.decoder, h, "key"), g = s.strictNullHandling ? null : "") : (b = s.decoder(O.slice(0, w), i.decoder, h, "key"), g = e.maybeMap(a(O.slice(w + 1), s), function (e) { return s.decoder(e, i.decoder, h, "value") })), g && s.interpretNumericEntities && "iso-8859-1" === h && (g = o(g)), O.indexOf("[]=") > -1 && (g = r(g) ? [g] : g), t.call(d, b) ? d[b] = e.combine(d[b], g) : d[b] = g } return d }, s = function (e, t, r, i) { for (var o = i ? t : a(t, r), n = e.length - 1; n >= 0; --n) { var l, c = e[n]; if ("[]" === c && r.parseArrays) l = [].concat(o); else { l = r.plainObjects ? Object.create(null) : {}; var s = "[" === c.charAt(0) && "]" === c.charAt(c.length - 1) ? c.slice(1, -1) : c, p = parseInt(s, 10); r.parseArrays || "" !== s ? !isNaN(p) && c !== s && String(p) === s && p >= 0 && r.parseArrays && p <= r.arrayLimit ? (l = [])[p] = o : l[s] = o : l = { 0: o } } o = l } return o }, p = function (e, r, i, o) { if (e) { var a = i.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, n = /(\[[^[\]]*])/g, l = i.depth > 0 && /(\[[^[\]]*])/.exec(a), c = l ? a.slice(0, l.index) : a, p = []; if (c) { if (!i.plainObjects && t.call(Object.prototype, c) && !i.allowPrototypes) return; p.push(c) } for (var d = 0; i.depth > 0 && null !== (l = n.exec(a)) && d < i.depth;) { if (d += 1, !i.plainObjects && t.call(Object.prototype, l[1].slice(1, -1)) && !i.allowPrototypes) return; p.push(l[1]) } return l && p.push("[" + a.slice(l.index) + "]"), s(p, r, i, o) } }, d = function (t) { if (!t) return i; if (null !== t.decoder && void 0 !== t.decoder && "function" != typeof t.decoder) throw new TypeError("Decoder has to be a function."); if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined"); var r = void 0 === t.charset ? i.charset : t.charset; return { allowDots: void 0 === t.allowDots ? i.allowDots : !!t.allowDots, allowPrototypes: "boolean" == typeof t.allowPrototypes ? t.allowPrototypes : i.allowPrototypes, arrayLimit: "number" == typeof t.arrayLimit ? t.arrayLimit : i.arrayLimit, charset: r, charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : i.charsetSentinel, comma: "boolean" == typeof t.comma ? t.comma : i.comma, decoder: "function" == typeof t.decoder ? t.decoder : i.decoder, delimiter: "string" == typeof t.delimiter || e.isRegExp(t.delimiter) ? t.delimiter : i.delimiter, depth: "number" == typeof t.depth || !1 === t.depth ? +t.depth : i.depth, ignoreQueryPrefix: !0 === t.ignoreQueryPrefix, interpretNumericEntities: "boolean" == typeof t.interpretNumericEntities ? t.interpretNumericEntities : i.interpretNumericEntities, parameterLimit: "number" == typeof t.parameterLimit ? t.parameterLimit : i.parameterLimit, parseArrays: !1 !== t.parseArrays, plainObjects: "boolean" == typeof t.plainObjects ? t.plainObjects : i.plainObjects, strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : i.strictNullHandling } }; module.exports = function (t, r) { var i = d(r); if ("" === t || null == t) return i.plainObjects ? Object.create(null) : {}; for (var o = "string" == typeof t ? c(t, i) : t, a = i.plainObjects ? Object.create(null) : {}, n = Object.keys(o), l = 0; l < n.length; ++l) { var s = n[l], u = p(s, o[s], i, "string" == typeof t); a = e.merge(a, u, i) } return e.compact(a) };
    }, { "./utils": "pPhZ" }], "rRMW": [function (require, module, exports) {
        "use strict"; var r = require("./stringify"), e = require("./parse"), s = require("./formats"); module.exports = { formats: s, parse: e, stringify: r };
    }, { "./stringify": "OqWE", "./parse": "Q782", "./formats": "VWmG" }], "rf7W": [function (require, module, exports) {
        "use strict"; function o(t) { return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o })(t) } function t(t) { return null !== t && "object" === o(t) } module.exports = t;
    }, {}], "bs5T": [function (require, module, exports) {
        "use strict"; function t(e) { return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(e) } var e = require("./is-object"); function r(t) { if (t) return i(t) } function i(t) { for (var e in r.prototype) Object.prototype.hasOwnProperty.call(r.prototype, e) && (t[e] = r.prototype[e]); return t } module.exports = r, r.prototype.clearTimeout = function () { return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), clearTimeout(this._uploadTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, delete this._uploadTimeoutTimer, this }, r.prototype.parse = function (t) { return this._parser = t, this }, r.prototype.responseType = function (t) { return this._responseType = t, this }, r.prototype.serialize = function (t) { return this._serializer = t, this }, r.prototype.timeout = function (e) { if (!e || "object" !== t(e)) return this._timeout = e, this._responseTimeout = 0, this._uploadTimeout = 0, this; for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r)) switch (r) { case "deadline": this._timeout = e.deadline; break; case "response": this._responseTimeout = e.response; break; case "upload": this._uploadTimeout = e.upload; break; default: console.warn("Unknown timeout option", r) }return this }, r.prototype.retry = function (t, e) { return 0 !== arguments.length && !0 !== t || (t = 1), t <= 0 && (t = 0), this._maxRetries = t, this._retries = 0, this._retryCallback = e, this }; var o = new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]), s = new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]); r.prototype._shouldRetry = function (t, e) { if (!this._maxRetries || this._retries++ >= this._maxRetries) return !1; if (this._retryCallback) try { var r = this._retryCallback(t, e); if (!0 === r) return !0; if (!1 === r) return !1 } catch (i) { console.error(i) } if (e && e.status && s.has(e.status)) return !0; if (t) { if (t.code && o.has(t.code)) return !0; if (t.timeout && "ECONNABORTED" === t.code) return !0; if (t.crossDomain) return !0 } return !1 }, r.prototype._retry = function () { return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = !1, this.timedout = !1, this.timedoutError = null, this._end() }, r.prototype.then = function (t, e) { var r = this; if (!this._fullfilledPromise) { var i = this; this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise(function (t, e) { i.on("abort", function () { if (!(r._maxRetries && r._maxRetries > r._retries)) if (r.timedout && r.timedoutError) e(r.timedoutError); else { var t = new Error("Aborted"); t.code = "ABORTED", t.status = r.status, t.method = r.method, t.url = r.url, e(t) } }), i.end(function (r, i) { r ? e(r) : t(i) }) }) } return this._fullfilledPromise.then(t, e) }, r.prototype.catch = function (t) { return this.then(void 0, t) }, r.prototype.use = function (t) { return t(this), this }, r.prototype.ok = function (t) { if ("function" != typeof t) throw new Error("Callback required"); return this._okCallback = t, this }, r.prototype._isResponseOK = function (t) { return !!t && (this._okCallback ? this._okCallback(t) : t.status >= 200 && t.status < 300) }, r.prototype.get = function (t) { return this._header[t.toLowerCase()] }, r.prototype.getHeader = r.prototype.get, r.prototype.set = function (t, r) { if (e(t)) { for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && this.set(i, t[i]); return this } return this._header[t.toLowerCase()] = r, this.header[t] = r, this }, r.prototype.unset = function (t) { return delete this._header[t.toLowerCase()], delete this.header[t], this }, r.prototype.field = function (t, r) { if (null == t) throw new Error(".field(name, val) name can not be empty"); if (this._data) throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"); if (e(t)) { for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && this.field(i, t[i]); return this } if (Array.isArray(r)) { for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && this.field(t, r[o]); return this } if (null == r) throw new Error(".field(name, val) val can not be empty"); return "boolean" == typeof r && (r = String(r)), this._getFormData().append(t, r), this }, r.prototype.abort = function () { return this._aborted ? this : (this._aborted = !0, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort"), this) }, r.prototype._auth = function (t, e, r, i) { switch (r.type) { case "basic": this.set("Authorization", "Basic ".concat(i("".concat(t, ":").concat(e)))); break; case "auto": this.username = t, this.password = e; break; case "bearer": this.set("Authorization", "Bearer ".concat(t)) }return this }, r.prototype.withCredentials = function (t) { return void 0 === t && (t = !0), this._withCredentials = t, this }, r.prototype.redirects = function (t) { return this._maxRedirects = t, this }, r.prototype.maxResponseSize = function (t) { if ("number" != typeof t) throw new TypeError("Invalid argument"); return this._maxResponseSize = t, this }, r.prototype.toJSON = function () { return { method: this.method, url: this.url, data: this._data, headers: this._header } }, r.prototype.send = function (t) { var r = e(t), i = this._header["content-type"]; if (this._formData) throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"); if (r && !this._data) Array.isArray(t) ? this._data = [] : this._isHost(t) || (this._data = {}); else if (t && this._data && this._isHost(this._data)) throw new Error("Can't merge these send calls"); if (r && e(this._data)) for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (this._data[o] = t[o]); else "string" == typeof t ? (i || this.type("form"), (i = this._header["content-type"]) && (i = i.toLowerCase().trim()), this._data = "application/x-www-form-urlencoded" === i ? this._data ? "".concat(this._data, "&").concat(t) : t : (this._data || "") + t) : this._data = t; return !r || this._isHost(t) ? this : (i || this.type("json"), this) }, r.prototype.sortQuery = function (t) { return this._sort = void 0 === t || t, this }, r.prototype._finalizeQueryString = function () { var t = this._query.join("&"); if (t && (this.url += (this.url.includes("?") ? "&" : "?") + t), this._query.length = 0, this._sort) { var e = this.url.indexOf("?"); if (e >= 0) { var r = this.url.slice(e + 1).split("&"); "function" == typeof this._sort ? r.sort(this._sort) : r.sort(), this.url = this.url.slice(0, e) + "?" + r.join("&") } } }, r.prototype._appendQueryString = function () { console.warn("Unsupported") }, r.prototype._timeoutError = function (t, e, r) { if (!this._aborted) { var i = new Error("".concat(t + e, "ms exceeded")); i.timeout = e, i.code = "ECONNABORTED", i.errno = r, this.timedout = !0, this.timedoutError = i, this.abort(), this.callback(i) } }, r.prototype._setTimeouts = function () { var t = this; this._timeout && !this._timer && (this._timer = setTimeout(function () { t._timeoutError("Timeout of ", t._timeout, "ETIME") }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(function () { t._timeoutError("Response timeout of ", t._responseTimeout, "ETIMEDOUT") }, this._responseTimeout)) };
    }, { "./is-object": "rf7W" }], "uzNR": [function (require, module, exports) {
        "use strict"; function t(t, n) { var r; if ("undefined" == typeof Symbol || null == t[Symbol.iterator]) { if (Array.isArray(t) || (r = e(t)) || n && t && "number" == typeof t.length) { r && (t = r); var o = 0, i = function () { }; return { s: i, n: function () { return o >= t.length ? { done: !0 } : { done: !1, value: t[o++] } }, e: function (t) { throw t }, f: i } } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } var a, l = !0, u = !1; return { s: function () { r = t[Symbol.iterator]() }, n: function () { var t = r.next(); return l = t.done, t }, e: function (t) { u = !0, a = t }, f: function () { try { l || null == r.return || r.return() } finally { if (u) throw a } } } } function e(t, e) { if (t) { if ("string" == typeof t) return n(t, e); var r = Object.prototype.toString.call(t).slice(8, -1); return "Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(t, e) : void 0 } } function n(t, e) { (null == e || e > t.length) && (e = t.length); for (var n = 0, r = new Array(e); n < e; n++)r[n] = t[n]; return r } exports.type = function (t) { return t.split(/ *; */).shift() }, exports.params = function (e) { var n, r = {}, o = t(e.split(/ *; */)); try { for (o.s(); !(n = o.n()).done;) { var i = n.value.split(/ *= */), a = i.shift(), l = i.shift(); a && l && (r[a] = l) } } catch (u) { o.e(u) } finally { o.f() } return r }, exports.parseLinks = function (e) { var n, r = {}, o = t(e.split(/ *, */)); try { for (o.s(); !(n = o.n()).done;) { var i = n.value.split(/ *; */), a = i[0].slice(1, -1); r[i[1].split(/ *= */)[1].slice(1, -1)] = a } } catch (l) { o.e(l) } finally { o.f() } return r }, exports.cleanHeader = function (t, e) { return delete t["content-type"], delete t["content-length"], delete t["transfer-encoding"], delete t.host, e && (delete t.authorization, delete t.cookie), t };
    }, {}], "LjRy": [function (require, module, exports) {
        "use strict"; var t = require("./utils"); function e(t) { if (t) return r(t) } function r(t) { for (var r in e.prototype) Object.prototype.hasOwnProperty.call(e.prototype, r) && (t[r] = e.prototype[r]); return t } module.exports = e, e.prototype.get = function (t) { return this.header[t.toLowerCase()] }, e.prototype._setHeaderProperties = function (e) { var r = e["content-type"] || ""; this.type = t.type(r); var s = t.params(r); for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (this[i] = s[i]); this.links = {}; try { e.link && (this.links = t.parseLinks(e.link)) } catch (o) { } }, e.prototype._setStatusProperties = function (t) { var e = t / 100 | 0; this.statusCode = t, this.status = this.statusCode, this.statusType = e, this.info = 1 === e, this.ok = 2 === e, this.redirect = 3 === e, this.clientError = 4 === e, this.serverError = 5 === e, this.error = (4 === e || 5 === e) && this.toError(), this.created = 201 === t, this.accepted = 202 === t, this.noContent = 204 === t, this.badRequest = 400 === t, this.unauthorized = 401 === t, this.notAcceptable = 406 === t, this.forbidden = 403 === t, this.notFound = 404 === t, this.unprocessableEntity = 422 === t };
    }, { "./utils": "uzNR" }], "XIKS": [function (require, module, exports) {
        "use strict"; function t(t) { return o(t) || n(t) || e(t) || r() } function r() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") } function e(t, r) { if (t) { if ("string" == typeof t) return a(t, r); var e = Object.prototype.toString.call(t).slice(8, -1); return "Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e ? Array.from(t) : "Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? a(t, r) : void 0 } } function n(t) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t) } function o(t) { if (Array.isArray(t)) return a(t) } function a(t, r) { (null == r || r > t.length) && (r = t.length); for (var e = 0, n = new Array(r); e < r; e++)n[e] = t[e]; return n } function i() { this._defaults = [] } ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function (t) { i.prototype[t] = function () { for (var r = arguments.length, e = new Array(r), n = 0; n < r; n++)e[n] = arguments[n]; return this._defaults.push({ fn: t, args: e }), this } }), i.prototype._setDefaults = function (r) { this._defaults.forEach(function (e) { r[e.fn].apply(r, t(e.args)) }) }, module.exports = i;
    }, {}], "jn4M": [function (require, module, exports) {
        "use strict"; function t(e) { return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(e) } var e; "undefined" != typeof window ? e = window : "undefined" == typeof self ? (console.warn("Using browser-only version of superagent in non-browser environment"), e = void 0) : e = self; var r = require("component-emitter"), o = require("fast-safe-stringify"), n = require("qs"), s = require("./request-base"), i = require("./is-object"), a = require("./response-base"), u = require("./agent-base"); function p() { } module.exports = function (t, e) { return "function" == typeof e ? new exports.Request("GET", t).end(e) : 1 === arguments.length ? new exports.Request("GET", t) : new exports.Request(t, e) }, exports = module.exports; var c = exports; exports.Request = T, c.getXHR = function () { if (e.XMLHttpRequest && (!e.location || "file:" !== e.location.protocol || !e.ActiveXObject)) return new XMLHttpRequest; try { return new ActiveXObject("Microsoft.XMLHTTP") } catch (t) { } try { return new ActiveXObject("Msxml2.XMLHTTP.6.0") } catch (r) { } try { return new ActiveXObject("Msxml2.XMLHTTP.3.0") } catch (o) { } try { return new ActiveXObject("Msxml2.XMLHTTP") } catch (n) { } throw new Error("Browser-only version of superagent could not find XHR") }; var h = "".trim ? function (t) { return t.trim() } : function (t) { return t.replace(/(^\s*|\s*$)/g, "") }; function l(t) { if (!i(t)) return t; var e = []; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && d(e, r, t[r]); return e.join("&") } function d(t, e, r) { if (void 0 !== r) if (null !== r) if (Array.isArray(r)) r.forEach(function (r) { d(t, e, r) }); else if (i(r)) for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && d(t, "".concat(e, "[").concat(o, "]"), r[o]); else t.push(encodeURI(e) + "=" + encodeURIComponent(r)); else t.push(encodeURI(e)) } function f(t) { for (var e, r, o = {}, n = t.split("&"), s = 0, i = n.length; s < i; ++s)-1 === (r = (e = n[s]).indexOf("=")) ? o[decodeURIComponent(e)] = "" : o[decodeURIComponent(e.slice(0, r))] = decodeURIComponent(e.slice(r + 1)); return o } function y(t) { for (var e, r, o, n, s = t.split(/\r?\n/), i = {}, a = 0, u = s.length; a < u; ++a)-1 !== (e = (r = s[a]).indexOf(":")) && (o = r.slice(0, e).toLowerCase(), n = h(r.slice(e + 1)), i[o] = n); return i } function m(t) { return /[/+]json($|[^-\w])/i.test(t) } function w(t) { this.req = t, this.xhr = this.req.xhr, this.text = "HEAD" !== this.req.method && ("" === this.xhr.responseType || "text" === this.xhr.responseType) || void 0 === this.xhr.responseType ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText; var e = this.xhr.status; 1223 === e && (e = 204), this._setStatusProperties(e), this.headers = y(this.xhr.getAllResponseHeaders()), this.header = this.headers, this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), null === this.text && t._responseType ? this.body = this.xhr.response : this.body = "HEAD" === this.req.method ? null : this._parseBody(this.text ? this.text : this.xhr.response) } function T(t, e) { var r = this; this._query = this._query || [], this.method = t, this.url = e, this.header = {}, this._header = {}, this.on("end", function () { var t, e = null, o = null; try { o = new w(r) } catch (n) { return (e = new Error("Parser is unable to parse the response")).parse = !0, e.original = n, r.xhr ? (e.rawResponse = void 0 === r.xhr.responseType ? r.xhr.responseText : r.xhr.response, e.status = r.xhr.status ? r.xhr.status : null, e.statusCode = e.status) : (e.rawResponse = null, e.status = null), r.callback(e) } r.emit("response", o); try { r._isResponseOK(o) || (t = new Error(o.statusText || o.text || "Unsuccessful HTTP response")) } catch (n) { t = n } t ? (t.original = e, t.response = o, t.status = o.status, r.callback(t, o)) : r.callback(null, o) }) } function b(t, e, r) { var o = c("DELETE", t); return "function" == typeof e && (r = e, e = null), e && o.send(e), r && o.end(r), o } c.serializeObject = l, c.parseString = f, c.types = { html: "text/html", json: "application/json", xml: "text/xml", urlencoded: "application/x-www-form-urlencoded", form: "application/x-www-form-urlencoded", "form-data": "application/x-www-form-urlencoded" }, c.serialize = { "application/x-www-form-urlencoded": n.stringify, "application/json": o }, c.parse = { "application/x-www-form-urlencoded": f, "application/json": JSON.parse }, a(w.prototype), w.prototype._parseBody = function (t) { var e = c.parse[this.type]; return this.req._parser ? this.req._parser(this, t) : (!e && m(this.type) && (e = c.parse["application/json"]), e && t && (t.length > 0 || t instanceof Object) ? e(t) : null) }, w.prototype.toError = function () { var t = this.req, e = t.method, r = t.url, o = "cannot ".concat(e, " ").concat(r, " (").concat(this.status, ")"), n = new Error(o); return n.status = this.status, n.method = e, n.url = r, n }, c.Response = w, r(T.prototype), s(T.prototype), T.prototype.type = function (t) { return this.set("Content-Type", c.types[t] || t), this }, T.prototype.accept = function (t) { return this.set("Accept", c.types[t] || t), this }, T.prototype.auth = function (e, r, o) { 1 === arguments.length && (r = ""), "object" === t(r) && null !== r && (o = r, r = ""), o || (o = { type: "function" == typeof btoa ? "basic" : "auto" }); return this._auth(e, r, o, function (t) { if ("function" == typeof btoa) return btoa(t); throw new Error("Cannot use basic auth, btoa is not a function") }) }, T.prototype.query = function (t) { return "string" != typeof t && (t = l(t)), t && this._query.push(t), this }, T.prototype.attach = function (t, e, r) { if (e) { if (this._data) throw new Error("superagent can't mix .send() and .attach()"); this._getFormData().append(t, e, r || e.name) } return this }, T.prototype._getFormData = function () { return this._formData || (this._formData = new e.FormData), this._formData }, T.prototype.callback = function (t, e) { if (this._shouldRetry(t, e)) return this._retry(); var r = this._callback; this.clearTimeout(), t && (this._maxRetries && (t.retries = this._retries - 1), this.emit("error", t)), r(t, e) }, T.prototype.crossDomainError = function () { var t = new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc."); t.crossDomain = !0, t.status = this.status, t.method = this.method, t.url = this.url, this.callback(t) }, T.prototype.agent = function () { return console.warn("This is not supported in browser version of superagent"), this }, T.prototype.ca = T.prototype.agent, T.prototype.buffer = T.prototype.ca, T.prototype.write = function () { throw new Error("Streaming is not supported in browser version of superagent") }, T.prototype.pipe = T.prototype.write, T.prototype._isHost = function (e) { return e && "object" === t(e) && !Array.isArray(e) && "[object Object]" !== Object.prototype.toString.call(e) }, T.prototype.end = function (t) { this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = !0, this._callback = t || p, this._finalizeQueryString(), this._end() }, T.prototype._setUploadTimeout = function () { var t = this; this._uploadTimeout && !this._uploadTimeoutTimer && (this._uploadTimeoutTimer = setTimeout(function () { t._timeoutError("Upload timeout of ", t._uploadTimeout, "ETIMEDOUT") }, this._uploadTimeout)) }, T.prototype._end = function () { if (this._aborted) return this.callback(new Error("The request has been aborted even before .end() was called")); var t = this; this.xhr = c.getXHR(); var e = this.xhr, r = this._formData || this._data; this._setTimeouts(), e.onreadystatechange = function () { var r = e.readyState; if (r >= 2 && t._responseTimeoutTimer && clearTimeout(t._responseTimeoutTimer), 4 === r) { var o; try { o = e.status } catch (n) { o = 0 } if (!o) { if (t.timedout || t._aborted) return; return t.crossDomainError() } t.emit("end") } }; var o = function (e, r) { r.total > 0 && (r.percent = r.loaded / r.total * 100, 100 === r.percent && clearTimeout(t._uploadTimeoutTimer)), r.direction = e, t.emit("progress", r) }; if (this.hasListeners("progress")) try { e.addEventListener("progress", o.bind(null, "download")), e.upload && e.upload.addEventListener("progress", o.bind(null, "upload")) } catch (a) { } e.upload && this._setUploadTimeout(); try { this.username && this.password ? e.open(this.method, this.url, !0, this.username, this.password) : e.open(this.method, this.url, !0) } catch (u) { return this.callback(u) } if (this._withCredentials && (e.withCredentials = !0), !this._formData && "GET" !== this.method && "HEAD" !== this.method && "string" != typeof r && !this._isHost(r)) { var n = this._header["content-type"], s = this._serializer || c.serialize[n ? n.split(";")[0] : ""]; !s && m(n) && (s = c.serialize["application/json"]), s && (r = s(r)) } for (var i in this.header) null !== this.header[i] && Object.prototype.hasOwnProperty.call(this.header, i) && e.setRequestHeader(i, this.header[i]); this._responseType && (e.responseType = this._responseType), this.emit("request", this), e.send(void 0 === r ? null : r) }, c.agent = function () { return new u }, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (t) { u.prototype[t.toLowerCase()] = function (e, r) { var o = new c.Request(t, e); return this._setDefaults(o), r && o.end(r), o } }), u.prototype.del = u.prototype.delete, c.get = function (t, e, r) { var o = c("GET", t); return "function" == typeof e && (r = e, e = null), e && o.query(e), r && o.end(r), o }, c.head = function (t, e, r) { var o = c("HEAD", t); return "function" == typeof e && (r = e, e = null), e && o.query(e), r && o.end(r), o }, c.options = function (t, e, r) { var o = c("OPTIONS", t); return "function" == typeof e && (r = e, e = null), e && o.send(e), r && o.end(r), o }, c.del = b, c.delete = b, c.patch = function (t, e, r) { var o = c("PATCH", t); return "function" == typeof e && (r = e, e = null), e && o.send(e), r && o.end(r), o }, c.post = function (t, e, r) { var o = c("POST", t); return "function" == typeof e && (r = e, e = null), e && o.send(e), r && o.end(r), o }, c.put = function (t, e, r) { var o = c("PUT", t); return "function" == typeof e && (r = e, e = null), e && o.send(e), r && o.end(r), o };
    }, { "component-emitter": "Wr69", "fast-safe-stringify": "SQZr", "qs": "rRMW", "./request-base": "bs5T", "./is-object": "rf7W", "./response-base": "LjRy", "./agent-base": "XIKS" }], "cZF8": [function (require, module, exports) {
        "use strict"; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.default = void 0; var e = r(require("./countries")), t = r(require("superagent")); function r(e) { return e && e.__esModule ? e : { default: e } } var u = "https://api.reliefweb.int/v1/disasters?appname=omundoagora&profile=full&offset=0&limit=10&preset=latest"; function n() { var r = []; return t.default.get(u).then(function (t) { return t.body.data.forEach(function (t) { r.push(e.default.find(function (e) { return e.iso3 == t.fields.country[0].iso3 })) }), r }) } var o = n; exports.default = o;
    }, { "./countries": "QNx4", "superagent": "jn4M" }], "QvaY": [function (require, module, exports) {
        "use strict"; var e = require("vue/dist/vue.esm-bundler.js"), t = u(require("./api.js")); function u(e) { return e && e.__esModule ? e : { default: e } } var n = { data: function () { return { affected: [] } }, beforeCreate: function () { var e = this; (0, t.default)().then(function (t) { e.affected = t }) }, mounted: function () { } }, r = (0, e.createApp)(n); r.mount("#app");
    }, { "vue/dist/vue.esm-bundler.js": "x0sI", "./api.js": "cZF8" }]
}, {}, ["QvaY"], null)
//# sourceMappingURL=js.aae4438d.js.map